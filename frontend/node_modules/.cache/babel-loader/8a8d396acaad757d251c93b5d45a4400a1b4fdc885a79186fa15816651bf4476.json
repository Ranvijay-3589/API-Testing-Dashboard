{"ast":null,"code":"import { propOr, pipe, last } from 'ramda';\nimport { isUndefined, replaceAll, isNotUndefined, trimCharsEnd } from 'ramda-adjunct';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) 2015 James Messinger\n *\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @public\n */\n\nconst isWindows = () => {\n  var _globalThis$process$p, _globalThis$process;\n  return /^win/.test((_globalThis$process$p = (_globalThis$process = globalThis.process) === null || _globalThis$process === void 0 ? void 0 : _globalThis$process.platform) !== null && _globalThis$process$p !== void 0 ? _globalThis$process$p : '');\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n * @public\n */\nexport const getProtocol = url => {\n  try {\n    const parsedUrl = new URL(url);\n    return trimCharsEnd(':', parsedUrl.protocol);\n  } catch (_unused) {\n    return undefined;\n  }\n};\n\n/**\n * Returns true if given URL has protocol.\n * @public\n */\nexport const hasProtocol = pipe(getProtocol, isNotUndefined);\n\n/**\n * Returns the lower-cased file extension of the given URL,\n * or an empty string if it has no extension.\n * @public\n */\nexport const getExtension = url => {\n  const lastDotPosition = url.lastIndexOf('.');\n  if (lastDotPosition >= 0) {\n    return url.substring(lastDotPosition).toLowerCase();\n  }\n  return '';\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n * @public\n */\nexport const isFileSystemPath = uri => {\n  if (globalThis.window !== undefined) {\n    /**\n     * We're running in a browser, so assume that all paths are URLs.\n     * This way, even relative paths will be treated as URLs rather than as filesystem paths.\n     */\n    return false;\n  }\n  const protocol = getProtocol(uri);\n  return isUndefined(protocol) || protocol === 'file' || /^[a-zA-Z]$/.test(protocol);\n};\n\n/**\n * Determines whether the given URI is an HTTP(S) URL.\n * @public\n */\nexport const isHttpUrl = url => {\n  const protocol = getProtocol(url);\n  return protocol === 'http' || protocol === 'https';\n};\n\n/**\n * Determines whether the given URI\n * @public\n */\nexport const isURI = uri => {\n  try {\n    return new URL(uri) && true;\n  } catch (_unused2) {\n    return false;\n  }\n};\n\n/**\n * @public\n */\n\n/**\n * Converts a URL to a local filesystem path.\n * @public\n */\nexport const toFileSystemPath = (uri, options) => {\n  // RegExp patterns to URL-decode special characters for local filesystem paths\n  const urlDecodePatterns = [/%23/g, '#', /%24/g, '$', /%26/g, '&', /%2C/g, ',', /%40/g, '@'];\n  const keepFileProtocol = propOr(false, 'keepFileProtocol', options);\n  const isWindowsPredicate = propOr(isWindows, 'isWindows', options);\n\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  let path = decodeURI(uri);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substring(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substring(8) : path.substring(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindowsPredicate() && path[1] === '/') {\n      path = \"\".concat(path[0], \":\").concat(path.substring(1));\n    }\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = \"file:///\".concat(path);\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindowsPredicate() ? path : \"/\".concat(path);\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindowsPredicate() && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = replaceAll('/', '\\\\', path);\n\n    // Capitalize the drive letter\n    if (path.substring(1, 3) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substring(1);\n    }\n  }\n  return path;\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where resolver is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *```\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n * ```\n * @public\n */\nexport const fromFileSystemPath = uri => {\n  const urlEncodePatterns = [/\\?/g, '%3F', /#/g, '%23'];\n  let path = uri;\n\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows()) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n * @public\n */\nexport const getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n * @public\n */\nexport const stripHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  let hashStrippedUri = uri;\n  if (hashIndex >= 0) {\n    hashStrippedUri = uri.substring(0, hashIndex);\n  }\n  return hashStrippedUri;\n};\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n * @public\n */\nexport const cwd = () => {\n  var _globalThis$process$c, _globalThis$process2;\n  if (globalThis.window !== undefined) {\n    return stripHash(globalThis.location.href);\n  }\n  const path = (_globalThis$process$c = (_globalThis$process2 = globalThis.process) === null || _globalThis$process2 === void 0 ? void 0 : _globalThis$process2.cwd()) !== null && _globalThis$process$c !== void 0 ? _globalThis$process$c : '/';\n  const lastChar = last(path);\n  if (['/', '\\\\'].includes(lastChar)) {\n    return path;\n  }\n  return path + (isWindows() ? '\\\\' : '/');\n};\n\n/**\n * Resolves a target URI relative to a base URI in a manner similar to that of a Web browser resolving an anchor tag HREF.\n * @public\n */\nexport const resolve = (from, to) => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const {\n      pathname,\n      search,\n      hash\n    } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\n/**\n * Sanitizes/Encodes URI to it's url encoded form.\n *\n * The functional will compensate with the usecase when\n * already sanitized URI is passed to it,\n * by first unsatizing it and then performing sanitization again.\n * @public\n */\n\nexport const sanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return fromFileSystemPath(toFileSystemPath(uri));\n  }\n  try {\n    return new URL(uri).toString();\n  } catch (_unused3) {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI#encoding_for_ipv6\n    return encodeURI(decodeURI(uri)).replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n};\n\n/**\n * Unsanitizes/Decodes URI to it's url encoded form.\n * This function already assumes that hash part of the URI\n * has been removed prior to transforming it to it's sanitized form.\n * @public\n */\n\nexport const unsanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return toFileSystemPath(uri);\n  }\n  return decodeURI(uri);\n};","map":{"version":3,"names":["propOr","pipe","last","isUndefined","replaceAll","isNotUndefined","trimCharsEnd","isWindows","_globalThis$process$p","_globalThis$process","test","globalThis","process","platform","getProtocol","url","parsedUrl","URL","protocol","_unused","undefined","hasProtocol","getExtension","lastDotPosition","lastIndexOf","substring","toLowerCase","isFileSystemPath","uri","window","isHttpUrl","isURI","_unused2","toFileSystemPath","options","urlDecodePatterns","keepFileProtocol","isWindowsPredicate","path","decodeURI","i","length","replace","isFileUrl","concat","toUpperCase","fromFileSystemPath","urlEncodePatterns","encodeURI","getHash","hashIndex","indexOf","stripHash","hashStrippedUri","cwd","_globalThis$process$c","_globalThis$process2","location","href","lastChar","includes","resolve","from","to","resolvedUrl","pathname","search","hash","toString","sanitize","_unused3","unsanitize"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-reference/src/util/url.mjs"],"sourcesContent":["import { propOr, pipe, last } from 'ramda';\nimport { isUndefined, replaceAll, isNotUndefined, trimCharsEnd } from 'ramda-adjunct';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) 2015 James Messinger\n *\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @public\n */\n\nconst isWindows = () => {\n  var _globalThis$process$p, _globalThis$process;\n  return /^win/.test((_globalThis$process$p = (_globalThis$process = globalThis.process) === null || _globalThis$process === void 0 ? void 0 : _globalThis$process.platform) !== null && _globalThis$process$p !== void 0 ? _globalThis$process$p : '');\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n * @public\n */\nexport const getProtocol = url => {\n  try {\n    const parsedUrl = new URL(url);\n    return trimCharsEnd(':', parsedUrl.protocol);\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Returns true if given URL has protocol.\n * @public\n */\nexport const hasProtocol = pipe(getProtocol, isNotUndefined);\n\n/**\n * Returns the lower-cased file extension of the given URL,\n * or an empty string if it has no extension.\n * @public\n */\nexport const getExtension = url => {\n  const lastDotPosition = url.lastIndexOf('.');\n  if (lastDotPosition >= 0) {\n    return url.substring(lastDotPosition).toLowerCase();\n  }\n  return '';\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n * @public\n */\nexport const isFileSystemPath = uri => {\n  if (globalThis.window !== undefined) {\n    /**\n     * We're running in a browser, so assume that all paths are URLs.\n     * This way, even relative paths will be treated as URLs rather than as filesystem paths.\n     */\n    return false;\n  }\n  const protocol = getProtocol(uri);\n  return isUndefined(protocol) || protocol === 'file' || /^[a-zA-Z]$/.test(protocol);\n};\n\n/**\n * Determines whether the given URI is an HTTP(S) URL.\n * @public\n */\nexport const isHttpUrl = url => {\n  const protocol = getProtocol(url);\n  return protocol === 'http' || protocol === 'https';\n};\n\n/**\n * Determines whether the given URI\n * @public\n */\nexport const isURI = uri => {\n  try {\n    return new URL(uri) && true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * @public\n */\n\n/**\n * Converts a URL to a local filesystem path.\n * @public\n */\nexport const toFileSystemPath = (uri, options) => {\n  // RegExp patterns to URL-decode special characters for local filesystem paths\n  const urlDecodePatterns = [/%23/g, '#', /%24/g, '$', /%26/g, '&', /%2C/g, ',', /%40/g, '@'];\n  const keepFileProtocol = propOr(false, 'keepFileProtocol', options);\n  const isWindowsPredicate = propOr(isWindows, 'isWindows', options);\n\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  let path = decodeURI(uri);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substring(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substring(8) : path.substring(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindowsPredicate() && path[1] === '/') {\n      path = `${path[0]}:${path.substring(1)}`;\n    }\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = `file:///${path}`;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindowsPredicate() ? path : `/${path}`;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindowsPredicate() && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = replaceAll('/', '\\\\', path);\n\n    // Capitalize the drive letter\n    if (path.substring(1, 3) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substring(1);\n    }\n  }\n  return path;\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where resolver is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *```\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n * ```\n * @public\n */\nexport const fromFileSystemPath = uri => {\n  const urlEncodePatterns = [/\\?/g, '%3F', /#/g, '%23'];\n  let path = uri;\n\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows()) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n * @public\n */\nexport const getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n * @public\n */\nexport const stripHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  let hashStrippedUri = uri;\n  if (hashIndex >= 0) {\n    hashStrippedUri = uri.substring(0, hashIndex);\n  }\n  return hashStrippedUri;\n};\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n * @public\n */\nexport const cwd = () => {\n  var _globalThis$process$c, _globalThis$process2;\n  if (globalThis.window !== undefined) {\n    return stripHash(globalThis.location.href);\n  }\n  const path = (_globalThis$process$c = (_globalThis$process2 = globalThis.process) === null || _globalThis$process2 === void 0 ? void 0 : _globalThis$process2.cwd()) !== null && _globalThis$process$c !== void 0 ? _globalThis$process$c : '/';\n  const lastChar = last(path);\n  if (['/', '\\\\'].includes(lastChar)) {\n    return path;\n  }\n  return path + (isWindows() ? '\\\\' : '/');\n};\n\n/**\n * Resolves a target URI relative to a base URI in a manner similar to that of a Web browser resolving an anchor tag HREF.\n * @public\n */\nexport const resolve = (from, to) => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const {\n      pathname,\n      search,\n      hash\n    } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\n/**\n * Sanitizes/Encodes URI to it's url encoded form.\n *\n * The functional will compensate with the usecase when\n * already sanitized URI is passed to it,\n * by first unsatizing it and then performing sanitization again.\n * @public\n */\n\nexport const sanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return fromFileSystemPath(toFileSystemPath(uri));\n  }\n  try {\n    return new URL(uri).toString();\n  } catch {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI#encoding_for_ipv6\n    return encodeURI(decodeURI(uri)).replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n};\n\n/**\n * Unsanitizes/Decodes URI to it's url encoded form.\n * This function already assumes that hash part of the URI\n * has been removed prior to transforming it to it's sanitized form.\n * @public\n */\n\nexport const unsanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return toFileSystemPath(uri);\n  }\n  return decodeURI(uri);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}