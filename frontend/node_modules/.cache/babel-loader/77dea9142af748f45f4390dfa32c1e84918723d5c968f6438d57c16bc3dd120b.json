{"ast":null,"code":"import '../helpers/fetch-polyfill.node.js';\nimport { serializeRequest } from './serializers/request/index.js';\nimport { serializeResponse } from './serializers/response/index.js';\nexport { serializeResponse as serializeRes };\n\n// Handles fetch-like syntax and the case where there is only one object passed-in\n// (which will have the URL as a property). Also serializes the response.\nexport default async function http(url) {\n  let request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof url === 'object') {\n    request = url;\n    url = request.url;\n  }\n  request.headers = request.headers || {};\n\n  // Serializes query, for convenience\n  // Should be the last thing we do, as its hard to mutate the URL with\n  // the search string, but much easier to manipulate the req.query object\n  request = serializeRequest(request);\n\n  // Newlines in header values cause weird error messages from `window.fetch`,\n  // so let's message them out.\n  // Context: https://stackoverflow.com/a/50709178\n  if (request.headers) {\n    Object.keys(request.headers).forEach(headerName => {\n      const value = request.headers[headerName];\n      if (typeof value === 'string') {\n        request.headers[headerName] = value.replace(/\\n+/g, ' ');\n      }\n    });\n  }\n\n  // Wait for the request interceptor, if it was provided\n  // WARNING: don't put anything between this and the request firing unless\n  // you have a good reason!\n  if (request.requestInterceptor) {\n    request = (await request.requestInterceptor(request)) || request;\n  }\n\n  /**\n   *  For content-type=multipart/form-data remove content-type from request before fetch,\n   *  so that correct one with `boundary` is set when request body is different from boundary encoded string.\n   */\n  const contentType = request.headers['content-type'] || request.headers['Content-Type'];\n  if (/multipart\\/form-data/i.test(contentType)) {\n    delete request.headers['content-type'];\n    delete request.headers['Content-Type'];\n  }\n\n  // eslint-disable-next-line no-undef\n  let res;\n  try {\n    res = await (request.userFetch || fetch)(request.url, request);\n    res = await serializeResponse(res, url, request);\n    if (request.responseInterceptor) {\n      res = (await request.responseInterceptor(res)) || res;\n    }\n  } catch (resError) {\n    if (!res) {\n      // res is completely absent, so we can't construct our own error\n      // so we'll just throw the error we got\n      throw resError;\n    }\n    const error = new Error(res.statusText || \"response status is \".concat(res.status));\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.responseError = resError;\n    throw error;\n  }\n  if (!res.ok) {\n    const error = new Error(res.statusText || \"response status is \".concat(res.status));\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.response = res;\n    throw error;\n  }\n  return res;\n}\n\n// Wrap a http function ( there are otherways to do this, consider this deprecated )\nexport function makeHttp(httpFn, preFetch, postFetch) {\n  postFetch = postFetch || (a => a);\n  preFetch = preFetch || (a => a);\n  return req => {\n    if (typeof req === 'string') {\n      req = {\n        url: req\n      };\n    }\n    req = serializeRequest(req);\n    req = preFetch(req);\n    return postFetch(httpFn(req));\n  };\n}","map":{"version":3,"names":["serializeRequest","serializeResponse","serializeRes","http","url","request","arguments","length","undefined","headers","Object","keys","forEach","headerName","value","replace","requestInterceptor","contentType","test","res","userFetch","fetch","responseInterceptor","resError","error","Error","statusText","concat","status","statusCode","responseError","ok","response","makeHttp","httpFn","preFetch","postFetch","a","req"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/swagger-client/es/http/index.js"],"sourcesContent":["import '../helpers/fetch-polyfill.node.js';\nimport { serializeRequest } from './serializers/request/index.js';\nimport { serializeResponse } from './serializers/response/index.js';\nexport { serializeResponse as serializeRes };\n\n// Handles fetch-like syntax and the case where there is only one object passed-in\n// (which will have the URL as a property). Also serializes the response.\nexport default async function http(url, request = {}) {\n  if (typeof url === 'object') {\n    request = url;\n    url = request.url;\n  }\n  request.headers = request.headers || {};\n\n  // Serializes query, for convenience\n  // Should be the last thing we do, as its hard to mutate the URL with\n  // the search string, but much easier to manipulate the req.query object\n  request = serializeRequest(request);\n\n  // Newlines in header values cause weird error messages from `window.fetch`,\n  // so let's message them out.\n  // Context: https://stackoverflow.com/a/50709178\n  if (request.headers) {\n    Object.keys(request.headers).forEach(headerName => {\n      const value = request.headers[headerName];\n      if (typeof value === 'string') {\n        request.headers[headerName] = value.replace(/\\n+/g, ' ');\n      }\n    });\n  }\n\n  // Wait for the request interceptor, if it was provided\n  // WARNING: don't put anything between this and the request firing unless\n  // you have a good reason!\n  if (request.requestInterceptor) {\n    request = (await request.requestInterceptor(request)) || request;\n  }\n\n  /**\n   *  For content-type=multipart/form-data remove content-type from request before fetch,\n   *  so that correct one with `boundary` is set when request body is different from boundary encoded string.\n   */\n  const contentType = request.headers['content-type'] || request.headers['Content-Type'];\n  if (/multipart\\/form-data/i.test(contentType)) {\n    delete request.headers['content-type'];\n    delete request.headers['Content-Type'];\n  }\n\n  // eslint-disable-next-line no-undef\n  let res;\n  try {\n    res = await (request.userFetch || fetch)(request.url, request);\n    res = await serializeResponse(res, url, request);\n    if (request.responseInterceptor) {\n      res = (await request.responseInterceptor(res)) || res;\n    }\n  } catch (resError) {\n    if (!res) {\n      // res is completely absent, so we can't construct our own error\n      // so we'll just throw the error we got\n      throw resError;\n    }\n    const error = new Error(res.statusText || `response status is ${res.status}`);\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.responseError = resError;\n    throw error;\n  }\n  if (!res.ok) {\n    const error = new Error(res.statusText || `response status is ${res.status}`);\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.response = res;\n    throw error;\n  }\n  return res;\n}\n\n// Wrap a http function ( there are otherways to do this, consider this deprecated )\nexport function makeHttp(httpFn, preFetch, postFetch) {\n  postFetch = postFetch || (a => a);\n  preFetch = preFetch || (a => a);\n  return req => {\n    if (typeof req === 'string') {\n      req = {\n        url: req\n      };\n    }\n    req = serializeRequest(req);\n    req = preFetch(req);\n    return postFetch(httpFn(req));\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}