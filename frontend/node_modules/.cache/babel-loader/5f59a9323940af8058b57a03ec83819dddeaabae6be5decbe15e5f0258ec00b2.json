{"ast":null,"code":"import parse from \"../parse/index.mjs\";\nimport testArrayDash from \"../test/array-dash.mjs\";\nimport testArrayIndex from \"../test/array-index.mjs\";\nimport TraceBuilder from \"./trace/TraceBuilder.mjs\";\nimport JSONRealm from \"./realms/json/index.mjs\";\nimport JSONPointerEvaluateError from \"../errors/JSONPointerEvaluateError.mjs\";\nimport JSONPointerTypeError from \"../errors/JSONPointerTypeError.mjs\";\nimport JSONPointerIndexError from \"../errors/JSONPointerIndexError.mjs\";\nimport JSONPointerKeyError from \"../errors/JSONPointerKeyError.mjs\";\nconst evaluate = function (value, jsonPointer) {\n  let {\n    strictArrays = true,\n    strictObjects = true,\n    realm = new JSONRealm(),\n    trace = true\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    result: parseResult,\n    tree: referenceTokens,\n    trace: parseTrace\n  } = parse(jsonPointer, {\n    trace: !!trace\n  });\n  const tracer = typeof trace === 'object' && trace !== null ? new TraceBuilder(trace, {\n    jsonPointer,\n    referenceTokens,\n    strictArrays,\n    strictObjects,\n    realm,\n    value\n  }) : null;\n  try {\n    let output;\n    if (!parseResult.success) {\n      let message = \"Invalid JSON Pointer: \\\"\".concat(jsonPointer, \"\\\". Syntax error at position \").concat(parseResult.maxMatched);\n      message += parseTrace ? \", expected \".concat(parseTrace.inferExpectations()) : '';\n      throw new JSONPointerEvaluateError(message, {\n        jsonPointer,\n        currentValue: value,\n        realm: realm.name\n      });\n    }\n    return referenceTokens.reduce((current, referenceToken, referenceTokenPosition) => {\n      if (realm.isArray(current)) {\n        if (testArrayDash(referenceToken)) {\n          if (strictArrays) {\n            throw new JSONPointerIndexError(\"Invalid array index \\\"-\\\" at position \".concat(referenceTokenPosition, \" in \\\"\").concat(jsonPointer, \"\\\". The \\\"-\\\" token always refers to a nonexistent element during evaluation\"), {\n              jsonPointer,\n              referenceTokens,\n              referenceToken,\n              referenceTokenPosition,\n              currentValue: current,\n              realm: realm.name\n            });\n          } else {\n            output = realm.evaluate(current, String(realm.sizeOf(current)));\n            tracer === null || tracer === void 0 || tracer.step({\n              referenceToken,\n              input: current,\n              output\n            });\n            return output;\n          }\n        }\n        if (!testArrayIndex(referenceToken)) {\n          throw new JSONPointerIndexError(\"Invalid array index \\\"\".concat(referenceToken, \"\\\" at position \").concat(referenceTokenPosition, \" in \\\"\").concat(jsonPointer, \"\\\": index MUST be \\\"0\\\", or digits without a leading \\\"0\\\"\"), {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        const index = Number(referenceToken);\n        if (!Number.isSafeInteger(index)) {\n          throw new JSONPointerIndexError(\"Invalid array index \\\"\".concat(referenceToken, \"\\\" at position \").concat(referenceTokenPosition, \" in \\\"\").concat(jsonPointer, \"\\\": index must be a safe integer\"), {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        if (!realm.has(current, referenceToken) && strictArrays) {\n          throw new JSONPointerIndexError(\"Invalid array index \\\"\".concat(referenceToken, \"\\\" at position \").concat(referenceTokenPosition, \" in \\\"\").concat(jsonPointer, \"\\\": index not found in array\"), {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        output = realm.evaluate(current, referenceToken);\n        tracer === null || tracer === void 0 || tracer.step({\n          referenceToken,\n          input: current,\n          output\n        });\n        return output;\n      }\n      if (realm.isObject(current)) {\n        if (!realm.has(current, referenceToken) && strictObjects) {\n          throw new JSONPointerKeyError(\"Invalid object key \\\"\".concat(referenceToken, \"\\\" at position \").concat(referenceTokenPosition, \" in \\\"\").concat(jsonPointer, \"\\\": key not found in object\"), {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        output = realm.evaluate(current, referenceToken);\n        tracer === null || tracer === void 0 || tracer.step({\n          referenceToken,\n          input: current,\n          output\n        });\n        return output;\n      }\n      throw new JSONPointerTypeError(\"Invalid reference token \\\"\".concat(referenceToken, \"\\\" at position \").concat(referenceTokenPosition, \" in \\\"\").concat(jsonPointer, \"\\\": cannot be applied to a non-object/non-array value\"), {\n        jsonPointer,\n        referenceTokens,\n        referenceToken,\n        referenceTokenPosition,\n        currentValue: current,\n        realm: realm.name\n      });\n    }, value);\n  } catch (error) {\n    tracer === null || tracer === void 0 || tracer.step({\n      referenceToken: error.referenceToken,\n      input: error.currentValue,\n      success: false,\n      reason: error.message\n    });\n    if (error instanceof JSONPointerEvaluateError) {\n      throw error;\n    }\n    throw new JSONPointerEvaluateError('Unexpected error during JSON Pointer evaluation', {\n      cause: error,\n      jsonPointer,\n      referenceTokens\n    });\n  }\n};\nexport default evaluate;","map":{"version":3,"names":["parse","testArrayDash","testArrayIndex","TraceBuilder","JSONRealm","JSONPointerEvaluateError","JSONPointerTypeError","JSONPointerIndexError","JSONPointerKeyError","evaluate","value","jsonPointer","strictArrays","strictObjects","realm","trace","arguments","length","undefined","result","parseResult","tree","referenceTokens","parseTrace","tracer","output","success","message","concat","maxMatched","inferExpectations","currentValue","name","reduce","current","referenceToken","referenceTokenPosition","isArray","String","sizeOf","step","input","index","Number","isSafeInteger","has","isObject","error","reason","cause"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swaggerexpert/json-pointer/es/evaluate/index.mjs"],"sourcesContent":["import parse from \"../parse/index.mjs\";\nimport testArrayDash from \"../test/array-dash.mjs\";\nimport testArrayIndex from \"../test/array-index.mjs\";\nimport TraceBuilder from \"./trace/TraceBuilder.mjs\";\nimport JSONRealm from \"./realms/json/index.mjs\";\nimport JSONPointerEvaluateError from \"../errors/JSONPointerEvaluateError.mjs\";\nimport JSONPointerTypeError from \"../errors/JSONPointerTypeError.mjs\";\nimport JSONPointerIndexError from \"../errors/JSONPointerIndexError.mjs\";\nimport JSONPointerKeyError from \"../errors/JSONPointerKeyError.mjs\";\nconst evaluate = (value, jsonPointer, {\n  strictArrays = true,\n  strictObjects = true,\n  realm = new JSONRealm(),\n  trace = true\n} = {}) => {\n  const {\n    result: parseResult,\n    tree: referenceTokens,\n    trace: parseTrace\n  } = parse(jsonPointer, {\n    trace: !!trace\n  });\n  const tracer = typeof trace === 'object' && trace !== null ? new TraceBuilder(trace, {\n    jsonPointer,\n    referenceTokens,\n    strictArrays,\n    strictObjects,\n    realm,\n    value\n  }) : null;\n  try {\n    let output;\n    if (!parseResult.success) {\n      let message = `Invalid JSON Pointer: \"${jsonPointer}\". Syntax error at position ${parseResult.maxMatched}`;\n      message += parseTrace ? `, expected ${parseTrace.inferExpectations()}` : '';\n      throw new JSONPointerEvaluateError(message, {\n        jsonPointer,\n        currentValue: value,\n        realm: realm.name\n      });\n    }\n    return referenceTokens.reduce((current, referenceToken, referenceTokenPosition) => {\n      if (realm.isArray(current)) {\n        if (testArrayDash(referenceToken)) {\n          if (strictArrays) {\n            throw new JSONPointerIndexError(`Invalid array index \"-\" at position ${referenceTokenPosition} in \"${jsonPointer}\". The \"-\" token always refers to a nonexistent element during evaluation`, {\n              jsonPointer,\n              referenceTokens,\n              referenceToken,\n              referenceTokenPosition,\n              currentValue: current,\n              realm: realm.name\n            });\n          } else {\n            output = realm.evaluate(current, String(realm.sizeOf(current)));\n            tracer === null || tracer === void 0 || tracer.step({\n              referenceToken,\n              input: current,\n              output\n            });\n            return output;\n          }\n        }\n        if (!testArrayIndex(referenceToken)) {\n          throw new JSONPointerIndexError(`Invalid array index \"${referenceToken}\" at position ${referenceTokenPosition} in \"${jsonPointer}\": index MUST be \"0\", or digits without a leading \"0\"`, {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        const index = Number(referenceToken);\n        if (!Number.isSafeInteger(index)) {\n          throw new JSONPointerIndexError(`Invalid array index \"${referenceToken}\" at position ${referenceTokenPosition} in \"${jsonPointer}\": index must be a safe integer`, {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        if (!realm.has(current, referenceToken) && strictArrays) {\n          throw new JSONPointerIndexError(`Invalid array index \"${referenceToken}\" at position ${referenceTokenPosition} in \"${jsonPointer}\": index not found in array`, {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        output = realm.evaluate(current, referenceToken);\n        tracer === null || tracer === void 0 || tracer.step({\n          referenceToken,\n          input: current,\n          output\n        });\n        return output;\n      }\n      if (realm.isObject(current)) {\n        if (!realm.has(current, referenceToken) && strictObjects) {\n          throw new JSONPointerKeyError(`Invalid object key \"${referenceToken}\" at position ${referenceTokenPosition} in \"${jsonPointer}\": key not found in object`, {\n            jsonPointer,\n            referenceTokens,\n            referenceToken,\n            referenceTokenPosition,\n            currentValue: current,\n            realm: realm.name\n          });\n        }\n        output = realm.evaluate(current, referenceToken);\n        tracer === null || tracer === void 0 || tracer.step({\n          referenceToken,\n          input: current,\n          output\n        });\n        return output;\n      }\n      throw new JSONPointerTypeError(`Invalid reference token \"${referenceToken}\" at position ${referenceTokenPosition} in \"${jsonPointer}\": cannot be applied to a non-object/non-array value`, {\n        jsonPointer,\n        referenceTokens,\n        referenceToken,\n        referenceTokenPosition,\n        currentValue: current,\n        realm: realm.name\n      });\n    }, value);\n  } catch (error) {\n    tracer === null || tracer === void 0 || tracer.step({\n      referenceToken: error.referenceToken,\n      input: error.currentValue,\n      success: false,\n      reason: error.message\n    });\n    if (error instanceof JSONPointerEvaluateError) {\n      throw error;\n    }\n    throw new JSONPointerEvaluateError('Unexpected error during JSON Pointer evaluation', {\n      cause: error,\n      jsonPointer,\n      referenceTokens\n    });\n  }\n};\nexport default evaluate;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}