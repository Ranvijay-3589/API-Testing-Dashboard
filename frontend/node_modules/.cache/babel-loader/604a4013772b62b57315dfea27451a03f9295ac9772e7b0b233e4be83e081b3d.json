{"ast":null,"code":"import _objectWithoutProperties from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"allowMetaPatches\", \"useCircularStructures\", \"basePath\"];\n/* eslint-disable camelcase */\nimport { RefElement, isObjectElement, isPrimitiveElement, isStringElement, isMemberElement, IdentityManager, visit, includesClasses, toValue, cloneShallow, cloneDeep } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { isReferenceLikeElement, isReferenceElement, isBooleanJsonSchemaElement, isPathItemElement, isSchemaElement, ReferenceElement, PathItemElement, SchemaElement, getNodeType, keyMap } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { evaluate as jsonPointerEvaluate, URIFragmentIdentifier } from '@swagger-api/apidom-json-pointer/modern';\nimport { url, MaximumDereferenceDepthError, File } from '@swagger-api/apidom-reference/configuration/empty';\nimport { OpenAPI3_1DereferenceVisitor, resolveSchema$refField, maybeRefractToSchemaElement } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/$anchor';\nimport { evaluate as uriEvaluate, EvaluationJsonSchemaUriError } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/uri';\nimport toPath from '../utils/to-path.js';\nimport getRootCause from '../utils/get-root-cause.js';\nimport specMapMod from '../../../../../../specmap/lib/refs.js';\nimport SchemaRefError from '../errors/SchemaRefError.js';\nconst {\n  wrapError\n} = specMapMod;\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n// custom mutation replacer\nconst mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\nclass OpenAPI3_1SwaggerClientDereferenceVisitor extends OpenAPI3_1DereferenceVisitor {\n  constructor(_ref) {\n    let {\n        allowMetaPatches = true,\n        useCircularStructures = false,\n        basePath = null\n      } = _ref,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    super(rest);\n    _defineProperty(this, \"useCircularStructures\", void 0);\n    _defineProperty(this, \"allowMetaPatches\", void 0);\n    _defineProperty(this, \"basePath\", void 0);\n    this.allowMetaPatches = allowMetaPatches;\n    this.useCircularStructures = useCircularStructures;\n    this.basePath = basePath;\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Reference Objects\n      if (!this.options.resolve.internal && isInternalReference) {\n        return false;\n      }\n      // ignore resolving external Reference Objects\n      if (!this.options.resolve.external && isExternalReference) {\n        return false;\n      }\n      const reference = await this.toReference(toValue(referencingElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n      this.indirections.push(referencingElement);\n      const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n\n      // possibly non-semantic fragment\n      let referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a fragment\n      if (isPrimitiveElement(referencedElement)) {\n        const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n        const cacheKey = \"\".concat(referencedElementType, \"-\").concat(toValue(identityManager.identify(referencedElement)));\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else if (isReferenceLikeElement(referencedElement)) {\n          // handling indirect references\n          referencedElement = ReferenceElement.refract(referencedElement);\n          referencedElement.setMetaProperty('referenced-element', referencedElementType);\n          this.refractCache.set(cacheKey, referencedElement);\n        } else {\n          // handling direct references\n          const ElementClass = this.namespace.getElementClass(referencedElementType);\n          referencedElement = ElementClass.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Reference Object detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(\"Maximum dereference depth of \\\"\".concat(this.options.dereference.maxDepth, \"\\\" has been exceeded in file \\\"\").concat(this.reference.uri, \"\\\"\"));\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer, _this$options$derefer2;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'reference',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement\n          });\n          const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath;\n        // append referencing reference to ancestors lineage\n        directAncestors.add(referencingElement);\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          refractCache: this.refractCache,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath = this.basePath) !== null && _this$basePath !== void 0 ? _this$basePath : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing reference from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      const mergedElement = cloneShallow(referencedElement);\n\n      // annotate fragment with info about original Reference element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        description: toValue(referencingElement.description),\n        summary: toValue(referencingElement.summary)\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n      // override description and summary (outer has higher priority then inner)\n      if (isObjectElement(referencedElement)) {\n        if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n          mergedElement.remove('description');\n          mergedElement.set('description', referencingElement.get('description'));\n        }\n        if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n          mergedElement.remove('summary');\n          mergedElement.set('summary', referencingElement.get('summary'));\n        }\n      }\n\n      // apply meta patches\n      if (this.allowMetaPatches && isObjectElement(mergedElement)) {\n        // apply meta patch only when not already applied\n        if (!mergedElement.hasKey('$$ref')) {\n          const baseURI = url.resolve(retrievalURI, $refBaseURI);\n          mergedElement.set('$$ref', baseURI);\n        }\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(mergedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? mergedElement : false;\n    } catch (error) {\n      var _this$basePath2, _this$options$derefer3, _this$options$derefer4;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        pointer: URIFragmentIdentifier.fromURIReference(toValue(referencingElement.$ref)),\n        fullPath: (_this$basePath2 = this.basePath) !== null && _this$basePath2 !== void 0 ? _this$basePath2 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n      });\n      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, wrappedError);\n      return undefined;\n    }\n  }\n  async PathItemElement(pathItemElement, key, parent, path, ancestors, link) {\n    try {\n      // ignore PathItemElement without $ref field\n      if (!isStringElement(pathItemElement.$ref)) {\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(pathItemElement)) {\n        return false;\n      }\n\n      // skip already identified cycled Path Item Objects\n      if (includesClasses(['cycle'], pathItemElement.$ref)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(pathItemElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Path Item Elements\n      if (!this.options.resolve.internal && isInternalReference) {\n        return undefined;\n      }\n      // ignore resolving external Path Item Elements\n      if (!this.options.resolve.external && isExternalReference) {\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(pathItemElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(pathItemElement.$ref));\n      this.indirections.push(pathItemElement);\n      const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n\n      // possibly non-semantic referenced element\n      let referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(referencedElement)) {\n        const cacheKey = \"path-item-\".concat(toValue(identityManager.identify(referencedElement)));\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else {\n          referencedElement = PathItemElement.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (pathItemElement === referencedElement) {\n        throw new ApiDOMError('Recursive Path Item Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(\"Maximum dereference depth of \\\"\".concat(this.options.dereference.maxDepth, \"\\\" has been exceeded in file \\\"\").concat(this.reference.uri, \"\\\"\"));\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer5, _this$options$derefer6;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'path-item',\n            uri: reference.uri,\n            $ref: toValue(pathItemElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement: pathItemElement\n          });\n          const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath3;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(pathItemElement);\n\n        // dive deep into the referenced element\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath3 = this.basePath) !== null && _this$basePath3 !== void 0 ? _this$basePath3 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(pathItemElement);\n      }\n      this.indirections.pop();\n\n      /**\n       * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n       */\n      if (isPathItemElement(referencedElement)) {\n        const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing PathItemElement overrides ones from referenced element\n        pathItemElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(pathItemElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(pathItemElement)));\n\n        // apply meta patches\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath4, _this$options$derefer7, _this$options$derefer8;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(pathItemElement.$ref),\n        pointer: URIFragmentIdentifier.fromURIReference(toValue(pathItemElement.$ref)),\n        fullPath: (_this$basePath4 = this.basePath) !== null && _this$basePath4 !== void 0 ? _this$basePath4 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n      });\n      (_this$options$derefer7 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer7 === void 0 || (_this$options$derefer7 = _this$options$derefer7.errors) === null || _this$options$derefer7 === void 0 || (_this$options$derefer8 = _this$options$derefer7.push) === null || _this$options$derefer8 === void 0 || _this$options$derefer8.call(_this$options$derefer7, wrappedError);\n      return undefined;\n    }\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing schema as $ref keyword was not defined\n      if (!isStringElement(referencingElement.$ref)) {\n        // skip traversing this schema but traverse all it's child schemas\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n      // compute baseURI using rules around $id and $ref keywords\n      let reference = await this.toReference(url.unsanitize(this.reference.uri));\n      let {\n        uri: retrievalURI\n      } = reference;\n      const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n      const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n      const file = new File({\n        uri: $refBaseURIStrippedHash\n      });\n      const isUnknownURI = !this.options.resolve.resolvers.some(r => r.canRead(file));\n      const isURL = !isUnknownURI;\n      let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n      let isExternalReference = !isInternalReference;\n      this.indirections.push(referencingElement);\n\n      // determining reference, proper evaluation and selection mechanism\n      let referencedElement;\n      try {\n        if (isUnknownURI || isURL) {\n          // we're dealing with canonical URI or URL with possible fragment\n          retrievalURI = this.toBaseURI($refBaseURI);\n          const selector = $refBaseURI;\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = uriEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } catch (error) {\n        /**\n         * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n         * the URL and assume the returned response is a JSON Schema.\n         */\n        if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n          if (isAnchor(uriToAnchor($refBaseURI))) {\n            // we're dealing with JSON Schema $anchor here\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = uriToAnchor($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          } else {\n            // we're assuming here that we're dealing with JSON Pointer here\n            retrievalURI = this.toBaseURI(toValue($refBaseURI));\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Schema Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(\"Maximum dereference depth of \\\"\".concat(this.options.dereference.maxDepth, \"\\\" has been exceeded in file \\\"\").concat(this.reference.uri, \"\\\"\"));\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer9, _this$options$derefer0;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'json-schema',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: url.resolve(retrievalURI, $refBaseURI),\n            referencingElement\n          });\n          const replacer = (_this$options$derefer9 = (_this$options$derefer0 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer0 === void 0 ? void 0 : _this$options$derefer0.circularReplacer) !== null && _this$options$derefer9 !== void 0 ? _this$options$derefer9 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(replacement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath5;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(referencingElement);\n\n        // dive deep into the fragment\n        const mergeVisitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          useCircularStructures: this.useCircularStructures,\n          allowMetaPatches: this.allowMetaPatches,\n          ancestors: ancestorsLineage,\n          basePath: (_this$basePath5 = this.basePath) !== null && _this$basePath5 !== void 0 ? _this$basePath5 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, mergeVisitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      if (isBooleanJsonSchemaElement(referencedElement)) {\n        const booleanJsonSchemaElement = cloneDeep(referencedElement);\n        // annotate referenced element with info about original referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n        link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n        return !parent ? booleanJsonSchemaElement : false;\n      }\n\n      /**\n       * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n       */\n      if (isSchemaElement(referencedElement)) {\n        // Schema Object - merge keywords from referenced schema with referencing schema\n        const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing schema overrides ones from referenced schema\n        referencingElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate fragment with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n        // allowMetaPatches option processing\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath6, _this$options$derefer1, _this$options$derefer10;\n      const rootCause = getRootCause(error);\n      const wrappedError = new SchemaRefError(\"Could not resolve reference: \".concat(rootCause.message), {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        fullPath: (_this$basePath6 = this.basePath) !== null && _this$basePath6 !== void 0 ? _this$basePath6 : [...toPath([...ancestors, parent, referencingElement]), '$ref'],\n        cause: rootCause\n      });\n      (_this$options$derefer1 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer1 === void 0 || (_this$options$derefer1 = _this$options$derefer1.errors) === null || _this$options$derefer1 === void 0 || (_this$options$derefer10 = _this$options$derefer1.push) === null || _this$options$derefer10 === void 0 || _this$options$derefer10.call(_this$options$derefer1, wrappedError);\n      return undefined;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async LinkElement() {\n    /**\n     * OpenApi3_1DereferenceVisitor is doing lookup of Operation Objects\n     * and assigns them to Link Object metadata. This is not needed in\n     * swagger-client context, so we're disabling it here.\n     */\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    try {\n      return await super.ExampleElement(exampleElement, key, parent, path, ancestors, link);\n    } catch (error) {\n      var _this$basePath7, _this$options$derefer11, _this$options$derefer12;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        externalValue: toValue(exampleElement.externalValue),\n        fullPath: (_this$basePath7 = this.basePath) !== null && _this$basePath7 !== void 0 ? _this$basePath7 : [...toPath([...ancestors, parent, exampleElement]), 'externalValue']\n      });\n      (_this$options$derefer11 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer11 === void 0 || (_this$options$derefer11 = _this$options$derefer11.errors) === null || _this$options$derefer11 === void 0 || (_this$options$derefer12 = _this$options$derefer11.push) === null || _this$options$derefer12 === void 0 || _this$options$derefer12.call(_this$options$derefer11, wrappedError);\n      return undefined;\n    }\n  }\n}\nexport default OpenAPI3_1SwaggerClientDereferenceVisitor;\n/* eslint-enable camelcase */","map":{"version":3,"names":["RefElement","isObjectElement","isPrimitiveElement","isStringElement","isMemberElement","IdentityManager","visit","includesClasses","toValue","cloneShallow","cloneDeep","ApiDOMError","isReferenceLikeElement","isReferenceElement","isBooleanJsonSchemaElement","isPathItemElement","isSchemaElement","ReferenceElement","PathItemElement","SchemaElement","getNodeType","keyMap","evaluate","jsonPointerEvaluate","URIFragmentIdentifier","url","MaximumDereferenceDepthError","File","OpenAPI3_1DereferenceVisitor","resolveSchema$refField","maybeRefractToSchemaElement","isAnchor","uriToAnchor","$anchorEvaluate","uriEvaluate","EvaluationJsonSchemaUriError","toPath","getRootCause","specMapMod","SchemaRefError","wrapError","visitAsync","Symbol","for","identityManager","mutationReplacer","newElement","oldElement","key","parent","value","Array","isArray","OpenAPI3_1SwaggerClientDereferenceVisitor","constructor","_ref","allowMetaPatches","useCircularStructures","basePath","rest","_objectWithoutProperties","_excluded","_defineProperty","referencingElement","path","ancestors","link","indirections","includes","ancestorsLineage","directAncestors","toAncestorLineage","retrievalURI","toBaseURI","$ref","isInternalReference","stripHash","reference","uri","isExternalReference","options","resolve","internal","external","toReference","$refBaseURI","push","jsonPointer","fromURIReference","referencedElement","result","id","identify","referencedElementType","meta","get","cacheKey","concat","refractCache","has","refract","setMetaProperty","set","ElementClass","namespace","getElementClass","length","dereference","maxDepth","refSet","circular","_this$options$derefer","_this$options$derefer2","refElement","type","baseURI","replacer","strategyOpts","circularReplacer","replacement","replaceWith","isNonRootDocument","rootRef","shouldDetectCircular","includesCycle","_this$basePath","add","visitor","nodeTypeGetter","delete","pop","mergedElement","description","summary","hasKey","remove","error","_this$basePath2","_this$options$derefer3","_this$options$derefer4","rootCause","wrappedError","baseDoc","pointer","fullPath","dereferenceOpts","errors","call","undefined","pathItemElement","_this$options$derefer5","_this$options$derefer6","_this$basePath3","content","attributes","forEach","keyElement","item","_this$basePath4","_this$options$derefer7","_this$options$derefer8","unsanitize","$refBaseURIStrippedHash","file","isUnknownURI","resolvers","some","r","canRead","isURL","selector","referenceAsSchema","_this$options$derefer9","_this$options$derefer0","_this$basePath5","mergeVisitor","booleanJsonSchemaElement","_this$basePath6","_this$options$derefer1","_this$options$derefer10","message","cause","LinkElement","ExampleElement","exampleElement","_this$basePath7","_this$options$derefer11","_this$options$derefer12","externalValue"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/dereference.js"],"sourcesContent":["/* eslint-disable camelcase */\nimport { RefElement, isObjectElement, isPrimitiveElement, isStringElement, isMemberElement, IdentityManager, visit, includesClasses, toValue, cloneShallow, cloneDeep } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { isReferenceLikeElement, isReferenceElement, isBooleanJsonSchemaElement, isPathItemElement, isSchemaElement, ReferenceElement, PathItemElement, SchemaElement, getNodeType, keyMap } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { evaluate as jsonPointerEvaluate, URIFragmentIdentifier } from '@swagger-api/apidom-json-pointer/modern';\nimport { url, MaximumDereferenceDepthError, File } from '@swagger-api/apidom-reference/configuration/empty';\nimport { OpenAPI3_1DereferenceVisitor, resolveSchema$refField, maybeRefractToSchemaElement } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/$anchor';\nimport { evaluate as uriEvaluate, EvaluationJsonSchemaUriError } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/uri';\nimport toPath from '../utils/to-path.js';\nimport getRootCause from '../utils/get-root-cause.js';\nimport specMapMod from '../../../../../../specmap/lib/refs.js';\nimport SchemaRefError from '../errors/SchemaRefError.js';\nconst {\n  wrapError\n} = specMapMod;\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n// custom mutation replacer\nconst mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\nclass OpenAPI3_1SwaggerClientDereferenceVisitor extends OpenAPI3_1DereferenceVisitor {\n  useCircularStructures;\n  allowMetaPatches;\n  basePath;\n  constructor({\n    allowMetaPatches = true,\n    useCircularStructures = false,\n    basePath = null,\n    ...rest\n  }) {\n    super(rest);\n    this.allowMetaPatches = allowMetaPatches;\n    this.useCircularStructures = useCircularStructures;\n    this.basePath = basePath;\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Reference Objects\n      if (!this.options.resolve.internal && isInternalReference) {\n        return false;\n      }\n      // ignore resolving external Reference Objects\n      if (!this.options.resolve.external && isExternalReference) {\n        return false;\n      }\n      const reference = await this.toReference(toValue(referencingElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n      this.indirections.push(referencingElement);\n      const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n\n      // possibly non-semantic fragment\n      let referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a fragment\n      if (isPrimitiveElement(referencedElement)) {\n        const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n        const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else if (isReferenceLikeElement(referencedElement)) {\n          // handling indirect references\n          referencedElement = ReferenceElement.refract(referencedElement);\n          referencedElement.setMetaProperty('referenced-element', referencedElementType);\n          this.refractCache.set(cacheKey, referencedElement);\n        } else {\n          // handling direct references\n          const ElementClass = this.namespace.getElementClass(referencedElementType);\n          referencedElement = ElementClass.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Reference Object detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer, _this$options$derefer2;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'reference',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement\n          });\n          const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath;\n        // append referencing reference to ancestors lineage\n        directAncestors.add(referencingElement);\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          refractCache: this.refractCache,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath = this.basePath) !== null && _this$basePath !== void 0 ? _this$basePath : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing reference from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      const mergedElement = cloneShallow(referencedElement);\n\n      // annotate fragment with info about original Reference element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        description: toValue(referencingElement.description),\n        summary: toValue(referencingElement.summary)\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n      // override description and summary (outer has higher priority then inner)\n      if (isObjectElement(referencedElement)) {\n        if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n          mergedElement.remove('description');\n          mergedElement.set('description', referencingElement.get('description'));\n        }\n        if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n          mergedElement.remove('summary');\n          mergedElement.set('summary', referencingElement.get('summary'));\n        }\n      }\n\n      // apply meta patches\n      if (this.allowMetaPatches && isObjectElement(mergedElement)) {\n        // apply meta patch only when not already applied\n        if (!mergedElement.hasKey('$$ref')) {\n          const baseURI = url.resolve(retrievalURI, $refBaseURI);\n          mergedElement.set('$$ref', baseURI);\n        }\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(mergedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? mergedElement : false;\n    } catch (error) {\n      var _this$basePath2, _this$options$derefer3, _this$options$derefer4;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        pointer: URIFragmentIdentifier.fromURIReference(toValue(referencingElement.$ref)),\n        fullPath: (_this$basePath2 = this.basePath) !== null && _this$basePath2 !== void 0 ? _this$basePath2 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n      });\n      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, wrappedError);\n      return undefined;\n    }\n  }\n  async PathItemElement(pathItemElement, key, parent, path, ancestors, link) {\n    try {\n      // ignore PathItemElement without $ref field\n      if (!isStringElement(pathItemElement.$ref)) {\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(pathItemElement)) {\n        return false;\n      }\n\n      // skip already identified cycled Path Item Objects\n      if (includesClasses(['cycle'], pathItemElement.$ref)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(pathItemElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Path Item Elements\n      if (!this.options.resolve.internal && isInternalReference) {\n        return undefined;\n      }\n      // ignore resolving external Path Item Elements\n      if (!this.options.resolve.external && isExternalReference) {\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(pathItemElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(pathItemElement.$ref));\n      this.indirections.push(pathItemElement);\n      const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n\n      // possibly non-semantic referenced element\n      let referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(referencedElement)) {\n        const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else {\n          referencedElement = PathItemElement.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (pathItemElement === referencedElement) {\n        throw new ApiDOMError('Recursive Path Item Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer5, _this$options$derefer6;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'path-item',\n            uri: reference.uri,\n            $ref: toValue(pathItemElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement: pathItemElement\n          });\n          const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath3;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(pathItemElement);\n\n        // dive deep into the referenced element\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath3 = this.basePath) !== null && _this$basePath3 !== void 0 ? _this$basePath3 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(pathItemElement);\n      }\n      this.indirections.pop();\n\n      /**\n       * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n       */\n      if (isPathItemElement(referencedElement)) {\n        const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing PathItemElement overrides ones from referenced element\n        pathItemElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(pathItemElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(pathItemElement)));\n\n        // apply meta patches\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath4, _this$options$derefer7, _this$options$derefer8;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(pathItemElement.$ref),\n        pointer: URIFragmentIdentifier.fromURIReference(toValue(pathItemElement.$ref)),\n        fullPath: (_this$basePath4 = this.basePath) !== null && _this$basePath4 !== void 0 ? _this$basePath4 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n      });\n      (_this$options$derefer7 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer7 === void 0 || (_this$options$derefer7 = _this$options$derefer7.errors) === null || _this$options$derefer7 === void 0 || (_this$options$derefer8 = _this$options$derefer7.push) === null || _this$options$derefer8 === void 0 || _this$options$derefer8.call(_this$options$derefer7, wrappedError);\n      return undefined;\n    }\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing schema as $ref keyword was not defined\n      if (!isStringElement(referencingElement.$ref)) {\n        // skip traversing this schema but traverse all it's child schemas\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n      // compute baseURI using rules around $id and $ref keywords\n      let reference = await this.toReference(url.unsanitize(this.reference.uri));\n      let {\n        uri: retrievalURI\n      } = reference;\n      const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n      const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n      const file = new File({\n        uri: $refBaseURIStrippedHash\n      });\n      const isUnknownURI = !this.options.resolve.resolvers.some(r => r.canRead(file));\n      const isURL = !isUnknownURI;\n      let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n      let isExternalReference = !isInternalReference;\n      this.indirections.push(referencingElement);\n\n      // determining reference, proper evaluation and selection mechanism\n      let referencedElement;\n      try {\n        if (isUnknownURI || isURL) {\n          // we're dealing with canonical URI or URL with possible fragment\n          retrievalURI = this.toBaseURI($refBaseURI);\n          const selector = $refBaseURI;\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = uriEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } catch (error) {\n        /**\n         * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n         * the URL and assume the returned response is a JSON Schema.\n         */\n        if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n          if (isAnchor(uriToAnchor($refBaseURI))) {\n            // we're dealing with JSON Schema $anchor here\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = uriToAnchor($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          } else {\n            // we're assuming here that we're dealing with JSON Pointer here\n            retrievalURI = this.toBaseURI(toValue($refBaseURI));\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Schema Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer9, _this$options$derefer0;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'json-schema',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: url.resolve(retrievalURI, $refBaseURI),\n            referencingElement\n          });\n          const replacer = (_this$options$derefer9 = (_this$options$derefer0 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer0 === void 0 ? void 0 : _this$options$derefer0.circularReplacer) !== null && _this$options$derefer9 !== void 0 ? _this$options$derefer9 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(replacement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath5;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(referencingElement);\n\n        // dive deep into the fragment\n        const mergeVisitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          useCircularStructures: this.useCircularStructures,\n          allowMetaPatches: this.allowMetaPatches,\n          ancestors: ancestorsLineage,\n          basePath: (_this$basePath5 = this.basePath) !== null && _this$basePath5 !== void 0 ? _this$basePath5 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, mergeVisitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      if (isBooleanJsonSchemaElement(referencedElement)) {\n        const booleanJsonSchemaElement = cloneDeep(referencedElement);\n        // annotate referenced element with info about original referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n        link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n        return !parent ? booleanJsonSchemaElement : false;\n      }\n\n      /**\n       * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n       */\n      if (isSchemaElement(referencedElement)) {\n        // Schema Object - merge keywords from referenced schema with referencing schema\n        const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing schema overrides ones from referenced schema\n        referencingElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate fragment with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n        // allowMetaPatches option processing\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath6, _this$options$derefer1, _this$options$derefer10;\n      const rootCause = getRootCause(error);\n      const wrappedError = new SchemaRefError(`Could not resolve reference: ${rootCause.message}`, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        fullPath: (_this$basePath6 = this.basePath) !== null && _this$basePath6 !== void 0 ? _this$basePath6 : [...toPath([...ancestors, parent, referencingElement]), '$ref'],\n        cause: rootCause\n      });\n      (_this$options$derefer1 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer1 === void 0 || (_this$options$derefer1 = _this$options$derefer1.errors) === null || _this$options$derefer1 === void 0 || (_this$options$derefer10 = _this$options$derefer1.push) === null || _this$options$derefer10 === void 0 || _this$options$derefer10.call(_this$options$derefer1, wrappedError);\n      return undefined;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async LinkElement() {\n    /**\n     * OpenApi3_1DereferenceVisitor is doing lookup of Operation Objects\n     * and assigns them to Link Object metadata. This is not needed in\n     * swagger-client context, so we're disabling it here.\n     */\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    try {\n      return await super.ExampleElement(exampleElement, key, parent, path, ancestors, link);\n    } catch (error) {\n      var _this$basePath7, _this$options$derefer11, _this$options$derefer12;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        externalValue: toValue(exampleElement.externalValue),\n        fullPath: (_this$basePath7 = this.basePath) !== null && _this$basePath7 !== void 0 ? _this$basePath7 : [...toPath([...ancestors, parent, exampleElement]), 'externalValue']\n      });\n      (_this$options$derefer11 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer11 === void 0 || (_this$options$derefer11 = _this$options$derefer11.errors) === null || _this$options$derefer11 === void 0 || (_this$options$derefer12 = _this$options$derefer11.push) === null || _this$options$derefer12 === void 0 || _this$options$derefer12.call(_this$options$derefer11, wrappedError);\n      return undefined;\n    }\n  }\n}\nexport default OpenAPI3_1SwaggerClientDereferenceVisitor;\n/* eslint-enable camelcase */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}