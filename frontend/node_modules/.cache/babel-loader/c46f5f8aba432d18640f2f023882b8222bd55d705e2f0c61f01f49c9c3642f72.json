{"ast":null,"code":"import { isPlainObject } from 'ramda-adjunct';\nimport opId from '../../../helpers/op-id.js';\nexport default function normalize(parsedSpec) {\n  const {\n    spec\n  } = parsedSpec;\n  const {\n    paths\n  } = spec;\n  const map = {};\n  if (!paths || spec.$$normalized) {\n    return parsedSpec;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const pathName in paths) {\n    const path = paths[pathName];\n    if (path == null || !['object', 'function'].includes(typeof path)) {\n      continue; // eslint-disable-line no-continue\n    }\n    const pathParameters = path.parameters;\n\n    // eslint-disable-next-line no-restricted-syntax, guard-for-in\n    for (const method in path) {\n      const operation = path[method];\n      if (operation == null || !['object', 'function'].includes(typeof operation)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const oid = opId(operation, pathName, method);\n      if (oid) {\n        if (map[oid]) {\n          map[oid].push(operation);\n        } else {\n          map[oid] = [operation];\n        }\n        const opList = map[oid];\n        if (opList.length > 1) {\n          opList.forEach((o, i) => {\n            // eslint-disable-next-line no-underscore-dangle\n            o.__originalOperationId = o.__originalOperationId || o.operationId;\n            o.operationId = \"\".concat(oid).concat(i + 1);\n          });\n        } else if (typeof operation.operationId !== 'undefined') {\n          // Ensure we always add the normalized operation ID if one already exists\n          // ( potentially different, given that we normalize our IDs)\n          // ... _back_ to the spec. Otherwise, they might not line up\n          const obj = opList[0];\n          // eslint-disable-next-line no-underscore-dangle\n          obj.__originalOperationId = obj.__originalOperationId || operation.operationId;\n          obj.operationId = oid;\n        }\n      }\n      if (method !== 'parameters') {\n        // Add inherited consumes, produces, parameters, securities\n        const inheritsList = [];\n        const toBeInherit = {};\n\n        // Global-levels\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key in spec) {\n          if (key === 'produces' || key === 'consumes' || key === 'security') {\n            toBeInherit[key] = spec[key];\n            inheritsList.push(toBeInherit);\n          }\n        }\n\n        // Path-levels\n        if (pathParameters) {\n          toBeInherit.parameters = pathParameters;\n          inheritsList.push(toBeInherit);\n        }\n        if (inheritsList.length) {\n          // eslint-disable-next-line no-restricted-syntax\n          for (const inherits of inheritsList) {\n            // eslint-disable-next-line no-restricted-syntax\n            for (const inheritName in inherits) {\n              if (!Array.isArray(operation[inheritName])) {\n                operation[inheritName] = inherits[inheritName];\n              } else if (inheritName === 'parameters') {\n                // eslint-disable-next-line no-restricted-syntax\n                for (const param of inherits[inheritName]) {\n                  const exists = operation[inheritName].some(opParam => {\n                    if (!isPlainObject(opParam) && !isPlainObject(param)) return false;\n                    if (opParam === param) return true;\n                    return ['name', '$ref', '$$ref'].some(key => typeof opParam[key] === 'string' && typeof param[key] === 'string' && opParam[key] === param[key]);\n                  });\n                  if (!exists) {\n                    operation[inheritName].push(param);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  spec.$$normalized = true;\n  return parsedSpec;\n}","map":{"version":3,"names":["isPlainObject","opId","normalize","parsedSpec","spec","paths","map","$$normalized","pathName","path","includes","pathParameters","parameters","method","operation","oid","push","opList","length","forEach","o","i","__originalOperationId","operationId","concat","obj","inheritsList","toBeInherit","key","inherits","inheritName","Array","isArray","param","exists","some","opParam"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/swagger-client/es/resolver/strategies/generic/normalize.js"],"sourcesContent":["import { isPlainObject } from 'ramda-adjunct';\nimport opId from '../../../helpers/op-id.js';\nexport default function normalize(parsedSpec) {\n  const {\n    spec\n  } = parsedSpec;\n  const {\n    paths\n  } = spec;\n  const map = {};\n  if (!paths || spec.$$normalized) {\n    return parsedSpec;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const pathName in paths) {\n    const path = paths[pathName];\n    if (path == null || !['object', 'function'].includes(typeof path)) {\n      continue; // eslint-disable-line no-continue\n    }\n    const pathParameters = path.parameters;\n\n    // eslint-disable-next-line no-restricted-syntax, guard-for-in\n    for (const method in path) {\n      const operation = path[method];\n      if (operation == null || !['object', 'function'].includes(typeof operation)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const oid = opId(operation, pathName, method);\n      if (oid) {\n        if (map[oid]) {\n          map[oid].push(operation);\n        } else {\n          map[oid] = [operation];\n        }\n        const opList = map[oid];\n        if (opList.length > 1) {\n          opList.forEach((o, i) => {\n            // eslint-disable-next-line no-underscore-dangle\n            o.__originalOperationId = o.__originalOperationId || o.operationId;\n            o.operationId = `${oid}${i + 1}`;\n          });\n        } else if (typeof operation.operationId !== 'undefined') {\n          // Ensure we always add the normalized operation ID if one already exists\n          // ( potentially different, given that we normalize our IDs)\n          // ... _back_ to the spec. Otherwise, they might not line up\n          const obj = opList[0];\n          // eslint-disable-next-line no-underscore-dangle\n          obj.__originalOperationId = obj.__originalOperationId || operation.operationId;\n          obj.operationId = oid;\n        }\n      }\n      if (method !== 'parameters') {\n        // Add inherited consumes, produces, parameters, securities\n        const inheritsList = [];\n        const toBeInherit = {};\n\n        // Global-levels\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key in spec) {\n          if (key === 'produces' || key === 'consumes' || key === 'security') {\n            toBeInherit[key] = spec[key];\n            inheritsList.push(toBeInherit);\n          }\n        }\n\n        // Path-levels\n        if (pathParameters) {\n          toBeInherit.parameters = pathParameters;\n          inheritsList.push(toBeInherit);\n        }\n        if (inheritsList.length) {\n          // eslint-disable-next-line no-restricted-syntax\n          for (const inherits of inheritsList) {\n            // eslint-disable-next-line no-restricted-syntax\n            for (const inheritName in inherits) {\n              if (!Array.isArray(operation[inheritName])) {\n                operation[inheritName] = inherits[inheritName];\n              } else if (inheritName === 'parameters') {\n                // eslint-disable-next-line no-restricted-syntax\n                for (const param of inherits[inheritName]) {\n                  const exists = operation[inheritName].some(opParam => {\n                    if (!isPlainObject(opParam) && !isPlainObject(param)) return false;\n                    if (opParam === param) return true;\n                    return ['name', '$ref', '$$ref'].some(key => typeof opParam[key] === 'string' && typeof param[key] === 'string' && opParam[key] === param[key]);\n                  });\n                  if (!exists) {\n                    operation[inheritName].push(param);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  spec.$$normalized = true;\n  return parsedSpec;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}