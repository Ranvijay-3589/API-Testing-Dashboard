{"ast":null,"code":"import _defineProperty from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport YamlTagError from \"../../errors/YamlTagError.mjs\";\nimport { YamlNodeKind } from \"../../nodes/YamlTag.mjs\";\nimport GenericMappingTag from \"./GenericMapping.mjs\";\nimport GenericSequenceTag from \"./GenericSequence.mjs\";\nimport GenericStringTag from \"./GenericString.mjs\";\nimport ScalarTag from \"../ScalarTag.mjs\";\n/**\n * @public\n */\nclass FailsafeSchema {\n  constructor() {\n    _defineProperty(this, \"tags\", void 0);\n    _defineProperty(this, \"tagDirectives\", void 0);\n    this.tags = [];\n    this.tagDirectives = [];\n    this.registerTag(new GenericMappingTag());\n    this.registerTag(new GenericSequenceTag());\n    this.registerTag(new GenericStringTag());\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  toSpecificTagName(node) {\n    let specificTagName = node.tag.explicitName;\n    if (node.tag.explicitName === '!') {\n      // non-specific tag; we assume tag by kind\n      if (node.tag.kind === YamlNodeKind.Scalar) {\n        specificTagName = GenericStringTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Sequence) {\n        specificTagName = GenericSequenceTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Mapping) {\n        specificTagName = GenericMappingTag.uri;\n      }\n    } else if (node.tag.explicitName.startsWith('!<')) {\n      // verbatim form\n      specificTagName = node.tag.explicitName.replace(/^!</, '').replace(/>$/, '');\n    } else if (node.tag.explicitName.startsWith('!!')) {\n      // shorthand notation\n      specificTagName = \"tag:yaml.org,2002:\".concat(node.tag.explicitName.replace(/^!!/, ''));\n    }\n    return specificTagName;\n  }\n  registerTagDirective(tagDirective) {\n    this.tagDirectives.push({\n      // @ts-ignore\n      handle: tagDirective.parameters.handle,\n      // @ts-ignore\n      prefix: tagDirective.parameters.prefix\n    });\n  }\n  registerTag(tag) {\n    let beginning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (beginning) {\n      this.tags.unshift(tag);\n    } else {\n      this.tags.push(tag);\n    }\n    return this;\n  }\n  overrideTag(tag) {\n    this.tags = this.tags.filter(itag => itag.tag === tag.tag);\n    this.tags.push(tag);\n    return this;\n  }\n  resolve(node) {\n    const specificTagName = this.toSpecificTagName(node);\n\n    // leave this node unresolved\n    if (specificTagName === '?') {\n      return node;\n    }\n\n    // turn scalar nodes into canonical format before resolving\n    let canonicalNode = node;\n    if (ScalarTag.test(node)) {\n      canonicalNode = ScalarTag.canonicalFormat(node);\n    }\n    const tag = this.tags.find(itag => (itag === null || itag === void 0 ? void 0 : itag.tag) === specificTagName);\n\n    // mechanism for resolving node (tag implementation) not found\n    if (typeof tag === 'undefined') {\n      throw new YamlTagError(\"Tag \\\"\".concat(specificTagName, \"\\\" was not recognized.\"), {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagStartPositionRow: node.tag.startPositionRow,\n        tagStartPositionColumn: node.tag.startPositionColumn,\n        tagStartPositionIndex: node.tag.startIndex,\n        tagEndPositionRow: node.tag.endPositionRow,\n        tagEndPositionColumn: node.tag.endPositionColumn,\n        tagEndPositionIndex: node.tag.endIndex,\n        node: node.clone()\n      });\n    }\n\n    // node content is not compatible with resolving mechanism (tag implementation)\n    if (!tag.test(canonicalNode)) {\n      throw new YamlTagError(\"Node couldn't be resolved against the tag \\\"\".concat(specificTagName, \"\\\"\"), {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagStartPositionRow: node.tag.startPositionRow,\n        tagStartPositionColumn: node.tag.startPositionColumn,\n        tagStartPositionIndex: node.tag.startIndex,\n        tagEndPositionRow: node.tag.endPositionRow,\n        tagEndPositionColumn: node.tag.endPositionColumn,\n        tagEndPositionIndex: node.tag.endIndex,\n        nodeCanonicalContent: canonicalNode.content,\n        node: node.clone()\n      });\n    }\n    return tag.resolve(canonicalNode);\n  }\n}\nexport default FailsafeSchema;","map":{"version":3,"names":["YamlTagError","YamlNodeKind","GenericMappingTag","GenericSequenceTag","GenericStringTag","ScalarTag","FailsafeSchema","constructor","_defineProperty","tags","tagDirectives","registerTag","toSpecificTagName","node","specificTagName","tag","explicitName","kind","Scalar","uri","Sequence","Mapping","startsWith","replace","concat","registerTagDirective","tagDirective","push","handle","parameters","prefix","beginning","arguments","length","undefined","unshift","overrideTag","filter","itag","resolve","canonicalNode","test","canonicalFormat","find","explicitTagName","tagKind","tagStartPositionRow","startPositionRow","tagStartPositionColumn","startPositionColumn","tagStartPositionIndex","startIndex","tagEndPositionRow","endPositionRow","tagEndPositionColumn","endPositionColumn","tagEndPositionIndex","endIndex","clone","nodeCanonicalContent","content"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-ast/src/yaml/schemas/failsafe/index.mjs"],"sourcesContent":["import YamlTagError from \"../../errors/YamlTagError.mjs\";\nimport { YamlNodeKind } from \"../../nodes/YamlTag.mjs\";\nimport GenericMappingTag from \"./GenericMapping.mjs\";\nimport GenericSequenceTag from \"./GenericSequence.mjs\";\nimport GenericStringTag from \"./GenericString.mjs\";\nimport ScalarTag from \"../ScalarTag.mjs\";\n/**\n * @public\n */\nclass FailsafeSchema {\n  tags;\n  tagDirectives;\n  constructor() {\n    this.tags = [];\n    this.tagDirectives = [];\n    this.registerTag(new GenericMappingTag());\n    this.registerTag(new GenericSequenceTag());\n    this.registerTag(new GenericStringTag());\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  toSpecificTagName(node) {\n    let specificTagName = node.tag.explicitName;\n    if (node.tag.explicitName === '!') {\n      // non-specific tag; we assume tag by kind\n      if (node.tag.kind === YamlNodeKind.Scalar) {\n        specificTagName = GenericStringTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Sequence) {\n        specificTagName = GenericSequenceTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Mapping) {\n        specificTagName = GenericMappingTag.uri;\n      }\n    } else if (node.tag.explicitName.startsWith('!<')) {\n      // verbatim form\n      specificTagName = node.tag.explicitName.replace(/^!</, '').replace(/>$/, '');\n    } else if (node.tag.explicitName.startsWith('!!')) {\n      // shorthand notation\n      specificTagName = `tag:yaml.org,2002:${node.tag.explicitName.replace(/^!!/, '')}`;\n    }\n    return specificTagName;\n  }\n  registerTagDirective(tagDirective) {\n    this.tagDirectives.push({\n      // @ts-ignore\n      handle: tagDirective.parameters.handle,\n      // @ts-ignore\n      prefix: tagDirective.parameters.prefix\n    });\n  }\n  registerTag(tag, beginning = false) {\n    if (beginning) {\n      this.tags.unshift(tag);\n    } else {\n      this.tags.push(tag);\n    }\n    return this;\n  }\n  overrideTag(tag) {\n    this.tags = this.tags.filter(itag => itag.tag === tag.tag);\n    this.tags.push(tag);\n    return this;\n  }\n  resolve(node) {\n    const specificTagName = this.toSpecificTagName(node);\n\n    // leave this node unresolved\n    if (specificTagName === '?') {\n      return node;\n    }\n\n    // turn scalar nodes into canonical format before resolving\n    let canonicalNode = node;\n    if (ScalarTag.test(node)) {\n      canonicalNode = ScalarTag.canonicalFormat(node);\n    }\n    const tag = this.tags.find(itag => (itag === null || itag === void 0 ? void 0 : itag.tag) === specificTagName);\n\n    // mechanism for resolving node (tag implementation) not found\n    if (typeof tag === 'undefined') {\n      throw new YamlTagError(`Tag \"${specificTagName}\" was not recognized.`, {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagStartPositionRow: node.tag.startPositionRow,\n        tagStartPositionColumn: node.tag.startPositionColumn,\n        tagStartPositionIndex: node.tag.startIndex,\n        tagEndPositionRow: node.tag.endPositionRow,\n        tagEndPositionColumn: node.tag.endPositionColumn,\n        tagEndPositionIndex: node.tag.endIndex,\n        node: node.clone()\n      });\n    }\n\n    // node content is not compatible with resolving mechanism (tag implementation)\n    if (!tag.test(canonicalNode)) {\n      throw new YamlTagError(`Node couldn't be resolved against the tag \"${specificTagName}\"`, {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagStartPositionRow: node.tag.startPositionRow,\n        tagStartPositionColumn: node.tag.startPositionColumn,\n        tagStartPositionIndex: node.tag.startIndex,\n        tagEndPositionRow: node.tag.endPositionRow,\n        tagEndPositionColumn: node.tag.endPositionColumn,\n        tagEndPositionIndex: node.tag.endIndex,\n        nodeCanonicalContent: canonicalNode.content,\n        node: node.clone()\n      });\n    }\n    return tag.resolve(canonicalNode);\n  }\n}\nexport default FailsafeSchema;"],"mappings":";AAAA,OAAOA,YAAY,MAAM,+BAA+B;AACxD,SAASC,YAAY,QAAQ,yBAAyB;AACtD,OAAOC,iBAAiB,MAAM,sBAAsB;AACpD,OAAOC,kBAAkB,MAAM,uBAAuB;AACtD,OAAOC,gBAAgB,MAAM,qBAAqB;AAClD,OAAOC,SAAS,MAAM,kBAAkB;AACxC;AACA;AACA;AACA,MAAMC,cAAc,CAAC;EAGnBC,WAAWA,CAAA,EAAG;IAAAC,eAAA;IAAAA,eAAA;IACZ,IAAI,CAACC,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,WAAW,CAAC,IAAIT,iBAAiB,CAAC,CAAC,CAAC;IACzC,IAAI,CAACS,WAAW,CAAC,IAAIR,kBAAkB,CAAC,CAAC,CAAC;IAC1C,IAAI,CAACQ,WAAW,CAAC,IAAIP,gBAAgB,CAAC,CAAC,CAAC;EAC1C;;EAEA;EACAQ,iBAAiBA,CAACC,IAAI,EAAE;IACtB,IAAIC,eAAe,GAAGD,IAAI,CAACE,GAAG,CAACC,YAAY;IAC3C,IAAIH,IAAI,CAACE,GAAG,CAACC,YAAY,KAAK,GAAG,EAAE;MACjC;MACA,IAAIH,IAAI,CAACE,GAAG,CAACE,IAAI,KAAKhB,YAAY,CAACiB,MAAM,EAAE;QACzCJ,eAAe,GAAGV,gBAAgB,CAACe,GAAG;MACxC,CAAC,MAAM,IAAIN,IAAI,CAACE,GAAG,CAACE,IAAI,KAAKhB,YAAY,CAACmB,QAAQ,EAAE;QAClDN,eAAe,GAAGX,kBAAkB,CAACgB,GAAG;MAC1C,CAAC,MAAM,IAAIN,IAAI,CAACE,GAAG,CAACE,IAAI,KAAKhB,YAAY,CAACoB,OAAO,EAAE;QACjDP,eAAe,GAAGZ,iBAAiB,CAACiB,GAAG;MACzC;IACF,CAAC,MAAM,IAAIN,IAAI,CAACE,GAAG,CAACC,YAAY,CAACM,UAAU,CAAC,IAAI,CAAC,EAAE;MACjD;MACAR,eAAe,GAAGD,IAAI,CAACE,GAAG,CAACC,YAAY,CAACO,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IAC9E,CAAC,MAAM,IAAIV,IAAI,CAACE,GAAG,CAACC,YAAY,CAACM,UAAU,CAAC,IAAI,CAAC,EAAE;MACjD;MACAR,eAAe,wBAAAU,MAAA,CAAwBX,IAAI,CAACE,GAAG,CAACC,YAAY,CAACO,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAE;IACnF;IACA,OAAOT,eAAe;EACxB;EACAW,oBAAoBA,CAACC,YAAY,EAAE;IACjC,IAAI,CAAChB,aAAa,CAACiB,IAAI,CAAC;MACtB;MACAC,MAAM,EAAEF,YAAY,CAACG,UAAU,CAACD,MAAM;MACtC;MACAE,MAAM,EAAEJ,YAAY,CAACG,UAAU,CAACC;IAClC,CAAC,CAAC;EACJ;EACAnB,WAAWA,CAACI,GAAG,EAAqB;IAAA,IAAnBgB,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IAChC,IAAID,SAAS,EAAE;MACb,IAAI,CAACtB,IAAI,CAAC0B,OAAO,CAACpB,GAAG,CAAC;IACxB,CAAC,MAAM;MACL,IAAI,CAACN,IAAI,CAACkB,IAAI,CAACZ,GAAG,CAAC;IACrB;IACA,OAAO,IAAI;EACb;EACAqB,WAAWA,CAACrB,GAAG,EAAE;IACf,IAAI,CAACN,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC4B,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACvB,GAAG,KAAKA,GAAG,CAACA,GAAG,CAAC;IAC1D,IAAI,CAACN,IAAI,CAACkB,IAAI,CAACZ,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACAwB,OAAOA,CAAC1B,IAAI,EAAE;IACZ,MAAMC,eAAe,GAAG,IAAI,CAACF,iBAAiB,CAACC,IAAI,CAAC;;IAEpD;IACA,IAAIC,eAAe,KAAK,GAAG,EAAE;MAC3B,OAAOD,IAAI;IACb;;IAEA;IACA,IAAI2B,aAAa,GAAG3B,IAAI;IACxB,IAAIR,SAAS,CAACoC,IAAI,CAAC5B,IAAI,CAAC,EAAE;MACxB2B,aAAa,GAAGnC,SAAS,CAACqC,eAAe,CAAC7B,IAAI,CAAC;IACjD;IACA,MAAME,GAAG,GAAG,IAAI,CAACN,IAAI,CAACkC,IAAI,CAACL,IAAI,IAAI,CAACA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACvB,GAAG,MAAMD,eAAe,CAAC;;IAE9G;IACA,IAAI,OAAOC,GAAG,KAAK,WAAW,EAAE;MAC9B,MAAM,IAAIf,YAAY,UAAAwB,MAAA,CAASV,eAAe,6BAAyB;QACrEA,eAAe;QACf8B,eAAe,EAAE/B,IAAI,CAACE,GAAG,CAACC,YAAY;QACtC6B,OAAO,EAAEhC,IAAI,CAACE,GAAG,CAACE,IAAI;QACtB6B,mBAAmB,EAAEjC,IAAI,CAACE,GAAG,CAACgC,gBAAgB;QAC9CC,sBAAsB,EAAEnC,IAAI,CAACE,GAAG,CAACkC,mBAAmB;QACpDC,qBAAqB,EAAErC,IAAI,CAACE,GAAG,CAACoC,UAAU;QAC1CC,iBAAiB,EAAEvC,IAAI,CAACE,GAAG,CAACsC,cAAc;QAC1CC,oBAAoB,EAAEzC,IAAI,CAACE,GAAG,CAACwC,iBAAiB;QAChDC,mBAAmB,EAAE3C,IAAI,CAACE,GAAG,CAAC0C,QAAQ;QACtC5C,IAAI,EAAEA,IAAI,CAAC6C,KAAK,CAAC;MACnB,CAAC,CAAC;IACJ;;IAEA;IACA,IAAI,CAAC3C,GAAG,CAAC0B,IAAI,CAACD,aAAa,CAAC,EAAE;MAC5B,MAAM,IAAIxC,YAAY,gDAAAwB,MAAA,CAA+CV,eAAe,SAAK;QACvFA,eAAe;QACf8B,eAAe,EAAE/B,IAAI,CAACE,GAAG,CAACC,YAAY;QACtC6B,OAAO,EAAEhC,IAAI,CAACE,GAAG,CAACE,IAAI;QACtB6B,mBAAmB,EAAEjC,IAAI,CAACE,GAAG,CAACgC,gBAAgB;QAC9CC,sBAAsB,EAAEnC,IAAI,CAACE,GAAG,CAACkC,mBAAmB;QACpDC,qBAAqB,EAAErC,IAAI,CAACE,GAAG,CAACoC,UAAU;QAC1CC,iBAAiB,EAAEvC,IAAI,CAACE,GAAG,CAACsC,cAAc;QAC1CC,oBAAoB,EAAEzC,IAAI,CAACE,GAAG,CAACwC,iBAAiB;QAChDC,mBAAmB,EAAE3C,IAAI,CAACE,GAAG,CAAC0C,QAAQ;QACtCE,oBAAoB,EAAEnB,aAAa,CAACoB,OAAO;QAC3C/C,IAAI,EAAEA,IAAI,CAAC6C,KAAK,CAAC;MACnB,CAAC,CAAC;IACJ;IACA,OAAO3C,GAAG,CAACwB,OAAO,CAACC,aAAa,CAAC;EACnC;AACF;AACA,eAAelC,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}