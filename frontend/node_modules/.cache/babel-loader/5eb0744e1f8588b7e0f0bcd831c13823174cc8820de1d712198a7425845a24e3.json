{"ast":null,"code":"import _objectSpread from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) GraphQL Contributors\n *\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @public\n */\nexport const getVisitFn = (visitor, type, isLeaving) => {\n  // @ts-ignore\n  const typeVisitor = visitor[type];\n  if (typeVisitor != null) {\n    if (!isLeaving && typeof typeVisitor === 'function') {\n      // { Type() {} }\n      return typeVisitor;\n    }\n    const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;\n    if (typeof typeSpecificVisitor === 'function') {\n      // { Type: { enter() {}, leave() {} } }\n      return typeSpecificVisitor;\n    }\n  } else {\n    const specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor != null) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      // @ts-ignore\n      const specificTypeVisitor = specificVisitor[type];\n      if (typeof specificTypeVisitor === 'function') {\n        // { enter: { Type() {} }, leave: { Type() {} } }\n        return specificTypeVisitor;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * @public\n */\nexport const BREAK = {};\n\n/**\n * @public\n */\nexport const getNodeType = node => node === null || node === void 0 ? void 0 : node.type;\n\n/**\n * @public\n */\nexport const isNode = node => typeof getNodeType(node) === 'string';\n\n/**\n * @public\n */\nexport const cloneNode = node => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n * `exposeEdits=true` can be used to expose the edited node from the previous visitors.\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nexport const mergeAll = function (visitors) {\n  let {\n    visitFnGetter = getVisitFn,\n    nodeTypeGetter = getNodeType,\n    breakSymbol = BREAK,\n    deleteNodeSymbol = null,\n    skipVisitingNodeSymbol = false,\n    exposeEdits = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = _objectSpread(_objectSpread({}, link), {}, {\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      });\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = _objectSpread(_objectSpread({}, link), {}, {\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      });\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nconst mergeAllAsync = function (visitors) {\n  let {\n    visitFnGetter = getVisitFn,\n    nodeTypeGetter = getNodeType,\n    breakSymbol = BREAK,\n    deleteNodeSymbol = null,\n    skipVisitingNodeSymbol = false,\n    exposeEdits = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    async enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = _objectSpread(_objectSpread({}, link), {}, {\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      });\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    async leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = _objectSpread(_objectSpread({}, link), {}, {\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      });\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nmergeAll[Symbol.for('nodejs.util.promisify.custom')] = mergeAllAsync;\n\n/* eslint-disable no-continue, no-param-reassign */\n/**\n * visit() will walk through an AST using a preorder depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * @example\n * ```\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // return\n *         //   undefined: no action\n *         //   false: no action\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *```\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n * ```\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n * ```\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n * ```\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n * ```\n * 3) Generic visitors that trigger upon entering and leaving any node.\n * ```\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n * ```\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n * ```\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n * ```\n *  sig `visit :: (Node, Visitor, Options)`\n *\n *  sig `Options = { keyMap: Object, state: Object }`\n *\n *  @public\n */\nexport const visit = function (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor) {\n  let {\n    keyMap = null,\n    state = {},\n    breakSymbol = BREAK,\n    deleteNodeSymbol = null,\n    skipVisitingNodeSymbol = false,\n    visitFnGetter = getVisitFn,\n    nodeTypeGetter = getNodeType,\n    nodePredicate = isNode,\n    nodeCloneFn = cloneNode,\n    detectCycles = true,\n    detectCyclesCallback = null\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _result;\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(\"Invalid AST Node:  \".concat(String(node)), {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        if (typeof detectCyclesCallback === 'function') {\n          // @ts-ignore\n          detectCyclesCallback(node, key, parent, path, ancestors);\n        }\n        path.pop();\n        continue;\n      }\n      // call appropriate visitor function if available\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = visitFn.call(visitor, node, key, parent, path, ancestors, link);\n      }\n\n      // check if the visitor is async\n      if (typeof ((_result = result) === null || _result === void 0 ? void 0 : _result.then) === 'function') {\n        throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n          visitor,\n          visitFn\n        });\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/**\n * Asynchronous version of visit.\n */\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async function (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor) {\n  let {\n    keyMap = null,\n    state = {},\n    breakSymbol = BREAK,\n    deleteNodeSymbol = null,\n    skipVisitingNodeSymbol = false,\n    visitFnGetter = getVisitFn,\n    nodeTypeGetter = getNodeType,\n    nodePredicate = isNode,\n    nodeCloneFn = cloneNode,\n    detectCycles = true,\n    detectCyclesCallback = null\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(\"Invalid AST Node: \".concat(String(node)), {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        if (typeof detectCyclesCallback === 'function') {\n          // @ts-ignore\n          detectCyclesCallback(node, key, parent, path, ancestors);\n        }\n        path.pop();\n        continue;\n      }\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = await visitFn.call(visitor, node, key, parent, path, ancestors, link); // eslint-disable-line no-await-in-loop\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType2;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/* eslint-enable */","map":{"version":3,"names":["ApiDOMStructuredError","getVisitFn","visitor","type","isLeaving","typeVisitor","typeSpecificVisitor","leave","enter","specificVisitor","specificTypeVisitor","BREAK","getNodeType","node","isNode","cloneNode","Object","create","getPrototypeOf","getOwnPropertyDescriptors","mergeAll","visitors","visitFnGetter","nodeTypeGetter","breakSymbol","deleteNodeSymbol","skipVisitingNodeSymbol","exposeEdits","arguments","length","undefined","skipSymbol","Symbol","skipping","Array","fill","key","parent","path","ancestors","link","currentNode","hasChanged","linkProxy","_objectSpread","replaceWith","newNode","replacer","i","visitFn","result","call","then","mergeAllAsync","for","visit","root","keyMap","state","nodePredicate","nodeCloneFn","detectCycles","detectCyclesCallback","visitorKeys","stack","inArray","isArray","keys","index","edits","isEdited","pop","slice","editOffset","editKey","editValue","arrayKey","splice","prev","push","_result","concat","String","includes","stateKey","stateValue","entries","_visitorKeys$nodeType","_visitorKeys$nodeType2"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-ast/src/traversal/visitor.mjs"],"sourcesContent":["import { ApiDOMStructuredError } from '@swagger-api/apidom-error';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) GraphQL Contributors\n *\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @public\n */\nexport const getVisitFn = (visitor, type, isLeaving) => {\n  // @ts-ignore\n  const typeVisitor = visitor[type];\n  if (typeVisitor != null) {\n    if (!isLeaving && typeof typeVisitor === 'function') {\n      // { Type() {} }\n      return typeVisitor;\n    }\n    const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;\n    if (typeof typeSpecificVisitor === 'function') {\n      // { Type: { enter() {}, leave() {} } }\n      return typeSpecificVisitor;\n    }\n  } else {\n    const specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor != null) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      // @ts-ignore\n      const specificTypeVisitor = specificVisitor[type];\n      if (typeof specificTypeVisitor === 'function') {\n        // { enter: { Type() {} }, leave: { Type() {} } }\n        return specificTypeVisitor;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * @public\n */\nexport const BREAK = {};\n\n/**\n * @public\n */\nexport const getNodeType = node => node === null || node === void 0 ? void 0 : node.type;\n\n/**\n * @public\n */\nexport const isNode = node => typeof getNodeType(node) === 'string';\n\n/**\n * @public\n */\nexport const cloneNode = node => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n * `exposeEdits=true` can be used to expose the edited node from the previous visitors.\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nexport const mergeAll = (visitors, {\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  exposeEdits = false\n} = {}) => {\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nconst mergeAllAsync = (visitors, {\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  exposeEdits = false\n} = {}) => {\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    async enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    async leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nmergeAll[Symbol.for('nodejs.util.promisify.custom')] = mergeAllAsync;\n\n/* eslint-disable no-continue, no-param-reassign */\n/**\n * visit() will walk through an AST using a preorder depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * @example\n * ```\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // return\n *         //   undefined: no action\n *         //   false: no action\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *```\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n * ```\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n * ```\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n * ```\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n * ```\n * 3) Generic visitors that trigger upon entering and leaving any node.\n * ```\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n * ```\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n * ```\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n * ```\n *  sig `visit :: (Node, Visitor, Options)`\n *\n *  sig `Options = { keyMap: Object, state: Object }`\n *\n *  @public\n */\nexport const visit = (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor, {\n  keyMap = null,\n  state = {},\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  nodePredicate = isNode,\n  nodeCloneFn = cloneNode,\n  detectCycles = true,\n  detectCyclesCallback = null\n} = {}) => {\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _result;\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(`Invalid AST Node:  ${String(node)}`, {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        if (typeof detectCyclesCallback === 'function') {\n          // @ts-ignore\n          detectCyclesCallback(node, key, parent, path, ancestors);\n        }\n        path.pop();\n        continue;\n      }\n      // call appropriate visitor function if available\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = visitFn.call(visitor, node, key, parent, path, ancestors, link);\n      }\n\n      // check if the visitor is async\n      if (typeof ((_result = result) === null || _result === void 0 ? void 0 : _result.then) === 'function') {\n        throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n          visitor,\n          visitFn\n        });\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/**\n * Asynchronous version of visit.\n */\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor, {\n  keyMap = null,\n  state = {},\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  nodePredicate = isNode,\n  nodeCloneFn = cloneNode,\n  detectCycles = true,\n  detectCyclesCallback = null\n} = {}) => {\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(`Invalid AST Node: ${String(node)}`, {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        if (typeof detectCyclesCallback === 'function') {\n          // @ts-ignore\n          detectCyclesCallback(node, key, parent, path, ancestors);\n        }\n        path.pop();\n        continue;\n      }\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = await visitFn.call(visitor, node, key, parent, path, ancestors, link); // eslint-disable-line no-await-in-loop\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType2;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/* eslint-enable */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}