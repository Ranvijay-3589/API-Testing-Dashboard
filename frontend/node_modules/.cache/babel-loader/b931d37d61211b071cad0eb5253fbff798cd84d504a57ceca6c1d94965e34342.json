{"ast":null,"code":"import { cloneShallow, isArrayElement, ObjectElement, StringElement, MemberElement, toValue, visit, isMemberElement, isStringElement } from '@swagger-api/apidom-core';\nimport { isReferenceLikeElement, isDiscriminatorElement } from '@swagger-api/apidom-ns-openapi-3-0';\nimport NormalizeStorage from \"./normalize-header-examples/NormalizeStorage.mjs\";\nimport { isSchemaElement } from \"../../predicates.mjs\";\nimport DiscriminatorElement from \"../../elements/Discriminator.mjs\";\n/**\n * Normalization of Discriminator.mapping field.\n *\n * Discriminator.mapping fields are normalized by adding missing mappings from oneOf/anyOf items\n * of the parent Schema Object and transforming existing mappings to Schema Objects.\n *\n * In case of allOf discriminator, the plugin will add missing mappings based on\n * allOf items of other Schema Objects.\n *\n * The normalized mapping is stored in the Schema.discriminator field as `x-normalized-mapping`.\n *\n * This plugin is designed to be used on dereferenced OpenAPI 3.1 documents.\n *\n * NOTE: this plugin is idempotent\n * @public\n */\n/**\n * @public\n */\nconst plugin = function () {\n  let {\n    storageField = 'x-normalized',\n    baseURI = ''\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return toolbox => {\n    const {\n      ancestorLineageToJSONPointer\n    } = toolbox;\n    let storage;\n    let allOfDiscriminatorMapping;\n    return {\n      visitor: {\n        OpenApi3_1Element: {\n          enter(element) {\n            var _element$getMetaPrope;\n            storage = new NormalizeStorage(element, storageField, 'discriminator-mapping');\n            allOfDiscriminatorMapping = (_element$getMetaPrope = element.getMetaProperty('allOfDiscriminatorMapping')) !== null && _element$getMetaPrope !== void 0 ? _element$getMetaPrope : new ObjectElement();\n          },\n          leave() {\n            storage = undefined;\n          }\n        },\n        SchemaElement: {\n          leave(schemaElement, key, parent, path, ancestors) {\n            var _parentElement$classe, _schemaElement$discri;\n            // no Schema.discriminator field present\n            if (!isDiscriminatorElement(schemaElement.discriminator)) {\n              return;\n            }\n            const schemaJSONPointer = ancestorLineageToJSONPointer([...ancestors, parent, schemaElement]);\n\n            // skip visiting this Schema Object if it's already normalized\n            if (storage.includes(schemaJSONPointer)) {\n              return;\n            }\n\n            // skip if both oneOf and anyOf are present\n            if (isArrayElement(schemaElement.oneOf) && isArrayElement(schemaElement.anyOf)) {\n              return;\n            }\n            const parentElement = ancestors[ancestors.length - 1];\n            const schemaName = schemaElement.getMetaProperty('schemaName');\n            const allOfMapping = allOfDiscriminatorMapping.getMember(toValue(schemaName));\n            const hasAllOfMapping =\n            // @ts-ignore\n            allOfMapping && !(parentElement !== null && parentElement !== void 0 && (_parentElement$classe = parentElement.classes) !== null && _parentElement$classe !== void 0 && _parentElement$classe.contains('json-schema-allOf'));\n\n            // skip if neither oneOf, anyOf nor allOf is present\n            if (!isArrayElement(schemaElement.oneOf) && !isArrayElement(schemaElement.anyOf) && !hasAllOfMapping) {\n              return;\n            }\n            const mapping = (_schemaElement$discri = schemaElement.discriminator.get('mapping')) !== null && _schemaElement$discri !== void 0 ? _schemaElement$discri : new ObjectElement();\n            const normalizedMapping = new ObjectElement();\n            let isNormalized = true;\n            const items = isArrayElement(schemaElement.oneOf) ? schemaElement.oneOf : isArrayElement(schemaElement.anyOf) ? schemaElement.anyOf : allOfMapping.value;\n            items.forEach(item => {\n              if (!isSchemaElement(item)) {\n                return;\n              }\n              if (isReferenceLikeElement(item)) {\n                isNormalized = false;\n                return;\n              }\n              const metaRefFields = toValue(item.getMetaProperty('ref-fields'));\n              const metaRefOrigin = toValue(item.getMetaProperty('ref-origin'));\n              const metaSchemaName = toValue(item.getMetaProperty('schemaName'));\n\n              /**\n               * handle external references and internal references\n               * that don't point to components/schemas/<SchemaName>\n               */\n              if (!hasAllOfMapping && (metaRefOrigin !== baseURI || !metaSchemaName && metaRefFields)) {\n                let hasMatchingMapping = false;\n                mapping.forEach((mappingValue, mappingKey) => {\n                  var _mappingValueSchema$g;\n                  const mappingValueSchema = mappingValue.getMetaProperty('ref-schema');\n                  const mappingValueSchemaRefBaseURI = mappingValueSchema === null || mappingValueSchema === void 0 || (_mappingValueSchema$g = mappingValueSchema.getMetaProperty('ref-fields')) === null || _mappingValueSchema$g === void 0 ? void 0 : _mappingValueSchema$g.get('$refBaseURI');\n                  if (mappingValueSchemaRefBaseURI !== null && mappingValueSchemaRefBaseURI !== void 0 && mappingValueSchemaRefBaseURI.equals(metaRefFields === null || metaRefFields === void 0 ? void 0 : metaRefFields.$refBaseURI)) {\n                    normalizedMapping.set(toValue(mappingKey), cloneShallow(item));\n                    hasMatchingMapping = true;\n                  }\n                });\n                if (!hasMatchingMapping) {\n                  isNormalized = false;\n                }\n                return;\n              }\n\n              // handle internal references that point to components/schemas/<SchemaName>\n              if (metaSchemaName) {\n                let hasMatchingMapping = false;\n                mapping.forEach((mappingValue, mappingKey) => {\n                  var _mappingValueSchema$g2;\n                  const mappingValueSchema = mappingValue.getMetaProperty('ref-schema');\n                  const mappingValueSchemaName = mappingValueSchema === null || mappingValueSchema === void 0 ? void 0 : mappingValueSchema.getMetaProperty('schemaName');\n                  const mappingValueSchemaRefBaseURI = mappingValueSchema === null || mappingValueSchema === void 0 || (_mappingValueSchema$g2 = mappingValueSchema.getMetaProperty('ref-fields')) === null || _mappingValueSchema$g2 === void 0 ? void 0 : _mappingValueSchema$g2.get('$refBaseURI');\n                  if (mappingValueSchemaName !== null && mappingValueSchemaName !== void 0 && mappingValueSchemaName.equals(metaSchemaName) && (!hasAllOfMapping || mappingValueSchemaRefBaseURI !== null && mappingValueSchemaRefBaseURI !== void 0 && mappingValueSchemaRefBaseURI.equals(metaRefFields === null || metaRefFields === void 0 ? void 0 : metaRefFields.$refBaseURI))) {\n                    normalizedMapping.set(toValue(mappingKey), cloneShallow(item));\n                    hasMatchingMapping = true;\n                  }\n                });\n\n                // add a new mapping if no matching mapping was found\n                if (!hasMatchingMapping) {\n                  normalizedMapping.set(metaSchemaName, cloneShallow(item));\n                }\n              }\n            });\n\n            // check if any mapping is not a Schema Object or if any mapping was not normalized\n            const mappingKeys = mapping.keys();\n            const normalizedMappingKeys = normalizedMapping.keys();\n            isNormalized = isNormalized && normalizedMapping.filter(mappingValue => !isSchemaElement(mappingValue)).length === 0 && mappingKeys.every(mappingKey => normalizedMappingKeys.includes(mappingKey));\n            if (isNormalized) {\n              schemaElement.discriminator.set('x-normalized-mapping', normalizedMapping);\n\n              // dive in and eliminate cycles that might be created by normalization\n              visit(schemaElement, {}, {\n                // @ts-ignore\n                detectCyclesCallback: (node, nodeKey, nodeParent) => {\n                  if (!nodeParent || !isMemberElement(node) || !isStringElement(node.key) || !node.key.equals('discriminator') || !isDiscriminatorElement(node.value)) {\n                    return;\n                  }\n                  const discriminator = cloneShallow(node.value);\n                  const discriminatorCopy = new DiscriminatorElement();\n                  if (discriminator.get('mapping')) {\n                    discriminatorCopy.mapping = discriminator.get('mapping');\n                  }\n                  if (discriminator.get('propertyName')) {\n                    discriminatorCopy.propertyName = discriminator.get('propertyName');\n                  }\n\n                  // eslint-disable-next-line no-param-reassign\n                  nodeParent[nodeKey] = new MemberElement(new StringElement('discriminator'), discriminatorCopy);\n                }\n              });\n              storage.append(schemaJSONPointer);\n            }\n          }\n        }\n      }\n    };\n  };\n};\nexport default plugin;","map":{"version":3,"names":["cloneShallow","isArrayElement","ObjectElement","StringElement","MemberElement","toValue","visit","isMemberElement","isStringElement","isReferenceLikeElement","isDiscriminatorElement","NormalizeStorage","isSchemaElement","DiscriminatorElement","plugin","storageField","baseURI","arguments","length","undefined","toolbox","ancestorLineageToJSONPointer","storage","allOfDiscriminatorMapping","visitor","OpenApi3_1Element","enter","element","_element$getMetaPrope","getMetaProperty","leave","SchemaElement","schemaElement","key","parent","path","ancestors","_parentElement$classe","_schemaElement$discri","discriminator","schemaJSONPointer","includes","oneOf","anyOf","parentElement","schemaName","allOfMapping","getMember","hasAllOfMapping","classes","contains","mapping","get","normalizedMapping","isNormalized","items","value","forEach","item","metaRefFields","metaRefOrigin","metaSchemaName","hasMatchingMapping","mappingValue","mappingKey","_mappingValueSchema$g","mappingValueSchema","mappingValueSchemaRefBaseURI","equals","$refBaseURI","set","_mappingValueSchema$g2","mappingValueSchemaName","mappingKeys","keys","normalizedMappingKeys","filter","every","detectCyclesCallback","node","nodeKey","nodeParent","discriminatorCopy","propertyName","append"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-discriminator-mapping.mjs"],"sourcesContent":["import { cloneShallow, isArrayElement, ObjectElement, StringElement, MemberElement, toValue, visit, isMemberElement, isStringElement } from '@swagger-api/apidom-core';\nimport { isReferenceLikeElement, isDiscriminatorElement } from '@swagger-api/apidom-ns-openapi-3-0';\nimport NormalizeStorage from \"./normalize-header-examples/NormalizeStorage.mjs\";\nimport { isSchemaElement } from \"../../predicates.mjs\";\nimport DiscriminatorElement from \"../../elements/Discriminator.mjs\";\n/**\n * Normalization of Discriminator.mapping field.\n *\n * Discriminator.mapping fields are normalized by adding missing mappings from oneOf/anyOf items\n * of the parent Schema Object and transforming existing mappings to Schema Objects.\n *\n * In case of allOf discriminator, the plugin will add missing mappings based on\n * allOf items of other Schema Objects.\n *\n * The normalized mapping is stored in the Schema.discriminator field as `x-normalized-mapping`.\n *\n * This plugin is designed to be used on dereferenced OpenAPI 3.1 documents.\n *\n * NOTE: this plugin is idempotent\n * @public\n */\n/**\n * @public\n */\nconst plugin = ({\n  storageField = 'x-normalized',\n  baseURI = ''\n} = {}) => toolbox => {\n  const {\n    ancestorLineageToJSONPointer\n  } = toolbox;\n  let storage;\n  let allOfDiscriminatorMapping;\n  return {\n    visitor: {\n      OpenApi3_1Element: {\n        enter(element) {\n          var _element$getMetaPrope;\n          storage = new NormalizeStorage(element, storageField, 'discriminator-mapping');\n          allOfDiscriminatorMapping = (_element$getMetaPrope = element.getMetaProperty('allOfDiscriminatorMapping')) !== null && _element$getMetaPrope !== void 0 ? _element$getMetaPrope : new ObjectElement();\n        },\n        leave() {\n          storage = undefined;\n        }\n      },\n      SchemaElement: {\n        leave(schemaElement, key, parent, path, ancestors) {\n          var _parentElement$classe, _schemaElement$discri;\n          // no Schema.discriminator field present\n          if (!isDiscriminatorElement(schemaElement.discriminator)) {\n            return;\n          }\n          const schemaJSONPointer = ancestorLineageToJSONPointer([...ancestors, parent, schemaElement]);\n\n          // skip visiting this Schema Object if it's already normalized\n          if (storage.includes(schemaJSONPointer)) {\n            return;\n          }\n\n          // skip if both oneOf and anyOf are present\n          if (isArrayElement(schemaElement.oneOf) && isArrayElement(schemaElement.anyOf)) {\n            return;\n          }\n          const parentElement = ancestors[ancestors.length - 1];\n          const schemaName = schemaElement.getMetaProperty('schemaName');\n          const allOfMapping = allOfDiscriminatorMapping.getMember(toValue(schemaName));\n          const hasAllOfMapping =\n          // @ts-ignore\n          allOfMapping && !(parentElement !== null && parentElement !== void 0 && (_parentElement$classe = parentElement.classes) !== null && _parentElement$classe !== void 0 && _parentElement$classe.contains('json-schema-allOf'));\n\n          // skip if neither oneOf, anyOf nor allOf is present\n          if (!isArrayElement(schemaElement.oneOf) && !isArrayElement(schemaElement.anyOf) && !hasAllOfMapping) {\n            return;\n          }\n          const mapping = (_schemaElement$discri = schemaElement.discriminator.get('mapping')) !== null && _schemaElement$discri !== void 0 ? _schemaElement$discri : new ObjectElement();\n          const normalizedMapping = new ObjectElement();\n          let isNormalized = true;\n          const items = isArrayElement(schemaElement.oneOf) ? schemaElement.oneOf : isArrayElement(schemaElement.anyOf) ? schemaElement.anyOf : allOfMapping.value;\n          items.forEach(item => {\n            if (!isSchemaElement(item)) {\n              return;\n            }\n            if (isReferenceLikeElement(item)) {\n              isNormalized = false;\n              return;\n            }\n            const metaRefFields = toValue(item.getMetaProperty('ref-fields'));\n            const metaRefOrigin = toValue(item.getMetaProperty('ref-origin'));\n            const metaSchemaName = toValue(item.getMetaProperty('schemaName'));\n\n            /**\n             * handle external references and internal references\n             * that don't point to components/schemas/<SchemaName>\n             */\n            if (!hasAllOfMapping && (metaRefOrigin !== baseURI || !metaSchemaName && metaRefFields)) {\n              let hasMatchingMapping = false;\n              mapping.forEach((mappingValue, mappingKey) => {\n                var _mappingValueSchema$g;\n                const mappingValueSchema = mappingValue.getMetaProperty('ref-schema');\n                const mappingValueSchemaRefBaseURI = mappingValueSchema === null || mappingValueSchema === void 0 || (_mappingValueSchema$g = mappingValueSchema.getMetaProperty('ref-fields')) === null || _mappingValueSchema$g === void 0 ? void 0 : _mappingValueSchema$g.get('$refBaseURI');\n                if (mappingValueSchemaRefBaseURI !== null && mappingValueSchemaRefBaseURI !== void 0 && mappingValueSchemaRefBaseURI.equals(metaRefFields === null || metaRefFields === void 0 ? void 0 : metaRefFields.$refBaseURI)) {\n                  normalizedMapping.set(toValue(mappingKey), cloneShallow(item));\n                  hasMatchingMapping = true;\n                }\n              });\n              if (!hasMatchingMapping) {\n                isNormalized = false;\n              }\n              return;\n            }\n\n            // handle internal references that point to components/schemas/<SchemaName>\n            if (metaSchemaName) {\n              let hasMatchingMapping = false;\n              mapping.forEach((mappingValue, mappingKey) => {\n                var _mappingValueSchema$g2;\n                const mappingValueSchema = mappingValue.getMetaProperty('ref-schema');\n                const mappingValueSchemaName = mappingValueSchema === null || mappingValueSchema === void 0 ? void 0 : mappingValueSchema.getMetaProperty('schemaName');\n                const mappingValueSchemaRefBaseURI = mappingValueSchema === null || mappingValueSchema === void 0 || (_mappingValueSchema$g2 = mappingValueSchema.getMetaProperty('ref-fields')) === null || _mappingValueSchema$g2 === void 0 ? void 0 : _mappingValueSchema$g2.get('$refBaseURI');\n                if (mappingValueSchemaName !== null && mappingValueSchemaName !== void 0 && mappingValueSchemaName.equals(metaSchemaName) && (!hasAllOfMapping || mappingValueSchemaRefBaseURI !== null && mappingValueSchemaRefBaseURI !== void 0 && mappingValueSchemaRefBaseURI.equals(metaRefFields === null || metaRefFields === void 0 ? void 0 : metaRefFields.$refBaseURI))) {\n                  normalizedMapping.set(toValue(mappingKey), cloneShallow(item));\n                  hasMatchingMapping = true;\n                }\n              });\n\n              // add a new mapping if no matching mapping was found\n              if (!hasMatchingMapping) {\n                normalizedMapping.set(metaSchemaName, cloneShallow(item));\n              }\n            }\n          });\n\n          // check if any mapping is not a Schema Object or if any mapping was not normalized\n          const mappingKeys = mapping.keys();\n          const normalizedMappingKeys = normalizedMapping.keys();\n          isNormalized = isNormalized && normalizedMapping.filter(mappingValue => !isSchemaElement(mappingValue)).length === 0 && mappingKeys.every(mappingKey => normalizedMappingKeys.includes(mappingKey));\n          if (isNormalized) {\n            schemaElement.discriminator.set('x-normalized-mapping', normalizedMapping);\n\n            // dive in and eliminate cycles that might be created by normalization\n            visit(schemaElement, {}, {\n              // @ts-ignore\n              detectCyclesCallback: (node, nodeKey, nodeParent) => {\n                if (!nodeParent || !isMemberElement(node) || !isStringElement(node.key) || !node.key.equals('discriminator') || !isDiscriminatorElement(node.value)) {\n                  return;\n                }\n                const discriminator = cloneShallow(node.value);\n                const discriminatorCopy = new DiscriminatorElement();\n                if (discriminator.get('mapping')) {\n                  discriminatorCopy.mapping = discriminator.get('mapping');\n                }\n                if (discriminator.get('propertyName')) {\n                  discriminatorCopy.propertyName = discriminator.get('propertyName');\n                }\n\n                // eslint-disable-next-line no-param-reassign\n                nodeParent[nodeKey] = new MemberElement(new StringElement('discriminator'), discriminatorCopy);\n              }\n            });\n            storage.append(schemaJSONPointer);\n          }\n        }\n      }\n    }\n  };\n};\nexport default plugin;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}