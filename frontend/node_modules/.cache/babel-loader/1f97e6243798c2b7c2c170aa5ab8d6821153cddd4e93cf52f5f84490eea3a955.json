{"ast":null,"code":"const util = require('./util');\nconst types = require('./types');\nconst sets = require('./sets');\nconst positions = require('./positions');\nmodule.exports = regexpStr => {\n  var i = 0,\n    l,\n    c,\n    start = {\n      type: types.ROOT,\n      stack: []\n    },\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n  var repeatErr = i => {\n    util.error(regexpStr, \"Nothing to repeat at column \".concat(i - 1));\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n          case 'w':\n            last.push(sets.words());\n            break;\n          case 'W':\n            last.push(sets.notWords());\n            break;\n          case 'd':\n            last.push(sets.ints());\n            break;\n          case 'D':\n            last.push(sets.notInts());\n            break;\n          case 's':\n            last.push(sets.whitespace());\n            break;\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({\n                type: types.REFERENCE,\n                value: parseInt(c, 10)\n              });\n\n              // Escaped character.\n            } else {\n              last.push({\n                type: types.CHAR,\n                value: c.charCodeAt(0)\n              });\n            }\n        }\n        break;\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n      case '$':\n        last.push(positions.end());\n        break;\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not\n        });\n        break;\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true\n        };\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n            // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n          } else if (c !== ':') {\n            util.error(regexpStr, \"Invalid group, character '\".concat(c, \"'\") + \" after '?' at column \".concat(i - 1));\n          }\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, \"Unmatched ) at column \".concat(i - 1));\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)),\n          min,\n          max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop()\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123\n          });\n        }\n        break;\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop()\n        });\n        break;\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop()\n        });\n        break;\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop()\n        });\n        break;\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0)\n        });\n    }\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n  return start;\n};\nmodule.exports.types = types;","map":{"version":3,"names":["util","require","types","sets","positions","module","exports","regexpStr","i","l","c","start","type","ROOT","stack","lastGroup","last","groupStack","repeatErr","error","concat","str","strToChars","length","push","wordBoundary","nonWordBoundary","words","notWords","ints","notInts","whitespace","notWhitespace","test","REFERENCE","value","parseInt","CHAR","charCodeAt","begin","end","not","classTokens","tokenizeClass","slice","SET","set","anyChar","group","GROUP","remember","followedBy","notFollowedBy","pop","options","rs","exec","min","max","Infinity","REPETITION"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/ret/lib/index.js"],"sourcesContent":["const util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}