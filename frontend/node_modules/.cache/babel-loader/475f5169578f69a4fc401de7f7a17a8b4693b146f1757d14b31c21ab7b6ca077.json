{"ast":null,"code":"import _objectSpread from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport jsYaml from 'js-yaml';\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport '../../../helpers/fetch-polyfill.node.js';\nimport lib from './index.js';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers.js';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../../constants.js';\nconst ABSOLUTE_URL_REGEXP = /^([a-z]+:\\/\\/|\\/\\/)/i;\nclass JSONRefError extends ApiDOMStructuredError {}\nconst docCache = {};\nconst specmapRefs = new WeakMap();\nconst skipResolutionTestFns = [\n// OpenAPI 2.0 response examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"examples\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples',\n// OpenAPI 3.0 Response Media Type Examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value',\n// OpenAPI 3.0 Request Body Media Type Examples\npath =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value',\n// OAS 3.0 Parameter Examples\npath =>\n// [\"paths\", *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'];\nconst shouldSkipResolution = path => skipResolutionTestFns.some(fn => fn(path));\n\n// =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\nconst plugin = {\n  key: '$ref',\n  plugin: (ref, key, fullPath, specmap) => {\n    const specmapInstance = specmap.getInstance();\n    const parent = fullPath.slice(0, -1);\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n    const {\n      baseDoc\n    } = specmap.getContext(fullPath);\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc,\n        fullPath\n      });\n    }\n    const splitString = split(ref);\n    const refPath = splitString[0];\n    const pointer = splitString[1] || '';\n    let basePath;\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer,\n        $ref: ref,\n        basePath,\n        fullPath\n      });\n    }\n    let promOrVal;\n    let tokens;\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        const absolutifiedRef = absolutifyPointer(ref, basePath);\n        if (ref === absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n        return lib.replace(fullPath, absolutifiedRef);\n      }\n    }\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(\"Could not resolve reference: \".concat(ref), {\n          pointer,\n          $ref: ref,\n          baseDoc,\n          fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer);\n      // eslint-disable-next-line no-underscore-dangle\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(e => {\n          throw wrapError(e, {\n            pointer,\n            $ref: ref,\n            baseDoc,\n            fullPath\n          });\n        });\n      }\n    }\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n    const absolutifiedRef = absolutifyPointer(ref, basePath);\n    const patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n    return undefined;\n  }\n};\nconst mod = Object.assign(plugin, {\n  docCache,\n  absoluteify,\n  clearCache,\n  JSONRefError,\n  wrapError,\n  getDoc,\n  split,\n  extractFromDoc,\n  fetchJSON,\n  extract,\n  jsonPointerToArray,\n  unescapeJsonPointerToken\n});\nexport default mod;\n\n// =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      throw new JSONRefError(\"Tried to resolve a relative URL, without having a basePath. path: '\".concat(path, \"' basePath: '\").concat(basePath, \"'\"));\n    }\n    return url.resolve(basePath, path);\n  }\n  return path;\n}\n\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\nfunction wrapError(e, extra) {\n  let message;\n  if (e && e.response && e.response.body) {\n    message = \"\".concat(e.response.body.code, \" \").concat(e.response.body.message);\n  } else {\n    message = e.message;\n  }\n  return new JSONRefError(\"Could not resolve reference: \".concat(message), _objectSpread(_objectSpread({}, extra), {}, {\n    cause: e\n  }));\n}\n\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\nfunction extractFromDoc(docPath, pointer) {\n  const doc = docCache[docPath];\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      const v = extract(pointer, doc);\n      return Object.assign(Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  return getDoc(docPath).then(_doc => extract(pointer, _doc));\n}\n\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    Object.keys(docCache).forEach(key => {\n      delete docCache[key];\n    });\n  }\n}\n\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction getDoc(docPath) {\n  const val = docCache[docPath];\n  if (val) {\n    return lib.isPromise(val) ? val : Promise.resolve(val);\n  }\n\n  // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n  docCache[docPath] = mod.fetchJSON(docPath).then(doc => {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(res => res.text()).then(text => jsYaml.load(text));\n}\n\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\nfunction extract(pointer, obj) {\n  const tokens = jsonPointerToArray(pointer);\n  if (tokens.length < 1) {\n    return obj;\n  }\n  const val = lib.getIn(obj, tokens);\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(\"Could not resolve pointer: \".concat(pointer, \" does not exist in document\"), {\n      pointer\n    });\n  }\n  return val;\n}\n\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\nfunction jsonPointerToArray(pointer) {\n  if (typeof pointer !== 'string') {\n    throw new TypeError(\"Expected a string, got a \".concat(typeof pointer));\n  }\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n  if (pointer === '') {\n    return [];\n  }\n  return pointer.split('/').map(unescapeJsonPointerToken);\n}\n\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n  const params = new URLSearchParams(\"=\".concat(token.replace(/~1/g, '/').replace(/~0/g, '~')));\n  return params.get('');\n}\n\n/**\n * Escapes a JSON pointer.\n * @api public\n */\nfunction escapeJsonPointerToken(token) {\n  const params = new URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return params.toString().slice(1);\n}\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n  return \"/\".concat(arr.map(escapeJsonPointerToken).join('/'));\n}\nconst pointerBoundaryChar = c => !c || c === '/' || c === '#';\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n  const nextChar = pointer.charAt(parentPointer.length);\n  const lastParentChar = parentPointer.slice(-1);\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n}\n\n// =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  let refs = specmapRefs.get(specmap);\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n  const parentPointer = arrayToJsonPointer(parent);\n  const fullyQualifiedPointer = \"\".concat(basePath || '<specmap-base>', \"#\").concat(pointer);\n\n  // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n  const safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, '');\n\n  // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n  const rootDoc = specmap.contextTree.get([]).baseDoc;\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  }\n\n  // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n  let currPath = '';\n  const hasIndirectCycle = parent.some(token => {\n    currPath = \"\".concat(currPath, \"/\").concat(escapeJsonPointerToken(token));\n    return refs[currPath] && refs[currPath].some(ref => pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref));\n  });\n  if (hasIndirectCycle) {\n    return true;\n  }\n\n  // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n  refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);\n  return undefined;\n}\n\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\nfunction patchValueAlreadyInPath(root, patch) {\n  const ancestors = [root];\n  patch.path.reduce((parent, p) => {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || Object.keys(obj).some(k => pointToAncestor(obj[k])));\n  }\n}","map":{"version":3,"names":["jsYaml","ApiDOMStructuredError","url","lib","isFreelyNamed","absolutifyPointer","ACCEPT_HEADER_VALUE_FOR_DOCUMENTS","ABSOLUTE_URL_REGEXP","JSONRefError","docCache","specmapRefs","WeakMap","skipResolutionTestFns","path","shouldSkipResolution","some","fn","plugin","key","ref","fullPath","specmap","specmapInstance","getInstance","parent","slice","undefined","baseDoc","getContext","$ref","splitString","split","refPath","pointer","basePath","absoluteify","e","wrapError","promOrVal","tokens","pointerAlreadyInPath","useCircularStructures","absolutifiedRef","replace","jsonPointerToArray","get","concat","extractFromDoc","__value","catch","Error","remove","patch","$$ref","context","patchValueAlreadyInPath","state","mod","Object","assign","clearCache","getDoc","fetchJSON","extract","unescapeJsonPointerToken","test","resolve","extra","message","response","body","code","_objectSpread","cause","docPath","doc","isPromise","v","Promise","reject","then","_doc","item","keys","forEach","val","fetch","headers","Accept","loadSpec","res","text","load","obj","length","getIn","TypeError","substr","map","token","params","URLSearchParams","escapeJsonPointerToken","toString","arrayToJsonPointer","arr","join","pointerBoundaryChar","c","pointerIsAParent","parentPointer","nextChar","charAt","lastParentChar","indexOf","refs","set","fullyQualifiedPointer","safeParentPointer","rootDoc","contextTree","currPath","hasIndirectCycle","root","ancestors","reduce","p","push","pointToAncestor","value","isObject","k"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/swagger-client/es/resolver/specmap/lib/refs.js"],"sourcesContent":["import jsYaml from 'js-yaml';\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport '../../../helpers/fetch-polyfill.node.js';\nimport lib from './index.js';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers.js';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../../constants.js';\nconst ABSOLUTE_URL_REGEXP = /^([a-z]+:\\/\\/|\\/\\/)/i;\nclass JSONRefError extends ApiDOMStructuredError {}\nconst docCache = {};\nconst specmapRefs = new WeakMap();\nconst skipResolutionTestFns = [\n// OpenAPI 2.0 response examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"examples\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples',\n// OpenAPI 3.0 Response Media Type Examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value',\n// OpenAPI 3.0 Request Body Media Type Examples\npath =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value',\n// OAS 3.0 Parameter Examples\npath =>\n// [\"paths\", *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'];\nconst shouldSkipResolution = path => skipResolutionTestFns.some(fn => fn(path));\n\n// =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\nconst plugin = {\n  key: '$ref',\n  plugin: (ref, key, fullPath, specmap) => {\n    const specmapInstance = specmap.getInstance();\n    const parent = fullPath.slice(0, -1);\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n    const {\n      baseDoc\n    } = specmap.getContext(fullPath);\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc,\n        fullPath\n      });\n    }\n    const splitString = split(ref);\n    const refPath = splitString[0];\n    const pointer = splitString[1] || '';\n    let basePath;\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer,\n        $ref: ref,\n        basePath,\n        fullPath\n      });\n    }\n    let promOrVal;\n    let tokens;\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        const absolutifiedRef = absolutifyPointer(ref, basePath);\n        if (ref === absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n        return lib.replace(fullPath, absolutifiedRef);\n      }\n    }\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(`Could not resolve reference: ${ref}`, {\n          pointer,\n          $ref: ref,\n          baseDoc,\n          fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer);\n      // eslint-disable-next-line no-underscore-dangle\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(e => {\n          throw wrapError(e, {\n            pointer,\n            $ref: ref,\n            baseDoc,\n            fullPath\n          });\n        });\n      }\n    }\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n    const absolutifiedRef = absolutifyPointer(ref, basePath);\n    const patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n    return undefined;\n  }\n};\nconst mod = Object.assign(plugin, {\n  docCache,\n  absoluteify,\n  clearCache,\n  JSONRefError,\n  wrapError,\n  getDoc,\n  split,\n  extractFromDoc,\n  fetchJSON,\n  extract,\n  jsonPointerToArray,\n  unescapeJsonPointerToken\n});\nexport default mod;\n\n// =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      throw new JSONRefError(`Tried to resolve a relative URL, without having a basePath. path: '${path}' basePath: '${basePath}'`);\n    }\n    return url.resolve(basePath, path);\n  }\n  return path;\n}\n\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\nfunction wrapError(e, extra) {\n  let message;\n  if (e && e.response && e.response.body) {\n    message = `${e.response.body.code} ${e.response.body.message}`;\n  } else {\n    message = e.message;\n  }\n  return new JSONRefError(`Could not resolve reference: ${message}`, {\n    ...extra,\n    cause: e\n  });\n}\n\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\nfunction extractFromDoc(docPath, pointer) {\n  const doc = docCache[docPath];\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      const v = extract(pointer, doc);\n      return Object.assign(Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  return getDoc(docPath).then(_doc => extract(pointer, _doc));\n}\n\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    Object.keys(docCache).forEach(key => {\n      delete docCache[key];\n    });\n  }\n}\n\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction getDoc(docPath) {\n  const val = docCache[docPath];\n  if (val) {\n    return lib.isPromise(val) ? val : Promise.resolve(val);\n  }\n\n  // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n  docCache[docPath] = mod.fetchJSON(docPath).then(doc => {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(res => res.text()).then(text => jsYaml.load(text));\n}\n\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\nfunction extract(pointer, obj) {\n  const tokens = jsonPointerToArray(pointer);\n  if (tokens.length < 1) {\n    return obj;\n  }\n  const val = lib.getIn(obj, tokens);\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(`Could not resolve pointer: ${pointer} does not exist in document`, {\n      pointer\n    });\n  }\n  return val;\n}\n\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\nfunction jsonPointerToArray(pointer) {\n  if (typeof pointer !== 'string') {\n    throw new TypeError(`Expected a string, got a ${typeof pointer}`);\n  }\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n  if (pointer === '') {\n    return [];\n  }\n  return pointer.split('/').map(unescapeJsonPointerToken);\n}\n\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n  const params = new URLSearchParams(`=${token.replace(/~1/g, '/').replace(/~0/g, '~')}`);\n  return params.get('');\n}\n\n/**\n * Escapes a JSON pointer.\n * @api public\n */\nfunction escapeJsonPointerToken(token) {\n  const params = new URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return params.toString().slice(1);\n}\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n  return `/${arr.map(escapeJsonPointerToken).join('/')}`;\n}\nconst pointerBoundaryChar = c => !c || c === '/' || c === '#';\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n  const nextChar = pointer.charAt(parentPointer.length);\n  const lastParentChar = parentPointer.slice(-1);\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n}\n\n// =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  let refs = specmapRefs.get(specmap);\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n  const parentPointer = arrayToJsonPointer(parent);\n  const fullyQualifiedPointer = `${basePath || '<specmap-base>'}#${pointer}`;\n\n  // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n  const safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, '');\n\n  // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n  const rootDoc = specmap.contextTree.get([]).baseDoc;\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  }\n\n  // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n  let currPath = '';\n  const hasIndirectCycle = parent.some(token => {\n    currPath = `${currPath}/${escapeJsonPointerToken(token)}`;\n    return refs[currPath] && refs[currPath].some(ref => pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref));\n  });\n  if (hasIndirectCycle) {\n    return true;\n  }\n\n  // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n  refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);\n  return undefined;\n}\n\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\nfunction patchValueAlreadyInPath(root, patch) {\n  const ancestors = [root];\n  patch.path.reduce((parent, p) => {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || Object.keys(obj).some(k => pointToAncestor(obj[k])));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}