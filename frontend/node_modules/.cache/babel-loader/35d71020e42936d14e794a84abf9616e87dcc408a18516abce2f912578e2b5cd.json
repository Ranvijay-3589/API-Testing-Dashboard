{"ast":null,"code":"import _objectSpread from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { propEq, none } from 'ramda';\nimport { isUndefined } from 'ramda-adjunct';\nimport { isElement, isPrimitiveElement, isStringElement, isMemberElement, isObjectElement, IdentityManager, visit, find, cloneShallow, cloneDeep, toValue, RefElement } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { evaluate as jsonPointerEvaluate, URIFragmentIdentifier } from '@swagger-api/apidom-json-pointer/modern';\nimport { getNodeType, isReferenceLikeElement, keyMap, ReferenceElement, PathItemElement, OperationElement, SchemaElement, isPathItemElement, isReferenceElement, isSchemaElement, isOperationElement, isBooleanJsonSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from \"./selectors/$anchor.mjs\";\nimport { evaluate as uriEvaluate } from \"./selectors/uri.mjs\";\nimport MaximumDereferenceDepthError from \"../../../errors/MaximumDereferenceDepthError.mjs\";\nimport MaximumResolveDepthError from \"../../../errors/MaximumResolveDepthError.mjs\";\nimport * as url from \"../../../util/url.mjs\";\nimport parse from \"../../../parse/index.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport File from \"../../../File.mjs\";\nimport { resolveSchema$refField, maybeRefractToSchemaElement } from \"./util.mjs\";\nimport { AncestorLineage } from \"../../util.mjs\";\nimport EvaluationJsonSchemaUriError from \"../../../errors/EvaluationJsonSchemaUriError.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n/**\n * Custom mutation replacer.\n * @public\n */\nexport const mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass OpenAPI3_1DereferenceVisitor {\n  constructor(_ref) {\n    let {\n      reference,\n      namespace,\n      options,\n      indirections = [],\n      ancestors = new AncestorLineage(),\n      refractCache = new Map(),\n      allOfDiscriminatorMapping = new Map()\n    } = _ref;\n    _defineProperty(this, \"indirections\", void 0);\n    _defineProperty(this, \"namespace\", void 0);\n    _defineProperty(this, \"reference\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"ancestors\", void 0);\n    _defineProperty(this, \"refractCache\", void 0);\n    _defineProperty(this, \"allOfDiscriminatorMapping\", void 0);\n    _defineProperty(this, \"OpenApi3_1Element\", {\n      leave: (openApi3_1Element, key, parent, path, ancestors, link) => {\n        var _this$options$derefer6;\n        if (!((_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer6 !== void 0 && _this$options$derefer6.dereferenceDiscriminatorMapping)) {\n          return undefined;\n        }\n        const openApi3_1ElementCopy = cloneShallow(openApi3_1Element);\n        openApi3_1ElementCopy.setMetaProperty('allOfDiscriminatorMapping', Object.fromEntries(this.allOfDiscriminatorMapping));\n        link.replaceWith(openApi3_1ElementCopy, mutationReplacer);\n        return !parent ? openApi3_1ElementCopy : undefined;\n      }\n    });\n    this.indirections = indirections;\n    this.namespace = namespace;\n    this.reference = reference;\n    this.options = options;\n    this.ancestors = new AncestorLineage(...ancestors);\n    this.refractCache = refractCache;\n    this.allOfDiscriminatorMapping = allOfDiscriminatorMapping;\n  }\n  handleDereferenceError(error, refEl, directAncestors) {\n    var _this$options$derefer;\n    if ((_this$options$derefer = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer !== void 0 && _this$options$derefer.continueOnError) {\n      var _this$options$derefer3;\n      if (directAncestors) {\n        const ancestorWithRef = [...directAncestors].find(ancestor => isObjectElement(ancestor) && ancestor.getMetaProperty('ref-referencing-element'));\n        if (ancestorWithRef) {\n          var _this$options$derefer2;\n          (_this$options$derefer2 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.errors.push({\n            error,\n            refEl: ancestorWithRef.getMetaProperty('ref-referencing-element')\n          });\n        }\n      }\n      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || _this$options$derefer3.errors.push({\n        error,\n        refEl\n      });\n      return undefined;\n    }\n    throw error;\n  }\n  getNestedVisitorOptions(referencingElement) {\n    var _this$options$derefer4, _this$options$derefer5;\n    return _objectSpread(_objectSpread({}, this.options), {}, {\n      resolve: _objectSpread(_objectSpread({}, this.options.resolve), {}, {\n        external: (_this$options$derefer4 = this.options.dereference) !== null && _this$options$derefer4 !== void 0 && (_this$options$derefer4 = _this$options$derefer4.dereferenceOpts) !== null && _this$options$derefer4 !== void 0 && _this$options$derefer4.skipNestedExternal && toValue(referencingElement.get('$ref')).startsWith('#') ? false : this.options.resolve.external\n      }),\n      dereference: _objectSpread(_objectSpread({}, this.options.dereference), {}, {\n        dereferenceOpts: _objectSpread(_objectSpread({}, (_this$options$derefer5 = this.options.dereference) === null || _this$options$derefer5 === void 0 ? void 0 : _this$options$derefer5.dereferenceOpts), {}, {\n          continueOnError: false\n        })\n      })\n    });\n  }\n  toBaseURI(uri) {\n    return url.resolve(this.reference.uri, url.sanitize(url.stripHash(uri)));\n  }\n  async toReference(uri) {\n    // detect maximum depth of resolution\n    if (this.reference.depth >= this.options.resolve.maxDepth) {\n      throw new MaximumResolveDepthError(\"Maximum resolution depth of \".concat(this.options.resolve.maxDepth, \" has been exceeded by file \\\"\").concat(this.reference.uri, \"\\\"\"));\n    }\n    const baseURI = this.toBaseURI(uri);\n    const {\n      refSet\n    } = this.reference;\n\n    // we've already processed this Reference in past\n    if (refSet.has(baseURI)) {\n      return refSet.find(propEq(baseURI, 'uri'));\n    }\n    const parseResult = await parse(url.unsanitize(baseURI), _objectSpread(_objectSpread({}, this.options), {}, {\n      parse: _objectSpread(_objectSpread({}, this.options.parse), {}, {\n        mediaType: 'text/plain'\n      })\n    }));\n\n    // register new mutable reference with a refSet\n    const mutableReference = new Reference({\n      uri: baseURI,\n      value: cloneDeep(parseResult),\n      depth: this.reference.depth + 1\n    });\n    refSet.add(mutableReference);\n    if (this.options.dereference.immutable) {\n      // register new immutable reference with a refSet\n      const immutableReference = new Reference({\n        uri: \"immutable://\".concat(baseURI),\n        value: parseResult,\n        depth: this.reference.depth + 1\n      });\n      refSet.add(immutableReference);\n    }\n    return mutableReference;\n  }\n  toAncestorLineage(ancestors) {\n    /**\n     * Compute full ancestors lineage.\n     * Ancestors are flatten to unwrap all Element instances.\n     */\n    const directAncestors = new Set(ancestors.filter(isElement));\n    const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);\n    return [ancestorsLineage, directAncestors];\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer9, _this$options$derefer0;\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Reference Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    // ignore resolving external Reference Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    let reference;\n    try {\n      reference = await this.toReference(toValue(referencingElement.$ref));\n    } catch (error) {\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n    let referencedElement;\n    try {\n      // possibly non-semantic fragment\n      referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n    } catch (error) {\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    // applying semantics to a fragment\n    if (isPrimitiveElement(referencedElement)) {\n      const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n      const cacheKey = \"\".concat(referencedElementType, \"-\").concat(toValue(identityManager.identify(referencedElement)));\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else if (isReferenceLikeElement(referencedElement)) {\n        // handling indirect references\n        referencedElement = ReferenceElement.refract(referencedElement);\n        referencedElement.setMetaProperty('referenced-element', referencedElementType);\n        this.refractCache.set(cacheKey, referencedElement);\n      } else {\n        // handling direct references\n        const ElementClass = this.namespace.getElementClass(referencedElementType);\n        referencedElement = ElementClass.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      const error = new ApiDOMError('Recursive Reference Object detected');\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      const error = new MaximumDereferenceDepthError(\"Maximum dereference depth of \\\"\".concat(this.options.dereference.maxDepth, \"\\\" has been exceeded in file \\\"\").concat(this.reference.uri, \"\\\"\"));\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        const error = new ApiDOMError('Circular reference detected');\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n      if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer7, _this$options$derefer8;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'reference',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer7 = (_this$options$derefer8 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer8 === void 0 ? void 0 : _this$options$derefer8.circularReplacer) !== null && _this$options$derefer7 !== void 0 ? _this$options$derefer7 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular || (_this$options$derefer9 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer9 !== void 0 && _this$options$derefer9.continueOnError) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.getNestedVisitorOptions(referencingElement),\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      try {\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n      } catch (error) {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of referenced element to avoid modifying the original one.\n     */\n    const mergedElement = cloneShallow(referencedElement);\n    // assign unique id to merged element\n    mergedElement.setMetaProperty('id', identityManager.generateId());\n    // annotate fragment with info about original Reference element\n    mergedElement.setMetaProperty('ref-fields', {\n      $ref: toValue(referencingElement.$ref),\n      // @ts-ignore\n      description: toValue(referencingElement.description),\n      // @ts-ignore\n      summary: toValue(referencingElement.summary)\n    });\n    // annotate fragment with info about origin\n    mergedElement.setMetaProperty('ref-origin', reference.uri);\n    // annotate fragment with info about referencing element\n    mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n    if ((_this$options$derefer0 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer0 !== void 0 && _this$options$derefer0.continueOnError) {\n      mergedElement.setMetaProperty('ref-referencing-element', referencingElement);\n    }\n\n    // override description and summary (outer has higher priority then inner)\n    if (isObjectElement(referencedElement) && isObjectElement(mergedElement)) {\n      if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n        mergedElement.remove('description');\n        mergedElement.set('description', referencingElement.get('description'));\n      }\n      if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n        mergedElement.remove('summary');\n        mergedElement.set('summary', referencingElement.get('summary'));\n      }\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(mergedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? mergedElement : false;\n  }\n  async PathItemElement(referencingElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer11;\n    // ignore PathItemElement without $ref field\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    let reference;\n    try {\n      reference = await this.toReference(toValue(referencingElement.$ref));\n    } catch (error) {\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n    let referencedElement;\n    try {\n      // possibly non-semantic referenced element\n      referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n    } catch (error) {\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    /**\n     * Applying semantics to a referenced element if semantics are missing.\n     */\n    if (isPrimitiveElement(referencedElement)) {\n      const cacheKey = \"path-item-\".concat(toValue(identityManager.identify(referencedElement)));\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else {\n        referencedElement = PathItemElement.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      const error = new ApiDOMError('Recursive Path Item Object reference detected');\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      const error = new MaximumDereferenceDepthError(\"Maximum dereference depth of \\\"\".concat(this.options.dereference.maxDepth, \"\\\" has been exceeded in file \\\"\").concat(this.reference.uri, \"\\\"\"));\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        const error = new ApiDOMError('Circular reference detected');\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n      if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer1, _this$options$derefer10;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'path-item',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer1 = (_this$options$derefer10 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer10 === void 0 ? void 0 : _this$options$derefer10.circularReplacer) !== null && _this$options$derefer1 !== void 0 ? _this$options$derefer1 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular || (_this$options$derefer11 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer11 !== void 0 && _this$options$derefer11.continueOnError) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.getNestedVisitorOptions(referencingElement),\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      try {\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n      } catch (error) {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n     */\n    if (isPathItemElement(referencedElement)) {\n      var _this$options$derefer12;\n      const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing PathItemElement overrides ones from referenced element\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      if ((_this$options$derefer12 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer12 !== void 0 && _this$options$derefer12.continueOnError) {\n        mergedElement.setMetaProperty('ref-referencing-element', referencingElement);\n      }\n      referencedElement = mergedElement;\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n  async LinkElement(linkElement, key, parent, path, ancestors, link) {\n    // ignore LinkElement without operationRef or operationId field\n    if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {\n      return undefined;\n    }\n\n    // operationRef and operationId fields are mutually exclusive\n    if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {\n      const error = new ApiDOMError('LinkElement operationRef and operationId fields are mutually exclusive.');\n      return this.handleDereferenceError(error, linkElement);\n    }\n    let operationElement;\n    if (isStringElement(linkElement.operationRef)) {\n      var _linkElementCopy$oper;\n      // possibly non-semantic referenced element\n      const jsonPointer = URIFragmentIdentifier.fromURIReference(toValue(linkElement.operationRef));\n      const retrievalURI = this.toBaseURI(toValue(linkElement.operationRef));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Operation Object reference\n      if (!this.options.resolve.internal && isInternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      // ignore resolving external Operation Object reference\n      if (!this.options.resolve.external && isExternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      let reference;\n      try {\n        reference = await this.toReference(toValue(linkElement.operationRef));\n        operationElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      } catch (error) {\n        return this.handleDereferenceError(error, linkElement);\n      }\n\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(operationElement)) {\n        const cacheKey = \"operation-\".concat(toValue(identityManager.identify(operationElement)));\n        if (this.refractCache.has(cacheKey)) {\n          operationElement = this.refractCache.get(cacheKey);\n        } else {\n          operationElement = OperationElement.refract(operationElement);\n          this.refractCache.set(cacheKey, operationElement);\n        }\n      }\n      // create shallow clone to be able to annotate with metadata\n      operationElement = cloneShallow(operationElement);\n      // annotate operation element with info about origin\n      operationElement.setMetaProperty('ref-origin', reference.uri);\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    if (isStringElement(linkElement.operationId)) {\n      var _linkElementCopy$oper2;\n      const operationId = toValue(linkElement.operationId);\n      let reference;\n      try {\n        reference = await this.toReference(url.unsanitize(this.reference.uri));\n      } catch (error) {\n        return this.handleDereferenceError(error, linkElement);\n      }\n      operationElement = find(e => isOperationElement(e) && isElement(e.operationId) && e.operationId.equals(operationId), reference.value.result);\n      // OperationElement not found by its operationId\n      if (isUndefined(operationElement)) {\n        const error = new ApiDOMError(\"OperationElement(operationId=\".concat(operationId, \") not found.\"));\n        return this.handleDereferenceError(error, linkElement);\n      }\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    // ignore ExampleElement without externalValue field\n    if (!isStringElement(exampleElement.externalValue)) {\n      return undefined;\n    }\n\n    // value and externalValue fields are mutually exclusive\n    if (exampleElement.hasKey('value') && isStringElement(exampleElement.externalValue)) {\n      const error = new ApiDOMError('ExampleElement value and externalValue fields are mutually exclusive.');\n      return this.handleDereferenceError(error, exampleElement);\n    }\n    const retrievalURI = this.toBaseURI(toValue(exampleElement.externalValue));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Example Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Example Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    let reference;\n    try {\n      reference = await this.toReference(toValue(exampleElement.externalValue));\n    } catch (error) {\n      return this.handleDereferenceError(error, exampleElement);\n    }\n\n    // shallow clone of the referenced element\n    const valueElement = cloneShallow(reference.value.result);\n    // annotate operation element with info about origin\n    valueElement.setMetaProperty('ref-origin', reference.uri);\n    const exampleElementCopy = cloneShallow(exampleElement);\n    exampleElementCopy.value = valueElement;\n\n    /**\n     * Transclude Example Object containing external value.\n     */\n    link.replaceWith(exampleElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? exampleElementCopy : undefined;\n  }\n  async MemberElement(memberElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer13;\n    const parentElement = ancestors[ancestors.length - 1];\n\n    // skip current MemberElement if its parent is not a DiscriminatorElement\n    if (!isObjectElement(parentElement) || !parentElement.classes.contains('discriminator-mapping')) {\n      return undefined;\n    }\n\n    // skip current MemberElement if discriminator mapping dereferencing option is not enabled\n    if (!((_this$options$derefer13 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer13 !== void 0 && _this$options$derefer13.dereferenceDiscriminatorMapping)) {\n      return false;\n    }\n\n    // skip current MemberElement if its key or value is not a StringElement\n    if (!isStringElement(memberElement.key) || !isStringElement(memberElement.value)) {\n      return false;\n    }\n\n    // skip current referencing MemberElement as it's already been accessed\n    if (this.indirections.includes(memberElement)) {\n      return false;\n    }\n    this.indirections.push(memberElement);\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const parentSchemaElement = [...directAncestors].findLast(isSchemaElement);\n    const ancestorsSchemaIdentifiers = cloneDeep(parentSchemaElement.getMetaProperty('ancestorsSchemaIdentifiers'));\n\n    // get the reference from the MemberElement value\n    const memberElementValue = toValue(memberElement.value);\n    const namePattern = /^[a-zA-Z0-9\\\\.\\\\-_]+$/;\n    const memberElementRef = namePattern.test(memberElementValue) ? \"#/components/schemas/\".concat(memberElementValue) : memberElementValue;\n\n    // create SchemaElement with the reference from the MemberElement value\n    const schemaElement = new SchemaElement({\n      $ref: memberElementRef\n    });\n    schemaElement.setMetaProperty('ancestorsSchemaIdentifiers', ancestorsSchemaIdentifiers);\n\n    // append referencing reference to ancestors lineage\n    directAncestors.add(schemaElement);\n    const visitor = new OpenAPI3_1DereferenceVisitor({\n      reference: this.reference,\n      namespace: this.namespace,\n      indirections: [...this.indirections],\n      options: this.getNestedVisitorOptions(schemaElement),\n      refractCache: this.refractCache,\n      ancestors: ancestorsLineage,\n      allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n    });\n    let referencedElement;\n    try {\n      referencedElement = await visitAsync(schemaElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n    } catch (error) {\n      return this.handleDereferenceError(error, schemaElement, directAncestors);\n    }\n\n    // remove referencing reference from ancestors lineage\n    directAncestors.delete(schemaElement);\n    this.indirections.pop();\n\n    // annotate MemberElement with referenced schema\n    const memberElementCopy = cloneShallow(memberElement);\n    memberElementCopy.value.setMetaProperty('ref-schema', referencedElement);\n\n    /**\n     * Transclude MemberElement containing referenced schema in its meta.\n     */\n    link.replaceWith(memberElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? memberElementCopy : undefined;\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer16;\n    // skip current referencing schema as $ref keyword was not defined\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n    // compute baseURI using rules around $id and $ref keywords\n    let reference;\n    try {\n      reference = await this.toReference(url.unsanitize(this.reference.uri));\n    } catch (error) {\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    let {\n      uri: retrievalURI\n    } = reference;\n    const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n    const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n    const file = new File({\n      uri: $refBaseURIStrippedHash\n    });\n    const isUnknownURI = none(r => r.canRead(file), this.options.resolve.resolvers);\n    const isURL = !isUnknownURI;\n    let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n    let isExternalReference = !isInternalReference;\n    this.indirections.push(referencingElement);\n\n    // determining reference, proper evaluation and selection mechanism\n    let referencedElement;\n    try {\n      if (isUnknownURI || isURL) {\n        // we're dealing with canonical URI or URL with possible fragment\n        retrievalURI = this.toBaseURI($refBaseURI);\n        const selector = $refBaseURI;\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = uriEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n      } else {\n        // we're assuming here that we're dealing with JSON Pointer here\n        retrievalURI = this.toBaseURI($refBaseURI);\n        isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n        isExternalReference = !isInternalReference;\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        reference = await this.toReference(url.unsanitize($refBaseURI));\n        const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n      }\n    } catch (error) {\n      /**\n       * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n       * the URL and assume the returned response is a JSON Schema.\n       */\n      if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n        if (isAnchor(uriToAnchor($refBaseURI))) {\n          // we're dealing with JSON Schema $anchor here\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          try {\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n          } catch (toReferenceError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(toReferenceError, referencingElement, directAncestors);\n          }\n          const selector = uriToAnchor($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          try {\n            referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n          } catch (evaluateError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(evaluateError, referencingElement, directAncestors);\n          }\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          try {\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n          } catch (toReferenceError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(toReferenceError, referencingElement, directAncestors);\n          }\n          const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          try {\n            referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n          } catch (evaluateError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(evaluateError, referencingElement, directAncestors);\n          }\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } else {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      const error = new ApiDOMError('Recursive Schema Object reference detected');\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      const error = new MaximumDereferenceDepthError(\"Maximum dereference depth of \\\"\".concat(this.options.dereference.maxDepth, \"\\\" has been exceeded in file \\\"\").concat(this.reference.uri, \"\\\"\"));\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        const error = new ApiDOMError('Circular reference detected');\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n      if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer14, _this$options$derefer15;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'json-schema',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer14 = (_this$options$derefer15 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer15 === void 0 ? void 0 : _this$options$derefer15.circularReplacer) !== null && _this$options$derefer14 !== void 0 ? _this$options$derefer14 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular || (_this$options$derefer16 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer16 !== void 0 && _this$options$derefer16.continueOnError) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.getNestedVisitorOptions(referencingElement),\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      try {\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n      } catch (error) {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    // Boolean JSON Schemas\n    if (isBooleanJsonSchemaElement(referencedElement)) {\n      const booleanJsonSchemaElement = cloneDeep(referencedElement);\n      // assign unique id to merged element\n      booleanJsonSchemaElement.setMetaProperty('id', identityManager.generateId());\n      // annotate referenced element with info about original referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        $refBaseURI\n      });\n      // annotate referenced element with info about origin\n      booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n      return !parent ? booleanJsonSchemaElement : false;\n    }\n\n    /**\n     * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n     */\n    if (isSchemaElement(referencedElement)) {\n      var _this$options$derefer17, _this$options$derefer18;\n      const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing schema overrides ones from referenced schema\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        $refBaseURI\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      if ((_this$options$derefer17 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer17 !== void 0 && _this$options$derefer17.continueOnError) {\n        mergedElement.setMetaProperty('ref-referencing-element', referencingElement);\n      }\n\n      // creating mapping for allOf discriminator\n      if ((_this$options$derefer18 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer18 !== void 0 && _this$options$derefer18.dereferenceDiscriminatorMapping) {\n        var _parentElement$classe;\n        const parentElement = ancestors[ancestors.length - 1];\n        const parentSchemaElement = [...directAncestors].findLast(isSchemaElement);\n        const parentSchemaElementName = parentSchemaElement === null || parentSchemaElement === void 0 ? void 0 : parentSchemaElement.getMetaProperty('schemaName');\n        const mergedElementName = toValue(mergedElement.getMetaProperty('schemaName'));\n        if (mergedElementName && parentSchemaElementName &&\n        // @ts-ignore\n        parentElement !== null && parentElement !== void 0 && (_parentElement$classe = parentElement.classes) !== null && _parentElement$classe !== void 0 && _parentElement$classe.contains('json-schema-allOf')) {\n          var _this$allOfDiscrimina;\n          const currentMapping = (_this$allOfDiscrimina = this.allOfDiscriminatorMapping.get(mergedElementName)) !== null && _this$allOfDiscrimina !== void 0 ? _this$allOfDiscrimina : [];\n          currentMapping.push(parentSchemaElement);\n          this.allOfDiscriminatorMapping.set(mergedElementName, currentMapping);\n        }\n      }\n      referencedElement = mergedElement;\n    }\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n}\nexport default OpenAPI3_1DereferenceVisitor;","map":{"version":3,"names":["propEq","none","isUndefined","isElement","isPrimitiveElement","isStringElement","isMemberElement","isObjectElement","IdentityManager","visit","find","cloneShallow","cloneDeep","toValue","RefElement","ApiDOMError","evaluate","jsonPointerEvaluate","URIFragmentIdentifier","getNodeType","isReferenceLikeElement","keyMap","ReferenceElement","PathItemElement","OperationElement","SchemaElement","isPathItemElement","isReferenceElement","isSchemaElement","isOperationElement","isBooleanJsonSchemaElement","isAnchor","uriToAnchor","$anchorEvaluate","uriEvaluate","MaximumDereferenceDepthError","MaximumResolveDepthError","url","parse","Reference","File","resolveSchema$refField","maybeRefractToSchemaElement","AncestorLineage","EvaluationJsonSchemaUriError","visitAsync","Symbol","for","identityManager","mutationReplacer","newElement","oldElement","key","parent","value","Array","isArray","OpenAPI3_1DereferenceVisitor","constructor","_ref","reference","namespace","options","indirections","ancestors","refractCache","Map","allOfDiscriminatorMapping","_defineProperty","leave","openApi3_1Element","path","link","_this$options$derefer6","dereference","strategyOpts","dereferenceDiscriminatorMapping","undefined","openApi3_1ElementCopy","setMetaProperty","Object","fromEntries","replaceWith","handleDereferenceError","error","refEl","directAncestors","_this$options$derefer","dereferenceOpts","continueOnError","_this$options$derefer3","ancestorWithRef","ancestor","getMetaProperty","_this$options$derefer2","errors","push","getNestedVisitorOptions","referencingElement","_this$options$derefer4","_this$options$derefer5","_objectSpread","resolve","external","skipNestedExternal","get","startsWith","toBaseURI","uri","sanitize","stripHash","toReference","depth","maxDepth","concat","baseURI","refSet","has","parseResult","unsanitize","mediaType","mutableReference","add","immutable","immutableReference","toAncestorLineage","Set","filter","ancestorsLineage","_this$options$derefer9","_this$options$derefer0","includes","retrievalURI","$ref","isInternalReference","isExternalReference","internal","$refBaseURI","jsonPointer","fromURIReference","referencedElement","result","pop","id","identify","referencedElementType","meta","cacheKey","refract","set","ElementClass","getElementClass","length","circular","_this$options$derefer7","_this$options$derefer8","refElement","type","replacer","circularReplacer","replacement","isNonRootDocument","rootRef","shouldDetectCircular","includesCycle","visitor","nodeTypeGetter","delete","mergedElement","generateId","description","summary","hasKey","remove","_this$options$derefer11","_this$options$derefer1","_this$options$derefer10","_this$options$derefer12","content","attributes","forEach","keyElement","item","LinkElement","linkElement","operationRef","operationId","operationElement","_linkElementCopy$oper","linkElementCopy","_linkElementCopy$oper2","e","equals","ExampleElement","exampleElement","externalValue","valueElement","exampleElementCopy","MemberElement","memberElement","_this$options$derefer13","parentElement","classes","contains","parentSchemaElement","findLast","ancestorsSchemaIdentifiers","memberElementValue","namePattern","memberElementRef","test","schemaElement","memberElementCopy","_this$options$derefer16","$refBaseURIStrippedHash","file","isUnknownURI","r","canRead","resolvers","isURL","selector","referenceAsSchema","toReferenceError","evaluateError","_this$options$derefer14","_this$options$derefer15","booleanJsonSchemaElement","_this$options$derefer17","_this$options$derefer18","_parentElement$classe","parentSchemaElementName","mergedElementName","_this$allOfDiscrimina","currentMapping"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/visitor.mjs"],"sourcesContent":["import { propEq, none } from 'ramda';\nimport { isUndefined } from 'ramda-adjunct';\nimport { isElement, isPrimitiveElement, isStringElement, isMemberElement, isObjectElement, IdentityManager, visit, find, cloneShallow, cloneDeep, toValue, RefElement } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { evaluate as jsonPointerEvaluate, URIFragmentIdentifier } from '@swagger-api/apidom-json-pointer/modern';\nimport { getNodeType, isReferenceLikeElement, keyMap, ReferenceElement, PathItemElement, OperationElement, SchemaElement, isPathItemElement, isReferenceElement, isSchemaElement, isOperationElement, isBooleanJsonSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from \"./selectors/$anchor.mjs\";\nimport { evaluate as uriEvaluate } from \"./selectors/uri.mjs\";\nimport MaximumDereferenceDepthError from \"../../../errors/MaximumDereferenceDepthError.mjs\";\nimport MaximumResolveDepthError from \"../../../errors/MaximumResolveDepthError.mjs\";\nimport * as url from \"../../../util/url.mjs\";\nimport parse from \"../../../parse/index.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport File from \"../../../File.mjs\";\nimport { resolveSchema$refField, maybeRefractToSchemaElement } from \"./util.mjs\";\nimport { AncestorLineage } from \"../../util.mjs\";\nimport EvaluationJsonSchemaUriError from \"../../../errors/EvaluationJsonSchemaUriError.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n/**\n * Custom mutation replacer.\n * @public\n */\nexport const mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass OpenAPI3_1DereferenceVisitor {\n  indirections;\n  namespace;\n  reference;\n  options;\n  ancestors;\n  refractCache;\n  allOfDiscriminatorMapping;\n  constructor({\n    reference,\n    namespace,\n    options,\n    indirections = [],\n    ancestors = new AncestorLineage(),\n    refractCache = new Map(),\n    allOfDiscriminatorMapping = new Map()\n  }) {\n    this.indirections = indirections;\n    this.namespace = namespace;\n    this.reference = reference;\n    this.options = options;\n    this.ancestors = new AncestorLineage(...ancestors);\n    this.refractCache = refractCache;\n    this.allOfDiscriminatorMapping = allOfDiscriminatorMapping;\n  }\n  handleDereferenceError(error, refEl, directAncestors) {\n    var _this$options$derefer;\n    if ((_this$options$derefer = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer !== void 0 && _this$options$derefer.continueOnError) {\n      var _this$options$derefer3;\n      if (directAncestors) {\n        const ancestorWithRef = [...directAncestors].find(ancestor => isObjectElement(ancestor) && ancestor.getMetaProperty('ref-referencing-element'));\n        if (ancestorWithRef) {\n          var _this$options$derefer2;\n          (_this$options$derefer2 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.errors.push({\n            error,\n            refEl: ancestorWithRef.getMetaProperty('ref-referencing-element')\n          });\n        }\n      }\n      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || _this$options$derefer3.errors.push({\n        error,\n        refEl\n      });\n      return undefined;\n    }\n    throw error;\n  }\n  getNestedVisitorOptions(referencingElement) {\n    var _this$options$derefer4, _this$options$derefer5;\n    return {\n      ...this.options,\n      resolve: {\n        ...this.options.resolve,\n        external: (_this$options$derefer4 = this.options.dereference) !== null && _this$options$derefer4 !== void 0 && (_this$options$derefer4 = _this$options$derefer4.dereferenceOpts) !== null && _this$options$derefer4 !== void 0 && _this$options$derefer4.skipNestedExternal && toValue(referencingElement.get('$ref')).startsWith('#') ? false : this.options.resolve.external\n      },\n      dereference: {\n        ...this.options.dereference,\n        dereferenceOpts: {\n          ...((_this$options$derefer5 = this.options.dereference) === null || _this$options$derefer5 === void 0 ? void 0 : _this$options$derefer5.dereferenceOpts),\n          continueOnError: false\n        }\n      }\n    };\n  }\n  toBaseURI(uri) {\n    return url.resolve(this.reference.uri, url.sanitize(url.stripHash(uri)));\n  }\n  async toReference(uri) {\n    // detect maximum depth of resolution\n    if (this.reference.depth >= this.options.resolve.maxDepth) {\n      throw new MaximumResolveDepthError(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file \"${this.reference.uri}\"`);\n    }\n    const baseURI = this.toBaseURI(uri);\n    const {\n      refSet\n    } = this.reference;\n\n    // we've already processed this Reference in past\n    if (refSet.has(baseURI)) {\n      return refSet.find(propEq(baseURI, 'uri'));\n    }\n    const parseResult = await parse(url.unsanitize(baseURI), {\n      ...this.options,\n      parse: {\n        ...this.options.parse,\n        mediaType: 'text/plain'\n      }\n    });\n\n    // register new mutable reference with a refSet\n    const mutableReference = new Reference({\n      uri: baseURI,\n      value: cloneDeep(parseResult),\n      depth: this.reference.depth + 1\n    });\n    refSet.add(mutableReference);\n    if (this.options.dereference.immutable) {\n      // register new immutable reference with a refSet\n      const immutableReference = new Reference({\n        uri: `immutable://${baseURI}`,\n        value: parseResult,\n        depth: this.reference.depth + 1\n      });\n      refSet.add(immutableReference);\n    }\n    return mutableReference;\n  }\n  toAncestorLineage(ancestors) {\n    /**\n     * Compute full ancestors lineage.\n     * Ancestors are flatten to unwrap all Element instances.\n     */\n    const directAncestors = new Set(ancestors.filter(isElement));\n    const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);\n    return [ancestorsLineage, directAncestors];\n  }\n  OpenApi3_1Element = {\n    leave: (openApi3_1Element, key, parent, path, ancestors, link) => {\n      var _this$options$derefer6;\n      if (!((_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer6 !== void 0 && _this$options$derefer6.dereferenceDiscriminatorMapping)) {\n        return undefined;\n      }\n      const openApi3_1ElementCopy = cloneShallow(openApi3_1Element);\n      openApi3_1ElementCopy.setMetaProperty('allOfDiscriminatorMapping', Object.fromEntries(this.allOfDiscriminatorMapping));\n      link.replaceWith(openApi3_1ElementCopy, mutationReplacer);\n      return !parent ? openApi3_1ElementCopy : undefined;\n    }\n  };\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer9, _this$options$derefer0;\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Reference Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    // ignore resolving external Reference Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    let reference;\n    try {\n      reference = await this.toReference(toValue(referencingElement.$ref));\n    } catch (error) {\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n    let referencedElement;\n    try {\n      // possibly non-semantic fragment\n      referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n    } catch (error) {\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    // applying semantics to a fragment\n    if (isPrimitiveElement(referencedElement)) {\n      const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n      const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else if (isReferenceLikeElement(referencedElement)) {\n        // handling indirect references\n        referencedElement = ReferenceElement.refract(referencedElement);\n        referencedElement.setMetaProperty('referenced-element', referencedElementType);\n        this.refractCache.set(cacheKey, referencedElement);\n      } else {\n        // handling direct references\n        const ElementClass = this.namespace.getElementClass(referencedElementType);\n        referencedElement = ElementClass.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      const error = new ApiDOMError('Recursive Reference Object detected');\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      const error = new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        const error = new ApiDOMError('Circular reference detected');\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n      if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer7, _this$options$derefer8;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'reference',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer7 = (_this$options$derefer8 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer8 === void 0 ? void 0 : _this$options$derefer8.circularReplacer) !== null && _this$options$derefer7 !== void 0 ? _this$options$derefer7 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular || (_this$options$derefer9 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer9 !== void 0 && _this$options$derefer9.continueOnError) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.getNestedVisitorOptions(referencingElement),\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      try {\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n      } catch (error) {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of referenced element to avoid modifying the original one.\n     */\n    const mergedElement = cloneShallow(referencedElement);\n    // assign unique id to merged element\n    mergedElement.setMetaProperty('id', identityManager.generateId());\n    // annotate fragment with info about original Reference element\n    mergedElement.setMetaProperty('ref-fields', {\n      $ref: toValue(referencingElement.$ref),\n      // @ts-ignore\n      description: toValue(referencingElement.description),\n      // @ts-ignore\n      summary: toValue(referencingElement.summary)\n    });\n    // annotate fragment with info about origin\n    mergedElement.setMetaProperty('ref-origin', reference.uri);\n    // annotate fragment with info about referencing element\n    mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n    if ((_this$options$derefer0 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer0 !== void 0 && _this$options$derefer0.continueOnError) {\n      mergedElement.setMetaProperty('ref-referencing-element', referencingElement);\n    }\n\n    // override description and summary (outer has higher priority then inner)\n    if (isObjectElement(referencedElement) && isObjectElement(mergedElement)) {\n      if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n        mergedElement.remove('description');\n        mergedElement.set('description', referencingElement.get('description'));\n      }\n      if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n        mergedElement.remove('summary');\n        mergedElement.set('summary', referencingElement.get('summary'));\n      }\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(mergedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? mergedElement : false;\n  }\n  async PathItemElement(referencingElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer11;\n    // ignore PathItemElement without $ref field\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    let reference;\n    try {\n      reference = await this.toReference(toValue(referencingElement.$ref));\n    } catch (error) {\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n    let referencedElement;\n    try {\n      // possibly non-semantic referenced element\n      referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n    } catch (error) {\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    /**\n     * Applying semantics to a referenced element if semantics are missing.\n     */\n    if (isPrimitiveElement(referencedElement)) {\n      const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else {\n        referencedElement = PathItemElement.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      const error = new ApiDOMError('Recursive Path Item Object reference detected');\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      const error = new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        const error = new ApiDOMError('Circular reference detected');\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n      if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer1, _this$options$derefer10;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'path-item',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer1 = (_this$options$derefer10 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer10 === void 0 ? void 0 : _this$options$derefer10.circularReplacer) !== null && _this$options$derefer1 !== void 0 ? _this$options$derefer1 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular || (_this$options$derefer11 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer11 !== void 0 && _this$options$derefer11.continueOnError) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.getNestedVisitorOptions(referencingElement),\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      try {\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n      } catch (error) {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n     */\n    if (isPathItemElement(referencedElement)) {\n      var _this$options$derefer12;\n      const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing PathItemElement overrides ones from referenced element\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      if ((_this$options$derefer12 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer12 !== void 0 && _this$options$derefer12.continueOnError) {\n        mergedElement.setMetaProperty('ref-referencing-element', referencingElement);\n      }\n      referencedElement = mergedElement;\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n  async LinkElement(linkElement, key, parent, path, ancestors, link) {\n    // ignore LinkElement without operationRef or operationId field\n    if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {\n      return undefined;\n    }\n\n    // operationRef and operationId fields are mutually exclusive\n    if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {\n      const error = new ApiDOMError('LinkElement operationRef and operationId fields are mutually exclusive.');\n      return this.handleDereferenceError(error, linkElement);\n    }\n    let operationElement;\n    if (isStringElement(linkElement.operationRef)) {\n      var _linkElementCopy$oper;\n      // possibly non-semantic referenced element\n      const jsonPointer = URIFragmentIdentifier.fromURIReference(toValue(linkElement.operationRef));\n      const retrievalURI = this.toBaseURI(toValue(linkElement.operationRef));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Operation Object reference\n      if (!this.options.resolve.internal && isInternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      // ignore resolving external Operation Object reference\n      if (!this.options.resolve.external && isExternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      let reference;\n      try {\n        reference = await this.toReference(toValue(linkElement.operationRef));\n        operationElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      } catch (error) {\n        return this.handleDereferenceError(error, linkElement);\n      }\n\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(operationElement)) {\n        const cacheKey = `operation-${toValue(identityManager.identify(operationElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          operationElement = this.refractCache.get(cacheKey);\n        } else {\n          operationElement = OperationElement.refract(operationElement);\n          this.refractCache.set(cacheKey, operationElement);\n        }\n      }\n      // create shallow clone to be able to annotate with metadata\n      operationElement = cloneShallow(operationElement);\n      // annotate operation element with info about origin\n      operationElement.setMetaProperty('ref-origin', reference.uri);\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    if (isStringElement(linkElement.operationId)) {\n      var _linkElementCopy$oper2;\n      const operationId = toValue(linkElement.operationId);\n      let reference;\n      try {\n        reference = await this.toReference(url.unsanitize(this.reference.uri));\n      } catch (error) {\n        return this.handleDereferenceError(error, linkElement);\n      }\n      operationElement = find(e => isOperationElement(e) && isElement(e.operationId) && e.operationId.equals(operationId), reference.value.result);\n      // OperationElement not found by its operationId\n      if (isUndefined(operationElement)) {\n        const error = new ApiDOMError(`OperationElement(operationId=${operationId}) not found.`);\n        return this.handleDereferenceError(error, linkElement);\n      }\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    // ignore ExampleElement without externalValue field\n    if (!isStringElement(exampleElement.externalValue)) {\n      return undefined;\n    }\n\n    // value and externalValue fields are mutually exclusive\n    if (exampleElement.hasKey('value') && isStringElement(exampleElement.externalValue)) {\n      const error = new ApiDOMError('ExampleElement value and externalValue fields are mutually exclusive.');\n      return this.handleDereferenceError(error, exampleElement);\n    }\n    const retrievalURI = this.toBaseURI(toValue(exampleElement.externalValue));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Example Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Example Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    let reference;\n    try {\n      reference = await this.toReference(toValue(exampleElement.externalValue));\n    } catch (error) {\n      return this.handleDereferenceError(error, exampleElement);\n    }\n\n    // shallow clone of the referenced element\n    const valueElement = cloneShallow(reference.value.result);\n    // annotate operation element with info about origin\n    valueElement.setMetaProperty('ref-origin', reference.uri);\n    const exampleElementCopy = cloneShallow(exampleElement);\n    exampleElementCopy.value = valueElement;\n\n    /**\n     * Transclude Example Object containing external value.\n     */\n    link.replaceWith(exampleElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? exampleElementCopy : undefined;\n  }\n  async MemberElement(memberElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer13;\n    const parentElement = ancestors[ancestors.length - 1];\n\n    // skip current MemberElement if its parent is not a DiscriminatorElement\n    if (!isObjectElement(parentElement) || !parentElement.classes.contains('discriminator-mapping')) {\n      return undefined;\n    }\n\n    // skip current MemberElement if discriminator mapping dereferencing option is not enabled\n    if (!((_this$options$derefer13 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer13 !== void 0 && _this$options$derefer13.dereferenceDiscriminatorMapping)) {\n      return false;\n    }\n\n    // skip current MemberElement if its key or value is not a StringElement\n    if (!isStringElement(memberElement.key) || !isStringElement(memberElement.value)) {\n      return false;\n    }\n\n    // skip current referencing MemberElement as it's already been accessed\n    if (this.indirections.includes(memberElement)) {\n      return false;\n    }\n    this.indirections.push(memberElement);\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const parentSchemaElement = [...directAncestors].findLast(isSchemaElement);\n    const ancestorsSchemaIdentifiers = cloneDeep(parentSchemaElement.getMetaProperty('ancestorsSchemaIdentifiers'));\n\n    // get the reference from the MemberElement value\n    const memberElementValue = toValue(memberElement.value);\n    const namePattern = /^[a-zA-Z0-9\\\\.\\\\-_]+$/;\n    const memberElementRef = namePattern.test(memberElementValue) ? `#/components/schemas/${memberElementValue}` : memberElementValue;\n\n    // create SchemaElement with the reference from the MemberElement value\n    const schemaElement = new SchemaElement({\n      $ref: memberElementRef\n    });\n    schemaElement.setMetaProperty('ancestorsSchemaIdentifiers', ancestorsSchemaIdentifiers);\n\n    // append referencing reference to ancestors lineage\n    directAncestors.add(schemaElement);\n    const visitor = new OpenAPI3_1DereferenceVisitor({\n      reference: this.reference,\n      namespace: this.namespace,\n      indirections: [...this.indirections],\n      options: this.getNestedVisitorOptions(schemaElement),\n      refractCache: this.refractCache,\n      ancestors: ancestorsLineage,\n      allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n    });\n    let referencedElement;\n    try {\n      referencedElement = await visitAsync(schemaElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n    } catch (error) {\n      return this.handleDereferenceError(error, schemaElement, directAncestors);\n    }\n\n    // remove referencing reference from ancestors lineage\n    directAncestors.delete(schemaElement);\n    this.indirections.pop();\n\n    // annotate MemberElement with referenced schema\n    const memberElementCopy = cloneShallow(memberElement);\n    memberElementCopy.value.setMetaProperty('ref-schema', referencedElement);\n\n    /**\n     * Transclude MemberElement containing referenced schema in its meta.\n     */\n    link.replaceWith(memberElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? memberElementCopy : undefined;\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer16;\n    // skip current referencing schema as $ref keyword was not defined\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n    // compute baseURI using rules around $id and $ref keywords\n    let reference;\n    try {\n      reference = await this.toReference(url.unsanitize(this.reference.uri));\n    } catch (error) {\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n    let {\n      uri: retrievalURI\n    } = reference;\n    const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n    const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n    const file = new File({\n      uri: $refBaseURIStrippedHash\n    });\n    const isUnknownURI = none(r => r.canRead(file), this.options.resolve.resolvers);\n    const isURL = !isUnknownURI;\n    let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n    let isExternalReference = !isInternalReference;\n    this.indirections.push(referencingElement);\n\n    // determining reference, proper evaluation and selection mechanism\n    let referencedElement;\n    try {\n      if (isUnknownURI || isURL) {\n        // we're dealing with canonical URI or URL with possible fragment\n        retrievalURI = this.toBaseURI($refBaseURI);\n        const selector = $refBaseURI;\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = uriEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n      } else {\n        // we're assuming here that we're dealing with JSON Pointer here\n        retrievalURI = this.toBaseURI($refBaseURI);\n        isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n        isExternalReference = !isInternalReference;\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        reference = await this.toReference(url.unsanitize($refBaseURI));\n        const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n      }\n    } catch (error) {\n      /**\n       * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n       * the URL and assume the returned response is a JSON Schema.\n       */\n      if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n        if (isAnchor(uriToAnchor($refBaseURI))) {\n          // we're dealing with JSON Schema $anchor here\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          try {\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n          } catch (toReferenceError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(toReferenceError, referencingElement, directAncestors);\n          }\n          const selector = uriToAnchor($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          try {\n            referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n          } catch (evaluateError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(evaluateError, referencingElement, directAncestors);\n          }\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          try {\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n          } catch (toReferenceError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(toReferenceError, referencingElement, directAncestors);\n          }\n          const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          try {\n            referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n          } catch (evaluateError) {\n            this.indirections.pop();\n            return this.handleDereferenceError(evaluateError, referencingElement, directAncestors);\n          }\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } else {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      const error = new ApiDOMError('Recursive Schema Object reference detected');\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      const error = new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      this.indirections.pop();\n      return this.handleDereferenceError(error, referencingElement, directAncestors);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        const error = new ApiDOMError('Circular reference detected');\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n      if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer14, _this$options$derefer15;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'json-schema',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer14 = (_this$options$derefer15 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer15 === void 0 ? void 0 : _this$options$derefer15.circularReplacer) !== null && _this$options$derefer14 !== void 0 ? _this$options$derefer14 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular || (_this$options$derefer16 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer16 !== void 0 && _this$options$derefer16.continueOnError) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.getNestedVisitorOptions(referencingElement),\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      try {\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n      } catch (error) {\n        this.indirections.pop();\n        return this.handleDereferenceError(error, referencingElement, directAncestors);\n      }\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    // Boolean JSON Schemas\n    if (isBooleanJsonSchemaElement(referencedElement)) {\n      const booleanJsonSchemaElement = cloneDeep(referencedElement);\n      // assign unique id to merged element\n      booleanJsonSchemaElement.setMetaProperty('id', identityManager.generateId());\n      // annotate referenced element with info about original referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        $refBaseURI\n      });\n      // annotate referenced element with info about origin\n      booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n      return !parent ? booleanJsonSchemaElement : false;\n    }\n\n    /**\n     * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n     */\n    if (isSchemaElement(referencedElement)) {\n      var _this$options$derefer17, _this$options$derefer18;\n      const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing schema overrides ones from referenced schema\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        $refBaseURI\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      if ((_this$options$derefer17 = this.options.dereference.dereferenceOpts) !== null && _this$options$derefer17 !== void 0 && _this$options$derefer17.continueOnError) {\n        mergedElement.setMetaProperty('ref-referencing-element', referencingElement);\n      }\n\n      // creating mapping for allOf discriminator\n      if ((_this$options$derefer18 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer18 !== void 0 && _this$options$derefer18.dereferenceDiscriminatorMapping) {\n        var _parentElement$classe;\n        const parentElement = ancestors[ancestors.length - 1];\n        const parentSchemaElement = [...directAncestors].findLast(isSchemaElement);\n        const parentSchemaElementName = parentSchemaElement === null || parentSchemaElement === void 0 ? void 0 : parentSchemaElement.getMetaProperty('schemaName');\n        const mergedElementName = toValue(mergedElement.getMetaProperty('schemaName'));\n        if (mergedElementName && parentSchemaElementName && // @ts-ignore\n        parentElement !== null && parentElement !== void 0 && (_parentElement$classe = parentElement.classes) !== null && _parentElement$classe !== void 0 && _parentElement$classe.contains('json-schema-allOf')) {\n          var _this$allOfDiscrimina;\n          const currentMapping = (_this$allOfDiscrimina = this.allOfDiscriminatorMapping.get(mergedElementName)) !== null && _this$allOfDiscrimina !== void 0 ? _this$allOfDiscrimina : [];\n          currentMapping.push(parentSchemaElement);\n          this.allOfDiscriminatorMapping.set(mergedElementName, currentMapping);\n        }\n      }\n      referencedElement = mergedElement;\n    }\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n}\nexport default OpenAPI3_1DereferenceVisitor;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}