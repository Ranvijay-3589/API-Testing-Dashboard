{"ast":null,"code":"import parse from \"../parse/index.mjs\";\n/**\n * Implementation of https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.3\n */\nconst significantTypes = ['slash', 'path-literal', 'template-expression'];\nconst pathSegmentNormalizer = pathTemplate => {\n  const parseResult = parse(pathTemplate);\n  if (!parseResult.result.success) return pathTemplate;\n  const parts = [];\n  const stack = [];\n  parseResult.ast.translate(parts);\n  for (let i = 0; i < parts.length; i += 1) {\n    let [type, value] = parts[i];\n\n    // remove `template-expression-param-name` and treat `template-expression` as `path-literal`\n    if (type === 'template-expression-param-name') {\n      continue; // skip this segment\n    }\n    if (type === 'path-literal' || type === 'template-expression') {\n      if (value === '.') continue; // ignore '.' segments\n\n      if (value === '..') {\n        // handle '..' segments\n        if (stack.length > 1) {\n          let last = stack.pop(); // remove preceding segment\n          if (last[0] === 'slash' && stack.length > 0) {\n            stack.pop(); // remove preceding slash if present\n          }\n        }\n        continue; // move to the next segment\n      }\n      stack.push([type, value]); // push valid path-literals\n    } else if (type === 'slash') {\n      var _stack;\n      // only add slash if the last item on the stack is not a slash\n      if (((_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack[0]) !== 'slash') {\n        stack.push([type, value]);\n      }\n    } else {\n      stack.push([type, value]); // preserve all other types\n    }\n  }\n  const normalizedPathTemplate = stack.reduce((pathTemplateNormalized, _ref) => {\n    let [type, value] = _ref;\n    if (significantTypes.includes(type)) {\n      return \"\".concat(pathTemplateNormalized).concat(value);\n    }\n    return pathTemplateNormalized;\n  }, '');\n\n  // makes sure the root path is represented as '/'\n  return normalizedPathTemplate === '' ? '/' : normalizedPathTemplate;\n};\nexport default pathSegmentNormalizer;","map":{"version":3,"names":["parse","significantTypes","pathSegmentNormalizer","pathTemplate","parseResult","result","success","parts","stack","ast","translate","i","length","type","value","last","pop","push","_stack","normalizedPathTemplate","reduce","pathTemplateNormalized","_ref","includes","concat"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/openapi-path-templating/es/normalization/path-segment.mjs"],"sourcesContent":["import parse from \"../parse/index.mjs\";\n/**\n * Implementation of https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.3\n */\nconst significantTypes = ['slash', 'path-literal', 'template-expression'];\nconst pathSegmentNormalizer = pathTemplate => {\n  const parseResult = parse(pathTemplate);\n  if (!parseResult.result.success) return pathTemplate;\n  const parts = [];\n  const stack = [];\n  parseResult.ast.translate(parts);\n  for (let i = 0; i < parts.length; i += 1) {\n    let [type, value] = parts[i];\n\n    // remove `template-expression-param-name` and treat `template-expression` as `path-literal`\n    if (type === 'template-expression-param-name') {\n      continue; // skip this segment\n    }\n    if (type === 'path-literal' || type === 'template-expression') {\n      if (value === '.') continue; // ignore '.' segments\n\n      if (value === '..') {\n        // handle '..' segments\n        if (stack.length > 1) {\n          let last = stack.pop(); // remove preceding segment\n          if (last[0] === 'slash' && stack.length > 0) {\n            stack.pop(); // remove preceding slash if present\n          }\n        }\n        continue; // move to the next segment\n      }\n      stack.push([type, value]); // push valid path-literals\n    } else if (type === 'slash') {\n      var _stack;\n      // only add slash if the last item on the stack is not a slash\n      if (((_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack[0]) !== 'slash') {\n        stack.push([type, value]);\n      }\n    } else {\n      stack.push([type, value]); // preserve all other types\n    }\n  }\n  const normalizedPathTemplate = stack.reduce((pathTemplateNormalized, [type, value]) => {\n    if (significantTypes.includes(type)) {\n      return `${pathTemplateNormalized}${value}`;\n    }\n    return pathTemplateNormalized;\n  }, '');\n\n  // makes sure the root path is represented as '/'\n  return normalizedPathTemplate === '' ? '/' : normalizedPathTemplate;\n};\nexport default pathSegmentNormalizer;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,oBAAoB;AACtC;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC,OAAO,EAAE,cAAc,EAAE,qBAAqB,CAAC;AACzE,MAAMC,qBAAqB,GAAGC,YAAY,IAAI;EAC5C,MAAMC,WAAW,GAAGJ,KAAK,CAACG,YAAY,CAAC;EACvC,IAAI,CAACC,WAAW,CAACC,MAAM,CAACC,OAAO,EAAE,OAAOH,YAAY;EACpD,MAAMI,KAAK,GAAG,EAAE;EAChB,MAAMC,KAAK,GAAG,EAAE;EAChBJ,WAAW,CAACK,GAAG,CAACC,SAAS,CAACH,KAAK,CAAC;EAChC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACxC,IAAI,CAACE,IAAI,EAAEC,KAAK,CAAC,GAAGP,KAAK,CAACI,CAAC,CAAC;;IAE5B;IACA,IAAIE,IAAI,KAAK,gCAAgC,EAAE;MAC7C,SAAS,CAAC;IACZ;IACA,IAAIA,IAAI,KAAK,cAAc,IAAIA,IAAI,KAAK,qBAAqB,EAAE;MAC7D,IAAIC,KAAK,KAAK,GAAG,EAAE,SAAS,CAAC;;MAE7B,IAAIA,KAAK,KAAK,IAAI,EAAE;QAClB;QACA,IAAIN,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;UACpB,IAAIG,IAAI,GAAGP,KAAK,CAACQ,GAAG,CAAC,CAAC,CAAC,CAAC;UACxB,IAAID,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIP,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;YAC3CJ,KAAK,CAACQ,GAAG,CAAC,CAAC,CAAC,CAAC;UACf;QACF;QACA,SAAS,CAAC;MACZ;MACAR,KAAK,CAACS,IAAI,CAAC,CAACJ,IAAI,EAAEC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC7B,CAAC,MAAM,IAAID,IAAI,KAAK,OAAO,EAAE;MAC3B,IAAIK,MAAM;MACV;MACA,IAAI,CAAC,CAACA,MAAM,GAAGV,KAAK,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,MAAM,IAAI,IAAIM,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,MAAM,OAAO,EAAE;QACvGV,KAAK,CAACS,IAAI,CAAC,CAACJ,IAAI,EAAEC,KAAK,CAAC,CAAC;MAC3B;IACF,CAAC,MAAM;MACLN,KAAK,CAACS,IAAI,CAAC,CAACJ,IAAI,EAAEC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC7B;EACF;EACA,MAAMK,sBAAsB,GAAGX,KAAK,CAACY,MAAM,CAAC,CAACC,sBAAsB,EAAAC,IAAA,KAAoB;IAAA,IAAlB,CAACT,IAAI,EAAEC,KAAK,CAAC,GAAAQ,IAAA;IAChF,IAAIrB,gBAAgB,CAACsB,QAAQ,CAACV,IAAI,CAAC,EAAE;MACnC,UAAAW,MAAA,CAAUH,sBAAsB,EAAAG,MAAA,CAAGV,KAAK;IAC1C;IACA,OAAOO,sBAAsB;EAC/B,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,OAAOF,sBAAsB,KAAK,EAAE,GAAG,GAAG,GAAGA,sBAAsB;AACrE,CAAC;AACD,eAAejB,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}