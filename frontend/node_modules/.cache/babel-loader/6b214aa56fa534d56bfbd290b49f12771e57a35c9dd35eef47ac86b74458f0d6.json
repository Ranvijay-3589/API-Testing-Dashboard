{"ast":null,"code":"import _objectSpread from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport lib from './lib/index.js';\nimport refs from './lib/refs.js';\nimport allOf from './lib/all-of.js';\nimport parameters from './lib/parameters.js';\nimport properties from './lib/properties.js';\nimport ContextTree from './lib/context-tree.js';\nimport { TRAVERSE_LIMIT } from '../../constants.js';\nconst PLUGIN_DISPATCH_LIMIT = 100;\nconst noop = () => {};\nclass SpecMap {\n  static getPluginName(plugin) {\n    return plugin.pluginName;\n  }\n  static getPatchesOfType(patches, fn) {\n    return patches.filter(fn);\n  }\n  constructor(opts) {\n    Object.assign(this, {\n      spec: '',\n      debugLevel: 'info',\n      plugins: [],\n      pluginHistory: {},\n      errors: [],\n      mutations: [],\n      promisedPatches: [],\n      state: {},\n      patches: [],\n      context: {},\n      contextTree: new ContextTree(),\n      showDebug: false,\n      allPatches: [],\n      // only populated if showDebug is true\n      pluginProp: 'specMap',\n      libMethods: Object.assign(Object.create(this), lib, {\n        getInstance: () => this\n      }),\n      allowMetaPatches: false\n    }, opts);\n\n    // Lib methods bound\n    this.get = this._get.bind(this); // eslint-disable-line no-underscore-dangle\n    this.getContext = this._getContext.bind(this); // eslint-disable-line no-underscore-dangle\n    this.hasRun = this._hasRun.bind(this); // eslint-disable-line no-underscore-dangle\n\n    this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib.isFunction);\n\n    // Initial patch(s)\n    this.patches.push(lib.add([], this.spec));\n    this.patches.push(lib.context([], this.context));\n    this.updatePatches(this.patches);\n  }\n  debug(level) {\n    if (this.debugLevel === level) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      console.log(...args); // eslint-disable-line no-console\n    }\n  }\n  verbose(header) {\n    if (this.debugLevel === 'verbose') {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      console.log(\"[\".concat(header, \"]   \"), ...args); // eslint-disable-line no-console\n    }\n  }\n  wrapPlugin(plugin, name) {\n    const {\n      pathDiscriminator\n    } = this;\n    let ctx = null;\n    let fn;\n    if (plugin[this.pluginProp]) {\n      ctx = plugin;\n      fn = plugin[this.pluginProp];\n    } else if (lib.isFunction(plugin)) {\n      fn = plugin;\n    } else if (lib.isObject(plugin)) {\n      fn = createKeyBasedPlugin(plugin);\n    }\n    return Object.assign(fn.bind(ctx), {\n      pluginName: plugin.name || name,\n      isGenerator: lib.isGenerator(fn)\n    });\n\n    // Expected plugin interface: {key: string, plugin: fn*}\n    // This traverses depth-first and immediately applies yielded patches.\n    // This strategy should work well for most plugins (including the built-ins).\n    // We might consider making this (traversing & application) configurable later.\n    function createKeyBasedPlugin(pluginObj) {\n      const isSubPath = (path, tested) => {\n        if (!Array.isArray(path)) {\n          return true;\n        }\n        return path.every((val, i) => val === tested[i]);\n      };\n      return function* generator(patches, specmap) {\n        const refCache = {};\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const [i, patch] of patches.filter(lib.isAdditiveMutation).entries()) {\n          if (i < TRAVERSE_LIMIT) {\n            yield* traverse(patch.value, patch.path, patch);\n          } else {\n            return;\n          }\n        }\n        function* traverse(obj, path, patch) {\n          if (!lib.isObject(obj)) {\n            if (pluginObj.key === path[path.length - 1]) {\n              yield pluginObj.plugin(obj, pluginObj.key, path, specmap);\n            }\n          } else {\n            const parentIndex = path.length - 1;\n            const parent = path[parentIndex];\n            const indexOfFirstProperties = path.indexOf('properties');\n            const isRootProperties = parent === 'properties' && parentIndex === indexOfFirstProperties;\n            const traversed = specmap.allowMetaPatches && refCache[obj.$$ref];\n\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key of Object.keys(obj)) {\n              const val = obj[key];\n              const updatedPath = path.concat(key);\n              const isObj = lib.isObject(val);\n              const objRef = obj.$$ref;\n              if (!traversed) {\n                if (isObj) {\n                  // Only store the ref if it exists\n                  if (specmap.allowMetaPatches && objRef && isSubPath(pathDiscriminator, updatedPath)) {\n                    refCache[objRef] = true;\n                  }\n                  yield* traverse(val, updatedPath, patch);\n                }\n              }\n              if (!isRootProperties && key === pluginObj.key) {\n                const isWithinPathDiscriminator = isSubPath(pathDiscriminator, path);\n                if (!pathDiscriminator || isWithinPathDiscriminator) {\n                  yield pluginObj.plugin(val, key, updatedPath, specmap, patch);\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n  }\n  nextPlugin() {\n    return this.wrappedPlugins.find(plugin => {\n      const mutations = this.getMutationsForPlugin(plugin);\n      return mutations.length > 0;\n    });\n  }\n  nextPromisedPatch() {\n    if (this.promisedPatches.length > 0) {\n      return Promise.race(this.promisedPatches.map(patch => patch.value));\n    }\n    return undefined;\n  }\n  getPluginHistory(plugin) {\n    const name = this.constructor.getPluginName(plugin);\n    return this.pluginHistory[name] || [];\n  }\n  getPluginRunCount(plugin) {\n    return this.getPluginHistory(plugin).length;\n  }\n  getPluginHistoryTip(plugin) {\n    const history = this.getPluginHistory(plugin);\n    const val = history && history[history.length - 1];\n    return val || {};\n  }\n  getPluginMutationIndex(plugin) {\n    const mi = this.getPluginHistoryTip(plugin).mutationIndex;\n    return typeof mi !== 'number' ? -1 : mi;\n  }\n  updatePluginHistory(plugin, val) {\n    const name = this.constructor.getPluginName(plugin);\n    this.pluginHistory[name] = this.pluginHistory[name] || [];\n    this.pluginHistory[name].push(val);\n  }\n  updatePatches(patches) {\n    lib.normalizeArray(patches).forEach(patch => {\n      if (patch instanceof Error) {\n        this.errors.push(patch);\n        return;\n      }\n      try {\n        if (!lib.isObject(patch)) {\n          this.debug('updatePatches', 'Got a non-object patch', patch);\n          return;\n        }\n        if (this.showDebug) {\n          this.allPatches.push(patch);\n        }\n        if (lib.isPromise(patch.value)) {\n          this.promisedPatches.push(patch);\n          this.promisedPatchThen(patch);\n          return;\n        }\n        if (lib.isContextPatch(patch)) {\n          this.setContext(patch.path, patch.value);\n          return;\n        }\n        if (lib.isMutation(patch)) {\n          this.updateMutations(patch);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        this.errors.push(e);\n      }\n    });\n  }\n  updateMutations(patch) {\n    if (typeof patch.value === 'object' && !Array.isArray(patch.value) && this.allowMetaPatches) {\n      patch.value = _objectSpread({}, patch.value);\n    }\n    const result = lib.applyPatch(this.state, patch, {\n      allowMetaPatches: this.allowMetaPatches\n    });\n    if (result) {\n      this.mutations.push(patch);\n      this.state = result;\n    }\n  }\n  removePromisedPatch(patch) {\n    const index = this.promisedPatches.indexOf(patch);\n    if (index < 0) {\n      this.debug(\"Tried to remove a promisedPatch that isn't there!\");\n      return;\n    }\n    this.promisedPatches.splice(index, 1);\n  }\n  promisedPatchThen(patch) {\n    patch.value = patch.value.then(val => {\n      const promisedPatch = _objectSpread(_objectSpread({}, patch), {}, {\n        value: val\n      });\n      this.removePromisedPatch(patch);\n      this.updatePatches(promisedPatch);\n    }).catch(e => {\n      this.removePromisedPatch(patch);\n      this.updatePatches(e);\n    });\n    return patch.value;\n  }\n  getMutations(from, to) {\n    from = from || 0;\n    if (typeof to !== 'number') {\n      to = this.mutations.length;\n    }\n    return this.mutations.slice(from, to);\n  }\n  getCurrentMutations() {\n    return this.getMutationsForPlugin(this.getCurrentPlugin());\n  }\n  getMutationsForPlugin(plugin) {\n    const tip = this.getPluginMutationIndex(plugin);\n    return this.getMutations(tip + 1);\n  }\n  getCurrentPlugin() {\n    return this.currentPlugin;\n  }\n  getLib() {\n    return this.libMethods;\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _get(path) {\n    return lib.getIn(this.state, path);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _getContext(path) {\n    return this.contextTree.get(path);\n  }\n  setContext(path, value) {\n    return this.contextTree.set(path, value);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _hasRun(count) {\n    const times = this.getPluginRunCount(this.getCurrentPlugin());\n    return times > (count || 0);\n  }\n  dispatch() {\n    const that = this;\n    const plugin = this.nextPlugin();\n    if (!plugin) {\n      const nextPromise = this.nextPromisedPatch();\n      if (nextPromise) {\n        return nextPromise.then(() => this.dispatch()).catch(() => this.dispatch());\n      }\n\n      // We're done!\n      const result = {\n        spec: this.state,\n        errors: this.errors\n      };\n      if (this.showDebug) {\n        result.patches = this.allPatches;\n      }\n      return Promise.resolve(result);\n    }\n\n    // Makes sure plugin isn't running an endless loop\n    that.pluginCount = that.pluginCount || new WeakMap();\n    that.pluginCount.set(plugin, (that.pluginCount.get(plugin) || 0) + 1);\n    if (that.pluginCount[plugin] > PLUGIN_DISPATCH_LIMIT) {\n      return Promise.resolve({\n        spec: that.state,\n        errors: that.errors.concat(new Error(\"We've reached a hard limit of \".concat(PLUGIN_DISPATCH_LIMIT, \" plugin runs\")))\n      });\n    }\n\n    // A different plugin runs, wait for all promises to resolve, then retry\n    if (plugin !== this.currentPlugin && this.promisedPatches.length) {\n      const promises = this.promisedPatches.map(p => p.value);\n\n      // Waits for all to settle instead of Promise.all which stops on rejection\n      return Promise.all(promises.map(promise => promise.then(noop, noop))).then(() => this.dispatch());\n    }\n\n    // Ok, run the plugin\n    return executePlugin();\n    function executePlugin() {\n      that.currentPlugin = plugin;\n      const mutations = that.getCurrentMutations();\n      const lastMutationIndex = that.mutations.length - 1;\n      try {\n        if (plugin.isGenerator) {\n          // eslint-disable-next-line no-restricted-syntax\n          for (const yieldedPatches of plugin(mutations, that.getLib())) {\n            updatePatches(yieldedPatches);\n          }\n        } else {\n          const newPatches = plugin(mutations, that.getLib());\n          updatePatches(newPatches);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        updatePatches([Object.assign(Object.create(e), {\n          plugin\n        })]);\n      } finally {\n        that.updatePluginHistory(plugin, {\n          mutationIndex: lastMutationIndex\n        });\n      }\n      return that.dispatch();\n    }\n    function updatePatches(patches) {\n      if (patches) {\n        patches = lib.fullyNormalizeArray(patches);\n        that.updatePatches(patches, plugin);\n      }\n    }\n  }\n}\nexport default function mapSpec(opts) {\n  return new SpecMap(opts).dispatch();\n}\nconst plugins = {\n  refs,\n  allOf,\n  parameters,\n  properties\n};\nexport { SpecMap, plugins };","map":{"version":3,"names":["lib","refs","allOf","parameters","properties","ContextTree","TRAVERSE_LIMIT","PLUGIN_DISPATCH_LIMIT","noop","SpecMap","getPluginName","plugin","pluginName","getPatchesOfType","patches","fn","filter","constructor","opts","Object","assign","spec","debugLevel","plugins","pluginHistory","errors","mutations","promisedPatches","state","context","contextTree","showDebug","allPatches","pluginProp","libMethods","create","getInstance","allowMetaPatches","get","_get","bind","getContext","_getContext","hasRun","_hasRun","wrappedPlugins","map","wrapPlugin","isFunction","push","add","updatePatches","debug","level","_len","arguments","length","args","Array","_key","console","log","verbose","header","_len2","_key2","concat","name","pathDiscriminator","ctx","isObject","createKeyBasedPlugin","isGenerator","pluginObj","isSubPath","path","tested","isArray","every","val","i","generator","specmap","refCache","patch","isAdditiveMutation","entries","traverse","value","obj","key","parentIndex","parent","indexOfFirstProperties","indexOf","isRootProperties","traversed","$$ref","keys","updatedPath","isObj","objRef","isWithinPathDiscriminator","nextPlugin","find","getMutationsForPlugin","nextPromisedPatch","Promise","race","undefined","getPluginHistory","getPluginRunCount","getPluginHistoryTip","history","getPluginMutationIndex","mi","mutationIndex","updatePluginHistory","normalizeArray","forEach","Error","isPromise","promisedPatchThen","isContextPatch","setContext","isMutation","updateMutations","e","error","_objectSpread","result","applyPatch","removePromisedPatch","index","splice","then","promisedPatch","catch","getMutations","from","to","slice","getCurrentMutations","getCurrentPlugin","tip","currentPlugin","getLib","getIn","set","count","times","dispatch","that","nextPromise","resolve","pluginCount","WeakMap","promises","p","all","promise","executePlugin","lastMutationIndex","yieldedPatches","newPatches","fullyNormalizeArray","mapSpec"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/swagger-client/es/resolver/specmap/index.js"],"sourcesContent":["import lib from './lib/index.js';\nimport refs from './lib/refs.js';\nimport allOf from './lib/all-of.js';\nimport parameters from './lib/parameters.js';\nimport properties from './lib/properties.js';\nimport ContextTree from './lib/context-tree.js';\nimport { TRAVERSE_LIMIT } from '../../constants.js';\nconst PLUGIN_DISPATCH_LIMIT = 100;\nconst noop = () => {};\nclass SpecMap {\n  static getPluginName(plugin) {\n    return plugin.pluginName;\n  }\n  static getPatchesOfType(patches, fn) {\n    return patches.filter(fn);\n  }\n  constructor(opts) {\n    Object.assign(this, {\n      spec: '',\n      debugLevel: 'info',\n      plugins: [],\n      pluginHistory: {},\n      errors: [],\n      mutations: [],\n      promisedPatches: [],\n      state: {},\n      patches: [],\n      context: {},\n      contextTree: new ContextTree(),\n      showDebug: false,\n      allPatches: [],\n      // only populated if showDebug is true\n      pluginProp: 'specMap',\n      libMethods: Object.assign(Object.create(this), lib, {\n        getInstance: () => this\n      }),\n      allowMetaPatches: false\n    }, opts);\n\n    // Lib methods bound\n    this.get = this._get.bind(this); // eslint-disable-line no-underscore-dangle\n    this.getContext = this._getContext.bind(this); // eslint-disable-line no-underscore-dangle\n    this.hasRun = this._hasRun.bind(this); // eslint-disable-line no-underscore-dangle\n\n    this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib.isFunction);\n\n    // Initial patch(s)\n    this.patches.push(lib.add([], this.spec));\n    this.patches.push(lib.context([], this.context));\n    this.updatePatches(this.patches);\n  }\n  debug(level, ...args) {\n    if (this.debugLevel === level) {\n      console.log(...args); // eslint-disable-line no-console\n    }\n  }\n  verbose(header, ...args) {\n    if (this.debugLevel === 'verbose') {\n      console.log(`[${header}]   `, ...args); // eslint-disable-line no-console\n    }\n  }\n  wrapPlugin(plugin, name) {\n    const {\n      pathDiscriminator\n    } = this;\n    let ctx = null;\n    let fn;\n    if (plugin[this.pluginProp]) {\n      ctx = plugin;\n      fn = plugin[this.pluginProp];\n    } else if (lib.isFunction(plugin)) {\n      fn = plugin;\n    } else if (lib.isObject(plugin)) {\n      fn = createKeyBasedPlugin(plugin);\n    }\n    return Object.assign(fn.bind(ctx), {\n      pluginName: plugin.name || name,\n      isGenerator: lib.isGenerator(fn)\n    });\n\n    // Expected plugin interface: {key: string, plugin: fn*}\n    // This traverses depth-first and immediately applies yielded patches.\n    // This strategy should work well for most plugins (including the built-ins).\n    // We might consider making this (traversing & application) configurable later.\n    function createKeyBasedPlugin(pluginObj) {\n      const isSubPath = (path, tested) => {\n        if (!Array.isArray(path)) {\n          return true;\n        }\n        return path.every((val, i) => val === tested[i]);\n      };\n      return function* generator(patches, specmap) {\n        const refCache = {};\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const [i, patch] of patches.filter(lib.isAdditiveMutation).entries()) {\n          if (i < TRAVERSE_LIMIT) {\n            yield* traverse(patch.value, patch.path, patch);\n          } else {\n            return;\n          }\n        }\n        function* traverse(obj, path, patch) {\n          if (!lib.isObject(obj)) {\n            if (pluginObj.key === path[path.length - 1]) {\n              yield pluginObj.plugin(obj, pluginObj.key, path, specmap);\n            }\n          } else {\n            const parentIndex = path.length - 1;\n            const parent = path[parentIndex];\n            const indexOfFirstProperties = path.indexOf('properties');\n            const isRootProperties = parent === 'properties' && parentIndex === indexOfFirstProperties;\n            const traversed = specmap.allowMetaPatches && refCache[obj.$$ref];\n\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key of Object.keys(obj)) {\n              const val = obj[key];\n              const updatedPath = path.concat(key);\n              const isObj = lib.isObject(val);\n              const objRef = obj.$$ref;\n              if (!traversed) {\n                if (isObj) {\n                  // Only store the ref if it exists\n                  if (specmap.allowMetaPatches && objRef && isSubPath(pathDiscriminator, updatedPath)) {\n                    refCache[objRef] = true;\n                  }\n                  yield* traverse(val, updatedPath, patch);\n                }\n              }\n              if (!isRootProperties && key === pluginObj.key) {\n                const isWithinPathDiscriminator = isSubPath(pathDiscriminator, path);\n                if (!pathDiscriminator || isWithinPathDiscriminator) {\n                  yield pluginObj.plugin(val, key, updatedPath, specmap, patch);\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n  }\n  nextPlugin() {\n    return this.wrappedPlugins.find(plugin => {\n      const mutations = this.getMutationsForPlugin(plugin);\n      return mutations.length > 0;\n    });\n  }\n  nextPromisedPatch() {\n    if (this.promisedPatches.length > 0) {\n      return Promise.race(this.promisedPatches.map(patch => patch.value));\n    }\n    return undefined;\n  }\n  getPluginHistory(plugin) {\n    const name = this.constructor.getPluginName(plugin);\n    return this.pluginHistory[name] || [];\n  }\n  getPluginRunCount(plugin) {\n    return this.getPluginHistory(plugin).length;\n  }\n  getPluginHistoryTip(plugin) {\n    const history = this.getPluginHistory(plugin);\n    const val = history && history[history.length - 1];\n    return val || {};\n  }\n  getPluginMutationIndex(plugin) {\n    const mi = this.getPluginHistoryTip(plugin).mutationIndex;\n    return typeof mi !== 'number' ? -1 : mi;\n  }\n  updatePluginHistory(plugin, val) {\n    const name = this.constructor.getPluginName(plugin);\n    this.pluginHistory[name] = this.pluginHistory[name] || [];\n    this.pluginHistory[name].push(val);\n  }\n  updatePatches(patches) {\n    lib.normalizeArray(patches).forEach(patch => {\n      if (patch instanceof Error) {\n        this.errors.push(patch);\n        return;\n      }\n      try {\n        if (!lib.isObject(patch)) {\n          this.debug('updatePatches', 'Got a non-object patch', patch);\n          return;\n        }\n        if (this.showDebug) {\n          this.allPatches.push(patch);\n        }\n        if (lib.isPromise(patch.value)) {\n          this.promisedPatches.push(patch);\n          this.promisedPatchThen(patch);\n          return;\n        }\n        if (lib.isContextPatch(patch)) {\n          this.setContext(patch.path, patch.value);\n          return;\n        }\n        if (lib.isMutation(patch)) {\n          this.updateMutations(patch);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        this.errors.push(e);\n      }\n    });\n  }\n  updateMutations(patch) {\n    if (typeof patch.value === 'object' && !Array.isArray(patch.value) && this.allowMetaPatches) {\n      patch.value = {\n        ...patch.value\n      };\n    }\n    const result = lib.applyPatch(this.state, patch, {\n      allowMetaPatches: this.allowMetaPatches\n    });\n    if (result) {\n      this.mutations.push(patch);\n      this.state = result;\n    }\n  }\n  removePromisedPatch(patch) {\n    const index = this.promisedPatches.indexOf(patch);\n    if (index < 0) {\n      this.debug(\"Tried to remove a promisedPatch that isn't there!\");\n      return;\n    }\n    this.promisedPatches.splice(index, 1);\n  }\n  promisedPatchThen(patch) {\n    patch.value = patch.value.then(val => {\n      const promisedPatch = {\n        ...patch,\n        value: val\n      };\n      this.removePromisedPatch(patch);\n      this.updatePatches(promisedPatch);\n    }).catch(e => {\n      this.removePromisedPatch(patch);\n      this.updatePatches(e);\n    });\n    return patch.value;\n  }\n  getMutations(from, to) {\n    from = from || 0;\n    if (typeof to !== 'number') {\n      to = this.mutations.length;\n    }\n    return this.mutations.slice(from, to);\n  }\n  getCurrentMutations() {\n    return this.getMutationsForPlugin(this.getCurrentPlugin());\n  }\n  getMutationsForPlugin(plugin) {\n    const tip = this.getPluginMutationIndex(plugin);\n    return this.getMutations(tip + 1);\n  }\n  getCurrentPlugin() {\n    return this.currentPlugin;\n  }\n  getLib() {\n    return this.libMethods;\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _get(path) {\n    return lib.getIn(this.state, path);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _getContext(path) {\n    return this.contextTree.get(path);\n  }\n  setContext(path, value) {\n    return this.contextTree.set(path, value);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _hasRun(count) {\n    const times = this.getPluginRunCount(this.getCurrentPlugin());\n    return times > (count || 0);\n  }\n  dispatch() {\n    const that = this;\n    const plugin = this.nextPlugin();\n    if (!plugin) {\n      const nextPromise = this.nextPromisedPatch();\n      if (nextPromise) {\n        return nextPromise.then(() => this.dispatch()).catch(() => this.dispatch());\n      }\n\n      // We're done!\n      const result = {\n        spec: this.state,\n        errors: this.errors\n      };\n      if (this.showDebug) {\n        result.patches = this.allPatches;\n      }\n      return Promise.resolve(result);\n    }\n\n    // Makes sure plugin isn't running an endless loop\n    that.pluginCount = that.pluginCount || new WeakMap();\n    that.pluginCount.set(plugin, (that.pluginCount.get(plugin) || 0) + 1);\n    if (that.pluginCount[plugin] > PLUGIN_DISPATCH_LIMIT) {\n      return Promise.resolve({\n        spec: that.state,\n        errors: that.errors.concat(new Error(`We've reached a hard limit of ${PLUGIN_DISPATCH_LIMIT} plugin runs`))\n      });\n    }\n\n    // A different plugin runs, wait for all promises to resolve, then retry\n    if (plugin !== this.currentPlugin && this.promisedPatches.length) {\n      const promises = this.promisedPatches.map(p => p.value);\n\n      // Waits for all to settle instead of Promise.all which stops on rejection\n      return Promise.all(promises.map(promise => promise.then(noop, noop))).then(() => this.dispatch());\n    }\n\n    // Ok, run the plugin\n    return executePlugin();\n    function executePlugin() {\n      that.currentPlugin = plugin;\n      const mutations = that.getCurrentMutations();\n      const lastMutationIndex = that.mutations.length - 1;\n      try {\n        if (plugin.isGenerator) {\n          // eslint-disable-next-line no-restricted-syntax\n          for (const yieldedPatches of plugin(mutations, that.getLib())) {\n            updatePatches(yieldedPatches);\n          }\n        } else {\n          const newPatches = plugin(mutations, that.getLib());\n          updatePatches(newPatches);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        updatePatches([Object.assign(Object.create(e), {\n          plugin\n        })]);\n      } finally {\n        that.updatePluginHistory(plugin, {\n          mutationIndex: lastMutationIndex\n        });\n      }\n      return that.dispatch();\n    }\n    function updatePatches(patches) {\n      if (patches) {\n        patches = lib.fullyNormalizeArray(patches);\n        that.updatePatches(patches, plugin);\n      }\n    }\n  }\n}\nexport default function mapSpec(opts) {\n  return new SpecMap(opts).dispatch();\n}\nconst plugins = {\n  refs,\n  allOf,\n  parameters,\n  properties\n};\nexport { SpecMap, plugins };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}