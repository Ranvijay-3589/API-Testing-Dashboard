{"ast":null,"code":"import _objectSpread from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"keyMap\"],\n  _excluded2 = [\"keyMap\"];\nimport { F as stubFalse, pipe } from 'ramda';\nimport { isString } from 'ramda-adjunct';\nimport { visit as astVisit, BREAK, mergeAllVisitors, cloneNode as cloneNodeDefault } from '@swagger-api/apidom-ast';\nimport { isElement, isMemberElement, isArrayElement, isStringElement, isBooleanElement, isLinkElement, isRefElement, isObjectElement, isNullElement, isNumberElement } from \"../predicates/index.mjs\";\nimport { cloneShallow } from \"../clone/index.mjs\";\nexport { BREAK, mergeAllVisitors };\n\n/**\n * @public\n */\nexport const getNodeType = element => {\n  /*\n   * We're translating every possible higher element type to primitive minim type here.\n   * We're using polymorphism to recognize any higher element type as ObjectElement or ArrayElement.\n   * Using polymorphism allows us to assume any namespace.\n   *\n   * There is a problem with naming visitor methods described here: https://github.com/babel/babel/discussions/12874\n   */\n  return isObjectElement(element) ? 'ObjectElement' : isArrayElement(element) ? 'ArrayElement' : isMemberElement(element) ? 'MemberElement' : isStringElement(element) ? 'StringElement' : isBooleanElement(element) ? 'BooleanElement' : isNumberElement(element) ? 'NumberElement' : isNullElement(element) ? 'NullElement' : isLinkElement(element) ? 'LinkElement' : isRefElement(element) ? 'RefElement' : undefined;\n};\n\n/**\n * @public\n */\nexport const cloneNode = node => {\n  if (isElement(node)) {\n    return cloneShallow(node);\n  }\n  return cloneNodeDefault(node);\n};\n\n// isNode :: Node -> Boolean\nexport const isNode = pipe(getNodeType, isString);\n\n/**\n * @public\n */\nexport const keyMapDefault = {\n  ObjectElement: ['content'],\n  ArrayElement: ['content'],\n  MemberElement: ['key', 'value'],\n  StringElement: [],\n  BooleanElement: [],\n  NumberElement: [],\n  NullElement: [],\n  RefElement: [],\n  LinkElement: [],\n  Annotation: [],\n  Comment: [],\n  ParseResultElement: ['content']\n};\nexport class PredicateVisitor {\n  constructor() {\n    let {\n      predicate = stubFalse,\n      returnOnTrue,\n      returnOnFalse\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"result\", void 0);\n    _defineProperty(this, \"predicate\", void 0);\n    _defineProperty(this, \"returnOnTrue\", void 0);\n    _defineProperty(this, \"returnOnFalse\", void 0);\n    this.result = [];\n    this.predicate = predicate;\n    this.returnOnTrue = returnOnTrue;\n    this.returnOnFalse = returnOnFalse;\n  }\n  enter(element) {\n    if (this.predicate(element)) {\n      this.result.push(element);\n      return this.returnOnTrue;\n    }\n    return this.returnOnFalse;\n  }\n}\n\n/**\n * @public\n */\nexport const visit = function (root,\n// @ts-ignore\nvisitor) {\n  let _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    {\n      keyMap = keyMapDefault\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  // @ts-ignore\n  return astVisit(root, visitor, _objectSpread({\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode\n  }, rest));\n};\n\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async function (root,\n// @ts-ignore\nvisitor) {\n  let _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    {\n      keyMap = keyMapDefault\n    } = _ref2,\n    rest = _objectWithoutProperties(_ref2, _excluded2);\n  // @ts-ignore\n  return astVisit[Symbol.for('nodejs.util.promisify.custom')](root, visitor, _objectSpread({\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode\n  }, rest));\n};","map":{"version":3,"names":["F","stubFalse","pipe","isString","visit","astVisit","BREAK","mergeAllVisitors","cloneNode","cloneNodeDefault","isElement","isMemberElement","isArrayElement","isStringElement","isBooleanElement","isLinkElement","isRefElement","isObjectElement","isNullElement","isNumberElement","cloneShallow","getNodeType","element","undefined","node","isNode","keyMapDefault","ObjectElement","ArrayElement","MemberElement","StringElement","BooleanElement","NumberElement","NullElement","RefElement","LinkElement","Annotation","Comment","ParseResultElement","PredicateVisitor","constructor","predicate","returnOnTrue","returnOnFalse","arguments","length","_defineProperty","result","enter","push","root","visitor","_ref","keyMap","rest","_objectWithoutProperties","_excluded","_objectSpread","nodeTypeGetter","nodePredicate","nodeCloneFn","Symbol","for","_ref2","_excluded2"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-core/src/traversal/visitor.mjs"],"sourcesContent":["import { F as stubFalse, pipe } from 'ramda';\nimport { isString } from 'ramda-adjunct';\nimport { visit as astVisit, BREAK, mergeAllVisitors, cloneNode as cloneNodeDefault } from '@swagger-api/apidom-ast';\nimport { isElement, isMemberElement, isArrayElement, isStringElement, isBooleanElement, isLinkElement, isRefElement, isObjectElement, isNullElement, isNumberElement } from \"../predicates/index.mjs\";\nimport { cloneShallow } from \"../clone/index.mjs\";\nexport { BREAK, mergeAllVisitors };\n\n/**\n * @public\n */\nexport const getNodeType = element => {\n  /*\n   * We're translating every possible higher element type to primitive minim type here.\n   * We're using polymorphism to recognize any higher element type as ObjectElement or ArrayElement.\n   * Using polymorphism allows us to assume any namespace.\n   *\n   * There is a problem with naming visitor methods described here: https://github.com/babel/babel/discussions/12874\n   */\n  return isObjectElement(element) ? 'ObjectElement' : isArrayElement(element) ? 'ArrayElement' : isMemberElement(element) ? 'MemberElement' : isStringElement(element) ? 'StringElement' : isBooleanElement(element) ? 'BooleanElement' : isNumberElement(element) ? 'NumberElement' : isNullElement(element) ? 'NullElement' : isLinkElement(element) ? 'LinkElement' : isRefElement(element) ? 'RefElement' : undefined;\n};\n\n/**\n * @public\n */\nexport const cloneNode = node => {\n  if (isElement(node)) {\n    return cloneShallow(node);\n  }\n  return cloneNodeDefault(node);\n};\n\n// isNode :: Node -> Boolean\nexport const isNode = pipe(getNodeType, isString);\n\n/**\n * @public\n */\nexport const keyMapDefault = {\n  ObjectElement: ['content'],\n  ArrayElement: ['content'],\n  MemberElement: ['key', 'value'],\n  StringElement: [],\n  BooleanElement: [],\n  NumberElement: [],\n  NullElement: [],\n  RefElement: [],\n  LinkElement: [],\n  Annotation: [],\n  Comment: [],\n  ParseResultElement: ['content']\n};\nexport class PredicateVisitor {\n  result;\n  predicate;\n  returnOnTrue;\n  returnOnFalse;\n  constructor({\n    predicate = stubFalse,\n    returnOnTrue,\n    returnOnFalse\n  } = {}) {\n    this.result = [];\n    this.predicate = predicate;\n    this.returnOnTrue = returnOnTrue;\n    this.returnOnFalse = returnOnFalse;\n  }\n  enter(element) {\n    if (this.predicate(element)) {\n      this.result.push(element);\n      return this.returnOnTrue;\n    }\n    return this.returnOnFalse;\n  }\n}\n\n/**\n * @public\n */\nexport const visit = (root,\n// @ts-ignore\nvisitor, {\n  keyMap = keyMapDefault,\n  ...rest\n} = {}) => {\n  // @ts-ignore\n  return astVisit(root, visitor, {\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode,\n    ...rest\n  });\n};\n\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async (root,\n// @ts-ignore\nvisitor, {\n  keyMap = keyMapDefault,\n  ...rest\n} = {}) => {\n  // @ts-ignore\n  return astVisit[Symbol.for('nodejs.util.promisify.custom')](root, visitor, {\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode,\n    ...rest\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}