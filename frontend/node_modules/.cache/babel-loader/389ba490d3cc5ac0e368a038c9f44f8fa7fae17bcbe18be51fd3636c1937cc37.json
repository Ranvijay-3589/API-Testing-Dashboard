{"ast":null,"code":"import _objectSpread from \"/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { propEq } from 'ramda';\nimport { createNamespace, visit, cloneDeep } from '@swagger-api/apidom-core';\nimport openApi3_1Namespace, { getNodeType, isOpenApi3_1Element, keyMap, mediaTypes } from '@swagger-api/apidom-ns-openapi-3-1';\nimport DereferenceStrategy from \"../DereferenceStrategy.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport ReferenceSet from \"../../../ReferenceSet.mjs\";\nimport OpenAPI3_1DereferenceVisitor from \"./visitor.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass OpenAPI3_1DereferenceStrategy extends DereferenceStrategy {\n  constructor(options) {\n    super(_objectSpread(_objectSpread({}, options !== null && options !== void 0 ? options : {}), {}, {\n      name: 'openapi-3-1'\n    }));\n  }\n  canDereference(file) {\n    var _file$parseResult;\n    // assert by media type\n    if (file.mediaType !== 'text/plain') {\n      return mediaTypes.includes(file.mediaType);\n    }\n\n    // assert by inspecting ApiDOM\n    return isOpenApi3_1Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.result);\n  }\n  async dereference(file, options) {\n    var _options$dereference$;\n    const namespace = createNamespace(openApi3_1Namespace);\n    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet();\n    const mutableRefSet = new ReferenceSet();\n    let refSet = immutableRefSet;\n    let reference;\n    if (!immutableRefSet.has(file.uri)) {\n      reference = new Reference({\n        uri: file.uri,\n        value: file.parseResult\n      });\n      immutableRefSet.add(reference);\n    } else {\n      // pre-computed refSet was provided as configuration option\n      reference = immutableRefSet.find(propEq(file.uri, 'uri'));\n    }\n\n    /**\n     * Clone refSet due the dereferencing process being mutable.\n     * We don't want to mutate the original refSet and the references.\n     */\n    if (options.dereference.immutable) {\n      immutableRefSet.refs.map(ref => new Reference(_objectSpread(_objectSpread({}, ref), {}, {\n        value: cloneDeep(ref.value)\n      }))).forEach(ref => mutableRefSet.add(ref));\n      reference = mutableRefSet.find(ref => ref.uri === file.uri);\n      refSet = mutableRefSet;\n    }\n    const visitor = new OpenAPI3_1DereferenceVisitor({\n      reference: reference,\n      namespace,\n      options\n    });\n    const dereferencedElement = await visitAsync(refSet.rootRef.value, visitor, {\n      keyMap,\n      nodeTypeGetter: getNodeType\n    });\n\n    /**\n     * If immutable option is set, replay refs from the refSet.\n     */\n    if (options.dereference.immutable) {\n      mutableRefSet.refs.filter(ref => ref.uri.startsWith('immutable://')).map(ref => new Reference(_objectSpread(_objectSpread({}, ref), {}, {\n        uri: ref.uri.replace(/^immutable:\\/\\//, '')\n      }))).forEach(ref => immutableRefSet.add(ref));\n    }\n\n    /**\n     * Release all memory if this refSet was not provided as an configuration option.\n     * If provided as configuration option, then provider is responsible for cleanup.\n     */\n    if (options.dereference.refSet === null) {\n      immutableRefSet.clean();\n    }\n    mutableRefSet.clean();\n    return dereferencedElement;\n  }\n}\nexport { OpenAPI3_1DereferenceVisitor };\nexport { resolveSchema$refField, resolveSchema$idField, maybeRefractToSchemaElement } from \"./util.mjs\";\nexport default OpenAPI3_1DereferenceStrategy;","map":{"version":3,"names":["propEq","createNamespace","visit","cloneDeep","openApi3_1Namespace","getNodeType","isOpenApi3_1Element","keyMap","mediaTypes","DereferenceStrategy","Reference","ReferenceSet","OpenAPI3_1DereferenceVisitor","visitAsync","Symbol","for","OpenAPI3_1DereferenceStrategy","constructor","options","_objectSpread","name","canDereference","file","_file$parseResult","mediaType","includes","parseResult","result","dereference","_options$dereference$","namespace","immutableRefSet","refSet","mutableRefSet","reference","has","uri","value","add","find","immutable","refs","map","ref","forEach","visitor","dereferencedElement","rootRef","nodeTypeGetter","filter","startsWith","replace","clean","resolveSchema$refField","resolveSchema$idField","maybeRefractToSchemaElement"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/index.mjs"],"sourcesContent":["import { propEq } from 'ramda';\nimport { createNamespace, visit, cloneDeep } from '@swagger-api/apidom-core';\nimport openApi3_1Namespace, { getNodeType, isOpenApi3_1Element, keyMap, mediaTypes } from '@swagger-api/apidom-ns-openapi-3-1';\nimport DereferenceStrategy from \"../DereferenceStrategy.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport ReferenceSet from \"../../../ReferenceSet.mjs\";\nimport OpenAPI3_1DereferenceVisitor from \"./visitor.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass OpenAPI3_1DereferenceStrategy extends DereferenceStrategy {\n  constructor(options) {\n    super({\n      ...(options !== null && options !== void 0 ? options : {}),\n      name: 'openapi-3-1'\n    });\n  }\n  canDereference(file) {\n    var _file$parseResult;\n    // assert by media type\n    if (file.mediaType !== 'text/plain') {\n      return mediaTypes.includes(file.mediaType);\n    }\n\n    // assert by inspecting ApiDOM\n    return isOpenApi3_1Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.result);\n  }\n  async dereference(file, options) {\n    var _options$dereference$;\n    const namespace = createNamespace(openApi3_1Namespace);\n    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet();\n    const mutableRefSet = new ReferenceSet();\n    let refSet = immutableRefSet;\n    let reference;\n    if (!immutableRefSet.has(file.uri)) {\n      reference = new Reference({\n        uri: file.uri,\n        value: file.parseResult\n      });\n      immutableRefSet.add(reference);\n    } else {\n      // pre-computed refSet was provided as configuration option\n      reference = immutableRefSet.find(propEq(file.uri, 'uri'));\n    }\n\n    /**\n     * Clone refSet due the dereferencing process being mutable.\n     * We don't want to mutate the original refSet and the references.\n     */\n    if (options.dereference.immutable) {\n      immutableRefSet.refs.map(ref => new Reference({\n        ...ref,\n        value: cloneDeep(ref.value)\n      })).forEach(ref => mutableRefSet.add(ref));\n      reference = mutableRefSet.find(ref => ref.uri === file.uri);\n      refSet = mutableRefSet;\n    }\n    const visitor = new OpenAPI3_1DereferenceVisitor({\n      reference: reference,\n      namespace,\n      options\n    });\n    const dereferencedElement = await visitAsync(refSet.rootRef.value, visitor, {\n      keyMap,\n      nodeTypeGetter: getNodeType\n    });\n\n    /**\n     * If immutable option is set, replay refs from the refSet.\n     */\n    if (options.dereference.immutable) {\n      mutableRefSet.refs.filter(ref => ref.uri.startsWith('immutable://')).map(ref => new Reference({\n        ...ref,\n        uri: ref.uri.replace(/^immutable:\\/\\//, '')\n      })).forEach(ref => immutableRefSet.add(ref));\n    }\n\n    /**\n     * Release all memory if this refSet was not provided as an configuration option.\n     * If provided as configuration option, then provider is responsible for cleanup.\n     */\n    if (options.dereference.refSet === null) {\n      immutableRefSet.clean();\n    }\n    mutableRefSet.clean();\n    return dereferencedElement;\n  }\n}\nexport { OpenAPI3_1DereferenceVisitor };\nexport { resolveSchema$refField, resolveSchema$idField, maybeRefractToSchemaElement } from \"./util.mjs\";\nexport default OpenAPI3_1DereferenceStrategy;"],"mappings":";AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,SAASC,eAAe,EAAEC,KAAK,EAAEC,SAAS,QAAQ,0BAA0B;AAC5E,OAAOC,mBAAmB,IAAIC,WAAW,EAAEC,mBAAmB,EAAEC,MAAM,EAAEC,UAAU,QAAQ,oCAAoC;AAC9H,OAAOC,mBAAmB,MAAM,4BAA4B;AAC5D,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,YAAY,MAAM,2BAA2B;AACpD,OAAOC,4BAA4B,MAAM,eAAe;AACxD;AACA,MAAMC,UAAU,GAAGX,KAAK,CAACY,MAAM,CAACC,GAAG,CAAC,8BAA8B,CAAC,CAAC;;AAEpE;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMC,6BAA6B,SAASP,mBAAmB,CAAC;EAC9DQ,WAAWA,CAACC,OAAO,EAAE;IACnB,KAAK,CAAAC,aAAA,CAAAA,aAAA,KACCD,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAGA,OAAO,GAAG,CAAC,CAAC;MACzDE,IAAI,EAAE;IAAa,EACpB,CAAC;EACJ;EACAC,cAAcA,CAACC,IAAI,EAAE;IACnB,IAAIC,iBAAiB;IACrB;IACA,IAAID,IAAI,CAACE,SAAS,KAAK,YAAY,EAAE;MACnC,OAAOhB,UAAU,CAACiB,QAAQ,CAACH,IAAI,CAACE,SAAS,CAAC;IAC5C;;IAEA;IACA,OAAOlB,mBAAmB,CAAC,CAACiB,iBAAiB,GAAGD,IAAI,CAACI,WAAW,MAAM,IAAI,IAAIH,iBAAiB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,iBAAiB,CAACI,MAAM,CAAC;EACjJ;EACA,MAAMC,WAAWA,CAACN,IAAI,EAAEJ,OAAO,EAAE;IAC/B,IAAIW,qBAAqB;IACzB,MAAMC,SAAS,GAAG7B,eAAe,CAACG,mBAAmB,CAAC;IACtD,MAAM2B,eAAe,GAAG,CAACF,qBAAqB,GAAGX,OAAO,CAACU,WAAW,CAACI,MAAM,MAAM,IAAI,IAAIH,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,IAAIlB,YAAY,CAAC,CAAC;IACtK,MAAMsB,aAAa,GAAG,IAAItB,YAAY,CAAC,CAAC;IACxC,IAAIqB,MAAM,GAAGD,eAAe;IAC5B,IAAIG,SAAS;IACb,IAAI,CAACH,eAAe,CAACI,GAAG,CAACb,IAAI,CAACc,GAAG,CAAC,EAAE;MAClCF,SAAS,GAAG,IAAIxB,SAAS,CAAC;QACxB0B,GAAG,EAAEd,IAAI,CAACc,GAAG;QACbC,KAAK,EAAEf,IAAI,CAACI;MACd,CAAC,CAAC;MACFK,eAAe,CAACO,GAAG,CAACJ,SAAS,CAAC;IAChC,CAAC,MAAM;MACL;MACAA,SAAS,GAAGH,eAAe,CAACQ,IAAI,CAACvC,MAAM,CAACsB,IAAI,CAACc,GAAG,EAAE,KAAK,CAAC,CAAC;IAC3D;;IAEA;AACJ;AACA;AACA;IACI,IAAIlB,OAAO,CAACU,WAAW,CAACY,SAAS,EAAE;MACjCT,eAAe,CAACU,IAAI,CAACC,GAAG,CAACC,GAAG,IAAI,IAAIjC,SAAS,CAAAS,aAAA,CAAAA,aAAA,KACxCwB,GAAG;QACNN,KAAK,EAAElC,SAAS,CAACwC,GAAG,CAACN,KAAK;MAAC,EAC5B,CAAC,CAAC,CAACO,OAAO,CAACD,GAAG,IAAIV,aAAa,CAACK,GAAG,CAACK,GAAG,CAAC,CAAC;MAC1CT,SAAS,GAAGD,aAAa,CAACM,IAAI,CAACI,GAAG,IAAIA,GAAG,CAACP,GAAG,KAAKd,IAAI,CAACc,GAAG,CAAC;MAC3DJ,MAAM,GAAGC,aAAa;IACxB;IACA,MAAMY,OAAO,GAAG,IAAIjC,4BAA4B,CAAC;MAC/CsB,SAAS,EAAEA,SAAS;MACpBJ,SAAS;MACTZ;IACF,CAAC,CAAC;IACF,MAAM4B,mBAAmB,GAAG,MAAMjC,UAAU,CAACmB,MAAM,CAACe,OAAO,CAACV,KAAK,EAAEQ,OAAO,EAAE;MAC1EtC,MAAM;MACNyC,cAAc,EAAE3C;IAClB,CAAC,CAAC;;IAEF;AACJ;AACA;IACI,IAAIa,OAAO,CAACU,WAAW,CAACY,SAAS,EAAE;MACjCP,aAAa,CAACQ,IAAI,CAACQ,MAAM,CAACN,GAAG,IAAIA,GAAG,CAACP,GAAG,CAACc,UAAU,CAAC,cAAc,CAAC,CAAC,CAACR,GAAG,CAACC,GAAG,IAAI,IAAIjC,SAAS,CAAAS,aAAA,CAAAA,aAAA,KACxFwB,GAAG;QACNP,GAAG,EAAEO,GAAG,CAACP,GAAG,CAACe,OAAO,CAAC,iBAAiB,EAAE,EAAE;MAAC,EAC5C,CAAC,CAAC,CAACP,OAAO,CAACD,GAAG,IAAIZ,eAAe,CAACO,GAAG,CAACK,GAAG,CAAC,CAAC;IAC9C;;IAEA;AACJ;AACA;AACA;IACI,IAAIzB,OAAO,CAACU,WAAW,CAACI,MAAM,KAAK,IAAI,EAAE;MACvCD,eAAe,CAACqB,KAAK,CAAC,CAAC;IACzB;IACAnB,aAAa,CAACmB,KAAK,CAAC,CAAC;IACrB,OAAON,mBAAmB;EAC5B;AACF;AACA,SAASlC,4BAA4B;AACrC,SAASyC,sBAAsB,EAAEC,qBAAqB,EAAEC,2BAA2B,QAAQ,YAAY;AACvG,eAAevC,6BAA6B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}