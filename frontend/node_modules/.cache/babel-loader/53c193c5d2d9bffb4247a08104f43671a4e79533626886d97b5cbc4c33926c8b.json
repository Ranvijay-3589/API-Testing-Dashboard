{"ast":null,"code":"/*  *************************************************************************************\r\n *   copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved\r\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\r\n *\r\n *    Redistribution and use in source and binary forms, with or without\r\n *    modification, are permitted provided that the following conditions are met:\r\n *\r\n *    1. Redistributions of source code must retain the above copyright notice, this\r\n *       list of conditions and the following disclaimer.\r\n *\r\n *    2. Redistributions in binary form must reproduce the above copyright notice,\r\n *       this list of conditions and the following disclaimer in the documentation\r\n *       and/or other materials provided with the distribution.\r\n *\r\n *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n *    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n *    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n *    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n *    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n *    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n *    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n *    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *   ********************************************************************************* */\nexport { Parser, Ast, Trace, Stats, utilities, identifiers };\nconst Parser = function fnparser() {\n  const id = identifiers;\n  const utils = utilities;\n  const p = this;\n  const thisFileName = 'parser.js: Parser(): ';\n  const systemData = function systemData() {\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.refresh = () => {\n      this.state = id.ACTIVE;\n      this.phraseLength = 0;\n    };\n  };\n  p.ast = undefined;\n  p.stats = undefined;\n  p.trace = undefined;\n  p.callbacks = [];\n  let lookAhead = 0;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let maxMatched = 0;\n  let rules = undefined;\n  let udts = undefined;\n  let opcodes = undefined;\n  let chars = undefined;\n  let sysData = new systemData();\n  let ruleCallbacks = undefined;\n  let udtCallbacks = undefined;\n  let userData = undefined;\n  const clear = () => {\n    lookAhead = 0;\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    rules = undefined;\n    udts = undefined;\n    opcodes = undefined;\n    chars = undefined;\n    sysData.refresh();\n    ruleCallbacks = undefined;\n    udtCallbacks = undefined;\n    userData = undefined;\n  };\n  const initializeCallbacks = () => {\n    const functionName = \"\".concat(thisFileName, \"initializeCallbacks(): \");\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = undefined;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = undefined;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in p.callbacks) {\n      if (p.callbacks.hasOwnProperty(index)) {\n        i = list.indexOf(index.toLowerCase());\n        if (i < 0) {\n          throw new Error(\"\".concat(functionName, \"syntax callback '\").concat(index, \"' not a rule or udt name\"));\n        }\n        func = p.callbacks[index] ? p.callbacks[index] : undefined;\n        if (typeof func === 'function' || func === undefined) {\n          if (i < rules.length) {\n            ruleCallbacks[i] = func;\n          } else {\n            udtCallbacks[i - rules.length] = func;\n          }\n        } else {\n          throw new Error(\"\".concat(functionName, \"syntax callback[\").concat(index, \"] must be function reference or falsy)\"));\n        }\n      }\n    }\n  };\n  p.parse = (grammar, startName, inputString, callbackData) => {\n    const functionName = \"\".concat(thisFileName, \"parse(): \");\n    clear();\n    chars = utils.stringToChars(inputString);\n    rules = grammar.rules;\n    udts = grammar.udts;\n    const lower = startName.toLowerCase();\n    let startIndex = undefined;\n    for (const i in rules) {\n      if (rules.hasOwnProperty(i)) {\n        if (lower === rules[i].lower) {\n          startIndex = rules[i].index;\n          break;\n        }\n      }\n    }\n    if (startIndex === undefined) {\n      throw new Error(\"\".concat(functionName, \"start rule name '\").concat(startRule, \"' not recognized\"));\n    }\n    initializeCallbacks();\n    if (p.trace) {\n      p.trace.init(rules, udts, chars);\n    }\n    if (p.stats) {\n      p.stats.init(rules, udts);\n    }\n    if (p.ast) {\n      p.ast.init(rules, udts, chars);\n    }\n    userData = callbackData;\n    /* create a dummy opcode for the start rule */\n    opcodes = [{\n      type: id.RNM,\n      index: startIndex\n    }];\n    /* execute the start rule */\n    opExecute(0, 0);\n    opcodes = undefined;\n    /* test and return the sysData */\n    let success = false;\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(\"\".concat(functionName, \"final state should never be 'ACTIVE'\"));\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === chars.length) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      stateName: id.idName(sysData.state),\n      length: chars.length,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits\n    };\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = (opIndex, phraseIndex) => {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    if (p.ast) {\n      astLength = p.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      if (p.ast) {\n        p.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = (opIndex, phraseIndex) => {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    if (p.ast) {\n      astLength = p.ast.getLength();\n    }\n    while (1) {\n      if (repCharIndex >= chars.length) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      if (p.ast) {\n        p.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = (rule, sysData, charsLeft, down) => {\n    if (sysData.phraseLength > charsLeft) {\n      let str = \"\".concat(thisFileName, \"opRNM(\").concat(rule.name, \"): callback function error: \");\n      str += \"sysData.phraseLength: \".concat(sysData.phraseLength);\n      str += \" must be <= remaining chars: \".concat(charsLeft);\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (!down) {\n          throw new Error(\"\".concat(thisFileName, \"opRNM(\").concat(rule.name, \"): callback function return error. ACTIVE state not allowed.\"));\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\"\".concat(thisFileName, \"opRNM(\").concat(rule.name, \"): callback function return error. Unrecognized return state: \").concat(sysData.state));\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  const opRNM = (opIndex, phraseIndex) => {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    /* ignore AST in look ahead (AND or NOT operator above) */\n    if (!lookAhead) {\n      astDefined = p.ast && p.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = p.ast.getLength();\n        p.ast.down(op.index, rules[op.index].name);\n      }\n    }\n    if (callback) {\n      /* call user's callback going down the parse tree*/\n      const charsLeft = chars.length - phraseIndex;\n      callback(sysData, chars, phraseIndex, userData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex);\n        opcodes = savedOpcodes;\n        /* call user's callback going up the parse tree*/\n        callback(sysData, chars, phraseIndex, userData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    } else {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    }\n    if (!lookAhead) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          p.ast.setLength(astLength);\n        } else {\n          p.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < chars.length) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= chars.length) {\n      for (let i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = (opIndex, phraseIndex) => {\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= chars.length) {\n      for (let i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = (udt, sysData, charsLeft) => {\n    if (sysData.phraseLength > charsLeft) {\n      let str = \"\".concat(thisFileName, \"opUDT(\").concat(udt.name, \"): callback function error: \");\n      str += \"sysData.phraseLength: \".concat(sysData.phraseLength);\n      str += \" must be <= remaining chars: \".concat(charsLeft);\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(\"\".concat(thisFileName, \"opUDT(\").concat(udt.name, \") ACTIVE state return not allowed.\"));\n      case id.EMPTY:\n        if (udt.empty) {\n          sysData.phraseLength = 0;\n        } else {\n          throw new Error(\"\".concat(thisFileName, \"opUDT(\").concat(udt.name, \") may not return EMPTY.\"));\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty) {\n            sysData.state = id.EMPTY;\n          } else {\n            throw new Error(\"\".concat(thisFileName, \"opUDT(\").concat(udt.name, \") may not return EMPTY.\"));\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\"\".concat(thisFileName, \"opUDT(\").concat(udt.name, \"): callback function return error. Unrecognized return state: \").concat(sysData.state));\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = (opIndex, phraseIndex) => {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n    /* ignore AST in look ahead */\n    if (!lookAhead) {\n      astDefined = p.ast && p.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = p.ast.getLength();\n        p.ast.down(astIndex, udt.name);\n      }\n    }\n    /* call the UDT */\n    const charsLeft = chars.length - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, userData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (!lookAhead) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          p.ast.setLength(astLength);\n        } else {\n          p.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = (opIndex, phraseIndex) => {\n    lookAhead += 1;\n    opExecute(opIndex + 1, phraseIndex);\n    lookAhead -= 1;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(\"opAND: invalid state \".concat(sysData.state));\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = (opIndex, phraseIndex) => {\n    lookAhead += 1;\n    opExecute(opIndex + 1, phraseIndex);\n    lookAhead -= 1;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(\"opNOT: invalid state \".concat(sysData.state));\n    }\n  };\n  const opExecute = (opIndex, phraseIndex) => {\n    const functionName = \"\".concat(thisFileName, \"opExecute(): \");\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n    }\n    treeDepth += 1;\n    sysData.refresh();\n    if (p.trace) {\n      p.trace.down(op, phraseIndex);\n    }\n    switch (op.type) {\n      case id.ALT:\n        opALT(opIndex, phraseIndex);\n        break;\n      case id.CAT:\n        opCAT(opIndex, phraseIndex);\n        break;\n      case id.REP:\n        opREP(opIndex, phraseIndex);\n        break;\n      case id.RNM:\n        opRNM(opIndex, phraseIndex);\n        break;\n      case id.TRG:\n        opTRG(opIndex, phraseIndex);\n        break;\n      case id.TBS:\n        opTBS(opIndex, phraseIndex);\n        break;\n      case id.TLS:\n        opTLS(opIndex, phraseIndex);\n        break;\n      case id.UDT:\n        opUDT(opIndex, phraseIndex);\n        break;\n      case id.AND:\n        opAND(opIndex, phraseIndex);\n        break;\n      case id.NOT:\n        opNOT(opIndex, phraseIndex);\n        break;\n      default:\n        throw new Error(\"\".concat(functionName, \"unrecognized operator\"));\n    }\n    if (!lookAhead) {\n      if (phraseIndex + sysData.phraseLength > maxMatched) {\n        maxMatched = phraseIndex + sysData.phraseLength;\n      }\n    }\n    if (p.stats) {\n      p.stats.collect(op, sysData);\n    }\n    if (p.trace) {\n      p.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength);\n    }\n    treeDepth -= 1;\n  };\n};\nconst Ast = function fnast() {\n  const thisFileName = 'parser.js: Ast()): ';\n  const id = identifiers;\n  const utils = utilities;\n  const a = this;\n  let rules = undefined;\n  let udts = undefined;\n  let chars = undefined;\n  let nodeCount = 0;\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  a.callbacks = [];\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  a.init = (rulesIn, udtsIn, charsIn) => {\n    stack.length = 0;\n    records.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodeCallbacks[i] = undefined;\n    }\n    for (const index in a.callbacks) {\n      if (a.callbacks.hasOwnProperty(index)) {\n        const lower = index.toLowerCase();\n        i = list.indexOf(lower);\n        if (i < 0) {\n          throw new Error(\"\".concat(thisFileName, \"init: node '\").concat(index, \"' not a rule or udt name\"));\n        }\n        nodeCallbacks[i] = a.callbacks[index];\n      }\n    }\n  };\n  /* AST node rule callbacks - called by the parser's `RNM` operator */\n  a.ruleDefined = index => !!nodeCallbacks[index];\n  /* AST node UDT callbacks - called by the parser's `UDT` operator */\n  a.udtDefined = index => !!nodeCallbacks[rules.length + index];\n  /* called by the parser's `RNM` & `UDT` operators\r\n     builds a record for the downward traversal of the node */\n  a.down = (callbackIndex, name) => {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: undefined,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: undefined,\n      phraseLength: undefined,\n      stack: stack.length\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  a.up = (callbackIndex, name, phraseIndex, phraseLength) => {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  a.translate = data => {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (callback) {\n        if (record.state === id.SEM_PRE) {\n          callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n        } else if (callback) {\n          callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n        }\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  a.setLength = length => {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  a.getLength = () => records.length;\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    while (n-- > 0) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST. Node data are JavaScript strings.\n  a.toXml = () => {\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += \"<root nodes=\\\"\".concat(records.length / 2, \"\\\" characters=\\\"\").concat(chars.length, \"\\\">\\n\");\n    xml += \"<!-- input string -->\\n\";\n    xml += indent(depth + 2);\n    xml += utils.charsToString(chars);\n    xml += '\\n';\n    records.forEach(rec => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += \"<node name=\\\"\".concat(rec.name, \"\\\" index=\\\"\").concat(rec.phraseIndex, \"\\\" length=\\\"\").concat(rec.phraseLength, \"\\\">\\n\");\n        xml += indent(depth + 2);\n        xml += utils.charsToString(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += \"</node><!-- name=\\\"\".concat(rec.name, \"\\\" -->\\n\");\n        depth -= 1;\n      }\n    });\n    xml += '</root>\\n';\n    return xml;\n  };\n};\nconst Trace = function fntrace() {\n  const id = identifiers;\n  const utils = utilities;\n  const thisFile = 'parser.js: Trace(): ';\n  let chars = undefined;\n  let rules = undefined;\n  let udts = undefined;\n  let out = '';\n  let treeDepth = 0;\n  const MAX_PHRASE = 100;\n  const t = this;\n  const indent = n => {\n    let ret = '';\n    let count = 0;\n    if (n >= 0) {\n      while (n--) {\n        count += 1;\n        if (count === 5) {\n          ret += '|';\n          count = 0;\n        } else {\n          ret += '.';\n        }\n      }\n    }\n    return ret;\n  };\n  t.init = (r, u, c) => {\n    rules = r;\n    udts = u;\n    chars = c;\n  };\n  const opName = op => {\n    let name;\n    switch (op.type) {\n      case id.ALT:\n        name = 'ALT';\n        break;\n      case id.CAT:\n        name = 'CAT';\n        break;\n      case id.REP:\n        if (op.max === Infinity) {\n          name = \"REP(\".concat(op.min, \",inf)\");\n        } else {\n          name = \"REP(\".concat(op.min, \",\").concat(op.max, \")\");\n        }\n        break;\n      case id.RNM:\n        name = \"RNM(\".concat(rules[op.index].name, \")\");\n        break;\n      case id.TRG:\n        name = \"TRG(\".concat(op.min, \",\").concat(op.max, \")\");\n        break;\n      case id.TBS:\n        if (op.string.length > 6) {\n          name = \"TBS(\".concat(utils.charsToString(op.string, 0, 3), \"...)\");\n        } else {\n          name = \"TBS(\".concat(utils.charsToString(op.string, 0, 6), \")\");\n        }\n        break;\n      case id.TLS:\n        if (op.string.length > 6) {\n          name = \"TLS(\".concat(utils.charsToString(op.string, 0, 3), \"...)\");\n        } else {\n          name = \"TLS(\".concat(utils.charsToString(op.string, 0, 6), \")\");\n        }\n        break;\n      case id.UDT:\n        name = \"UDT(\".concat(udts[op.index].name, \")\");\n        break;\n      case id.AND:\n        name = 'AND';\n        break;\n      case id.NOT:\n        name = 'NOT';\n        break;\n      default:\n        throw new Error(\"\".concat(thisFile, \"Trace: opName: unrecognized opcode\"));\n    }\n    return name;\n  };\n  t.down = (op, offset) => {\n    const lead = indent(treeDepth);\n    const len = Math.min(MAX_PHRASE, chars.length - offset);\n    let phrase = utils.charsToString(chars, offset, len);\n    if (len < chars.length - offset) {\n      phrase += '...';\n    }\n    phrase = \"\".concat(lead, \"|-|[\").concat(opName(op), \"]\").concat(phrase, \"\\n\");\n    out += phrase;\n    treeDepth += 1;\n  };\n  t.up = (op, state, offset, phraseLength) => {\n    const thisFunc = \"\".concat(thisFile, \"trace.up: \");\n    treeDepth -= 1;\n    const lead = indent(treeDepth);\n    let len;\n    let phrase;\n    let st;\n    switch (state) {\n      case id.EMPTY:\n        st = '|E|';\n        phrase = \"''\";\n        break;\n      case id.MATCH:\n        st = '|M|';\n        len = Math.min(MAX_PHRASE, phraseLength);\n        if (len < phraseLength) {\n          phrase = \"'\".concat(utils.charsToString(chars, offset, len), \"...'\");\n        } else {\n          phrase = \"'\".concat(utils.charsToString(chars, offset, len), \"'\");\n        }\n        break;\n      case id.NOMATCH:\n        st = '|N|';\n        phrase = '';\n        break;\n      default:\n        throw new Error(\"\".concat(thisFunc, \" unrecognized state\"));\n    }\n    phrase = \"\".concat(lead).concat(st, \"[\").concat(opName(op), \"]\").concat(phrase, \"\\n\");\n    out += phrase;\n  };\n  t.displayTrace = () => out;\n};\nconst Stats = function fnstats() {\n  const id = identifiers;\n  const thisFileName = 'parser.js: Stats(): ';\n  let rules;\n  let udts;\n  let totals;\n  const stats = [];\n  const ruleStats = [];\n  const udtStats = [];\n  /* called by parser to initialize the stats */\n  this.init = (r, u) => {\n    rules = r;\n    udts = u;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = (op, sys) => {\n    incStat(totals, sys.state, sys.phraseLength);\n    incStat(stats[op.type], sys.state, sys.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], sys.state, sys.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], sys.state, sys.phraseLength);\n    }\n  };\n  this.displayStats = () => {\n    let out = '';\n    const totals = {\n      match: 0,\n      empty: 0,\n      nomatch: 0,\n      total: 0\n    };\n    const displayRow = (op, m, e, n, t) => {\n      totals.match += m;\n      totals.empty += e;\n      totals.nomatch += n;\n      totals.total += t;\n      const mm = normalize(m);\n      const ee = normalize(e);\n      const nn = normalize(n);\n      const tt = normalize(t);\n      return \"\".concat(op, \" | \").concat(mm, \" | \").concat(ee, \" | \").concat(nn, \" | \").concat(tt, \" |\\n\");\n    };\n    out += '          OPERATOR STATS\\n';\n    out += '      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\\n';\n    out += displayRow('  ALT', stats[id.ALT].match, stats[id.ALT].empty, stats[id.ALT].nomatch, stats[id.ALT].total);\n    out += displayRow('  CAT', stats[id.CAT].match, stats[id.CAT].empty, stats[id.CAT].nomatch, stats[id.CAT].total);\n    out += displayRow('  REP', stats[id.REP].match, stats[id.REP].empty, stats[id.REP].nomatch, stats[id.REP].total);\n    out += displayRow('  RNM', stats[id.RNM].match, stats[id.RNM].empty, stats[id.RNM].nomatch, stats[id.RNM].total);\n    out += displayRow('  TRG', stats[id.TRG].match, stats[id.TRG].empty, stats[id.TRG].nomatch, stats[id.TRG].total);\n    out += displayRow('  TBS', stats[id.TBS].match, stats[id.TBS].empty, stats[id.TBS].nomatch, stats[id.TBS].total);\n    out += displayRow('  TLS', stats[id.TLS].match, stats[id.TLS].empty, stats[id.TLS].nomatch, stats[id.TLS].total);\n    out += displayRow('  UDT', stats[id.UDT].match, stats[id.UDT].empty, stats[id.UDT].nomatch, stats[id.UDT].total);\n    out += displayRow('  AND', stats[id.AND].match, stats[id.AND].empty, stats[id.AND].nomatch, stats[id.AND].total);\n    out += displayRow('  NOT', stats[id.NOT].match, stats[id.NOT].empty, stats[id.NOT].nomatch, stats[id.NOT].total);\n    out += displayRow('TOTAL', totals.match, totals.empty, totals.nomatch, totals.total);\n    return out;\n  };\n  /*\r\n  Display rule/udt\r\n  */\n  this.displayHits = type => {\n    let out = '';\n    const displayRow = (m, e, n, t, name) => {\n      totals.match += m;\n      totals.empty += e;\n      totals.nomatch += n;\n      totals.total += t;\n      const mm = normalize(m);\n      const ee = normalize(e);\n      const nn = normalize(n);\n      const tt = normalize(t);\n      return \"| \".concat(mm, \" | \").concat(ee, \" | \").concat(nn, \" | \").concat(tt, \" | \").concat(name, \"\\n\");\n    };\n    if (typeof type === 'string' && type.toLowerCase()[0] === 'a') {\n      ruleStats.sort(sortAlpha);\n      udtStats.sort(sortAlpha);\n      out += '    RULES/UDTS ALPHABETICALLY\\n';\n    } else if (typeof type === 'string' && type.toLowerCase()[0] === 'i') {\n      ruleStats.sort(sortIndex);\n      udtStats.sort(sortIndex);\n      out += '    RULES/UDTS BY INDEX\\n';\n    } else {\n      ruleStats.sort(sortHits);\n      udtStats.sort(sortHits);\n      out += '    RULES/UDTS BY HIT COUNT\\n';\n    }\n    out += '|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\\n';\n    for (let i = 0; i < ruleStats.length; i += 1) {\n      let r = ruleStats[i];\n      if (r.total) {\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\n      }\n    }\n    for (let i = 0; i < udtStats.length; i += 1) {\n      let r = udtStats[i];\n      if (r.total) {\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\n      }\n    }\n    return out;\n  };\n  const normalize = n => {\n    if (n < 10) {\n      return \"      \".concat(n);\n    }\n    if (n < 100) {\n      return \"     \".concat(n);\n    }\n    if (n < 1000) {\n      return \"    \".concat(n);\n    }\n    if (n < 10000) {\n      return \"   \".concat(n);\n    }\n    if (n < 100000) {\n      return \"  \".concat(n);\n    }\n    if (n < 1000000) {\n      return \" \".concat(n);\n    }\n    return \"\".concat(n);\n  };\n  const sortAlpha = (lhs, rhs) => {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  const sortHits = (lhs, rhs) => {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  const sortIndex = (lhs, rhs) => {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function fnempty() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = () => {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = (stat, state) => {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(\"\".concat(thisFileName, \"collect(): incStat(): unrecognized state: \").concat(state));\n    }\n  };\n};\nconst utilities = {\n  // utility functions\n  stringToChars: string => [...string].map(cp => cp.codePointAt(0)),\n  charsToString: (chars, beg, len) => {\n    let subChars = chars;\n    while (1) {\n      if (beg === undefined || beg < 0) {\n        break;\n      }\n      if (len === undefined) {\n        subChars = chars.slice(beg);\n        break;\n      }\n      if (len <= 0) {\n        // always an empty string\n        return '';\n      }\n      subChars = chars.slice(beg, beg + len);\n      break;\n    }\n    return String.fromCodePoint(...subChars);\n  }\n};\nconst identifiers = {\n  // Identifies the operator type.\n  // NB: These must match the values in apg-js 4.3.0, apg-lib/identifiers.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Ignored. Retained for backwords compatibility.\n  SEM_OK: 300,\n  idName: s => {\n    switch (s) {\n      case identifiers.ALT:\n        return 'ALT';\n      case identifiers.CAT:\n        return 'CAT';\n      case identifiers.REP:\n        return 'REP';\n      case identifiers.RNM:\n        return 'RNM';\n      case identifiers.TRG:\n        return 'TRG';\n      case identifiers.TBS:\n        return 'TBS';\n      case identifiers.TLS:\n        return 'TLS';\n      case identifiers.UDT:\n        return 'UDT';\n      case identifiers.AND:\n        return 'AND';\n      case identifiers.NOT:\n        return 'NOT';\n      case identifiers.ACTIVE:\n        return 'ACTIVE';\n      case identifiers.EMPTY:\n        return 'EMPTY';\n      case identifiers.MATCH:\n        return 'MATCH';\n      case identifiers.NOMATCH:\n        return 'NOMATCH';\n      case identifiers.SEM_PRE:\n        return 'SEM_PRE';\n      case identifiers.SEM_POST:\n        return 'SEM_POST';\n      case identifiers.SEM_OK:\n        return 'SEM_OK';\n      default:\n        return 'UNRECOGNIZED STATE';\n    }\n  }\n};","map":{"version":3,"names":["Parser","Ast","Trace","Stats","utilities","identifiers","fnparser","id","utils","p","thisFileName","systemData","state","ACTIVE","phraseLength","refresh","ast","undefined","stats","trace","callbacks","lookAhead","treeDepth","maxTreeDepth","nodeHits","maxMatched","rules","udts","opcodes","chars","sysData","ruleCallbacks","udtCallbacks","userData","clear","initializeCallbacks","functionName","concat","i","length","func","list","push","lower","index","hasOwnProperty","indexOf","toLowerCase","Error","parse","grammar","startName","inputString","callbackData","stringToChars","startIndex","startRule","init","type","RNM","opExecute","success","NOMATCH","EMPTY","MATCH","stateName","idName","matched","opALT","opIndex","phraseIndex","op","children","opCAT","astLength","catCharIndex","catPhrase","getLength","setLength","opREP","repCharIndex","repPhrase","repCount","max","min","validateRnmCallbackResult","rule","charsLeft","down","str","name","opRNM","astDefined","savedOpcodes","callback","ruleDefined","up","opTRG","opTBS","len","string","opTLS","code","validateUdtCallbackResult","udt","empty","opUDT","astIndex","UdtIndex","udtDefined","opAND","opNOT","ALT","CAT","REP","TRG","TBS","TLS","UDT","AND","NOT","collect","fnast","a","nodeCount","nodeCallbacks","stack","records","rulesIn","udtsIn","charsIn","callbackIndex","thisIndex","thatIndex","SEM_PRE","pop","SEM_POST","translate","data","ret","record","indent","n","toXml","xml","depth","charsToString","forEach","rec","fntrace","thisFile","out","MAX_PHRASE","t","count","r","u","c","opName","Infinity","offset","lead","Math","phrase","thisFunc","st","displayTrace","fnstats","totals","ruleStats","udtStats","sys","incStat","displayStats","match","nomatch","total","displayRow","m","e","mm","normalize","ee","nn","tt","displayHits","sort","sortAlpha","sortIndex","sortHits","lhs","rhs","EmptyStat","fnempty","stat","map","cp","codePointAt","beg","subChars","slice","String","fromCodePoint","SEM_OK","s"],"sources":["/var/www/ranvijay.capricorn.online/mohit/frontend/node_modules/apg-lite/lib/parser.js"],"sourcesContent":["/*  *************************************************************************************\r\n *   copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved\r\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\r\n *\r\n *    Redistribution and use in source and binary forms, with or without\r\n *    modification, are permitted provided that the following conditions are met:\r\n *\r\n *    1. Redistributions of source code must retain the above copyright notice, this\r\n *       list of conditions and the following disclaimer.\r\n *\r\n *    2. Redistributions in binary form must reproduce the above copyright notice,\r\n *       this list of conditions and the following disclaimer in the documentation\r\n *       and/or other materials provided with the distribution.\r\n *\r\n *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n *    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n *    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n *    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n *    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n *    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n *    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n *    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *   ********************************************************************************* */\r\nexport { Parser, Ast, Trace, Stats, utilities, identifiers };\r\n\r\nconst Parser = function fnparser() {\r\n  const id = identifiers;\r\n  const utils = utilities;\r\n  const p = this;\r\n  const thisFileName = 'parser.js: Parser(): ';\r\n  const systemData = function systemData() {\r\n    this.state = id.ACTIVE;\r\n    this.phraseLength = 0;\r\n    this.refresh = () => {\r\n      this.state = id.ACTIVE;\r\n      this.phraseLength = 0;\r\n    };\r\n  };\r\n  p.ast = undefined;\r\n  p.stats = undefined;\r\n  p.trace = undefined;\r\n  p.callbacks = [];\r\n  let lookAhead = 0;\r\n  let treeDepth = 0;\r\n  let maxTreeDepth = 0;\r\n  let nodeHits = 0;\r\n  let maxMatched = 0;\r\n  let rules = undefined;\r\n  let udts = undefined;\r\n  let opcodes = undefined;\r\n  let chars = undefined;\r\n  let sysData = new systemData();\r\n  let ruleCallbacks = undefined;\r\n  let udtCallbacks = undefined;\r\n  let userData = undefined;\r\n  const clear = () => {\r\n    lookAhead = 0;\r\n    treeDepth = 0;\r\n    maxTreeDepth = 0;\r\n    nodeHits = 0;\r\n    maxMatched = 0;\r\n    rules = undefined;\r\n    udts = undefined;\r\n    opcodes = undefined;\r\n    chars = undefined;\r\n    sysData.refresh();\r\n    ruleCallbacks = undefined;\r\n    udtCallbacks = undefined;\r\n    userData = undefined;\r\n  };\r\n\r\n  const initializeCallbacks = () => {\r\n    const functionName = `${thisFileName}initializeCallbacks(): `;\r\n    let i;\r\n    ruleCallbacks = [];\r\n    udtCallbacks = [];\r\n    for (i = 0; i < rules.length; i += 1) {\r\n      ruleCallbacks[i] = undefined;\r\n    }\r\n    for (i = 0; i < udts.length; i += 1) {\r\n      udtCallbacks[i] = undefined;\r\n    }\r\n    let func;\r\n    const list = [];\r\n    for (i = 0; i < rules.length; i += 1) {\r\n      list.push(rules[i].lower);\r\n    }\r\n    for (i = 0; i < udts.length; i += 1) {\r\n      list.push(udts[i].lower);\r\n    }\r\n    for (const index in p.callbacks) {\r\n      if (p.callbacks.hasOwnProperty(index)) {\r\n        i = list.indexOf(index.toLowerCase());\r\n        if (i < 0) {\r\n          throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\r\n        }\r\n        func = p.callbacks[index] ? p.callbacks[index] : undefined;\r\n        if (typeof func === 'function' || func === undefined) {\r\n          if (i < rules.length) {\r\n            ruleCallbacks[i] = func;\r\n          } else {\r\n            udtCallbacks[i - rules.length] = func;\r\n          }\r\n        } else {\r\n          throw new Error(`${functionName}syntax callback[${index}] must be function reference or falsy)`);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  p.parse = (grammar, startName, inputString, callbackData) => {\r\n    const functionName = `${thisFileName}parse(): `;\r\n    clear();\r\n    chars = utils.stringToChars(inputString);\r\n    rules = grammar.rules;\r\n    udts = grammar.udts;\r\n    const lower = startName.toLowerCase();\r\n    let startIndex = undefined;\r\n    for (const i in rules) {\r\n      if (rules.hasOwnProperty(i)) {\r\n        if (lower === rules[i].lower) {\r\n          startIndex = rules[i].index;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (startIndex === undefined) {\r\n      throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\r\n    }\r\n    initializeCallbacks();\r\n    if (p.trace) {\r\n      p.trace.init(rules, udts, chars);\r\n    }\r\n    if (p.stats) {\r\n      p.stats.init(rules, udts);\r\n    }\r\n    if (p.ast) {\r\n      p.ast.init(rules, udts, chars);\r\n    }\r\n    userData = callbackData;\r\n    /* create a dummy opcode for the start rule */\r\n    opcodes = [\r\n      {\r\n        type: id.RNM,\r\n        index: startIndex,\r\n      },\r\n    ];\r\n    /* execute the start rule */\r\n    opExecute(0, 0);\r\n    opcodes = undefined;\r\n    /* test and return the sysData */\r\n    let success = false;\r\n    switch (sysData.state) {\r\n      case id.ACTIVE:\r\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\r\n      case id.NOMATCH:\r\n        success = false;\r\n        break;\r\n      case id.EMPTY:\r\n      case id.MATCH:\r\n        if (sysData.phraseLength === chars.length) {\r\n          success = true;\r\n        } else {\r\n          success = false;\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('unrecognized state');\r\n    }\r\n    return {\r\n      success,\r\n      state: sysData.state,\r\n      stateName: id.idName(sysData.state),\r\n      length: chars.length,\r\n      matched: sysData.phraseLength,\r\n      maxMatched,\r\n      maxTreeDepth,\r\n      nodeHits,\r\n    };\r\n  };\r\n  // The `ALT` operator.<br>\r\n  // Executes its child nodes, from left to right, until it finds a match.\r\n  // Fails if *all* of its child nodes fail.\r\n  const opALT = (opIndex, phraseIndex) => {\r\n    const op = opcodes[opIndex];\r\n    for (let i = 0; i < op.children.length; i += 1) {\r\n      opExecute(op.children[i], phraseIndex);\r\n      if (sysData.state !== id.NOMATCH) {\r\n        break;\r\n      }\r\n    }\r\n  };\r\n  // The `CAT` operator.<br>\r\n  // Executes all of its child nodes, from left to right,\r\n  // concatenating the matched phrases.\r\n  // Fails if *any* child nodes fail.\r\n  const opCAT = (opIndex, phraseIndex) => {\r\n    let success;\r\n    let astLength;\r\n    let catCharIndex;\r\n    let catPhrase;\r\n    const op = opcodes[opIndex];\r\n    if (p.ast) {\r\n      astLength = p.ast.getLength();\r\n    }\r\n    success = true;\r\n    catCharIndex = phraseIndex;\r\n    catPhrase = 0;\r\n    for (let i = 0; i < op.children.length; i += 1) {\r\n      opExecute(op.children[i], catCharIndex);\r\n      if (sysData.state === id.NOMATCH) {\r\n        success = false;\r\n        break;\r\n      } else {\r\n        catCharIndex += sysData.phraseLength;\r\n        catPhrase += sysData.phraseLength;\r\n      }\r\n    }\r\n    if (success) {\r\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\r\n      sysData.phraseLength = catPhrase;\r\n    } else {\r\n      sysData.state = id.NOMATCH;\r\n      sysData.phraseLength = 0;\r\n      if (p.ast) {\r\n        p.ast.setLength(astLength);\r\n      }\r\n    }\r\n  };\r\n  // The `REP` operator.<br>\r\n  // Repeatedly executes its single child node,\r\n  // concatenating each of the matched phrases found.\r\n  // The number of repetitions executed and its final sysData depends\r\n  // on its `min` & `max` repetition values.\r\n  const opREP = (opIndex, phraseIndex) => {\r\n    let astLength;\r\n    let repCharIndex;\r\n    let repPhrase;\r\n    let repCount;\r\n    const op = opcodes[opIndex];\r\n    if (op.max === 0) {\r\n      // this is an empty-string acceptor\r\n      // deprecated: use the TLS empty string operator, \"\", instead\r\n      sysData.state = id.EMPTY;\r\n      sysData.phraseLength = 0;\r\n      return;\r\n    }\r\n    repCharIndex = phraseIndex;\r\n    repPhrase = 0;\r\n    repCount = 0;\r\n    if (p.ast) {\r\n      astLength = p.ast.getLength();\r\n    }\r\n    while (1) {\r\n      if (repCharIndex >= chars.length) {\r\n        /* exit on end of input string */\r\n        break;\r\n      }\r\n      opExecute(opIndex + 1, repCharIndex);\r\n      if (sysData.state === id.NOMATCH) {\r\n        /* always end if the child node fails */\r\n        break;\r\n      }\r\n      if (sysData.state === id.EMPTY) {\r\n        /* REP always succeeds when the child node returns an empty phrase */\r\n        /* this may not seem obvious, but that's the way it works out */\r\n        break;\r\n      }\r\n      repCount += 1;\r\n      repPhrase += sysData.phraseLength;\r\n      repCharIndex += sysData.phraseLength;\r\n      if (repCount === op.max) {\r\n        /* end on maxed out reps */\r\n        break;\r\n      }\r\n    }\r\n    /* evaluate the match count according to the min, max values */\r\n    if (sysData.state === id.EMPTY) {\r\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\r\n      sysData.phraseLength = repPhrase;\r\n    } else if (repCount >= op.min) {\r\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\r\n      sysData.phraseLength = repPhrase;\r\n    } else {\r\n      sysData.state = id.NOMATCH;\r\n      sysData.phraseLength = 0;\r\n      if (p.ast) {\r\n        p.ast.setLength(astLength);\r\n      }\r\n    }\r\n  };\r\n  // Validate the callback function's returned sysData values.\r\n  // It's the user's responsibility to get them right\r\n  // but `RNM` fails if not.\r\n  const validateRnmCallbackResult = (rule, sysData, charsLeft, down) => {\r\n    if (sysData.phraseLength > charsLeft) {\r\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\r\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\r\n      str += ` must be <= remaining chars: ${charsLeft}`;\r\n      throw new Error(str);\r\n    }\r\n    switch (sysData.state) {\r\n      case id.ACTIVE:\r\n        if (!down) {\r\n          throw new Error(\r\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\r\n          );\r\n        }\r\n        break;\r\n      case id.EMPTY:\r\n        sysData.phraseLength = 0;\r\n        break;\r\n      case id.MATCH:\r\n        if (sysData.phraseLength === 0) {\r\n          sysData.state = id.EMPTY;\r\n        }\r\n        break;\r\n      case id.NOMATCH:\r\n        sysData.phraseLength = 0;\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\r\n        );\r\n    }\r\n  };\r\n  // The `RNM` operator.<br>\r\n  // This operator will acts as a root node for a parse tree branch below and\r\n  // returns the matched phrase to its parent.\r\n  // However, its larger responsibility is handling user-defined callback functions and `AST` nodes.\r\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\r\n  const opRNM = (opIndex, phraseIndex) => {\r\n    let astLength;\r\n    let astDefined;\r\n    let savedOpcodes;\r\n    const op = opcodes[opIndex];\r\n    const rule = rules[op.index];\r\n    const callback = ruleCallbacks[rule.index];\r\n    /* ignore AST in look ahead (AND or NOT operator above) */\r\n    if (!lookAhead) {\r\n      astDefined = p.ast && p.ast.ruleDefined(op.index);\r\n      if (astDefined) {\r\n        astLength = p.ast.getLength();\r\n        p.ast.down(op.index, rules[op.index].name);\r\n      }\r\n    }\r\n    if (callback) {\r\n      /* call user's callback going down the parse tree*/\r\n      const charsLeft = chars.length - phraseIndex;\r\n      callback(sysData, chars, phraseIndex, userData);\r\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\r\n      if (sysData.state === id.ACTIVE) {\r\n        savedOpcodes = opcodes;\r\n        opcodes = rule.opcodes;\r\n        opExecute(0, phraseIndex);\r\n        opcodes = savedOpcodes;\r\n        /* call user's callback going up the parse tree*/\r\n        callback(sysData, chars, phraseIndex, userData);\r\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\r\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\r\n    } else {\r\n      /* no callback - just execute the rule */\r\n      savedOpcodes = opcodes;\r\n      opcodes = rule.opcodes;\r\n      opExecute(0, phraseIndex, sysData);\r\n      opcodes = savedOpcodes;\r\n    }\r\n    if (!lookAhead) {\r\n      /* end AST */\r\n      if (astDefined) {\r\n        if (sysData.state === id.NOMATCH) {\r\n          p.ast.setLength(astLength);\r\n        } else {\r\n          p.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  // The `TRG` operator.<br>\r\n  // Succeeds if the single first character of the phrase is\r\n  // within the `min - max` range.\r\n  const opTRG = (opIndex, phraseIndex) => {\r\n    const op = opcodes[opIndex];\r\n    sysData.state = id.NOMATCH;\r\n    if (phraseIndex < chars.length) {\r\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\r\n        sysData.state = id.MATCH;\r\n        sysData.phraseLength = 1;\r\n      }\r\n    }\r\n  };\r\n  // The `TBS` operator.<br>\r\n  // Matches its pre-defined phrase against the input string.\r\n  // All characters must match exactly.\r\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\r\n  // operators by `apg`.\r\n  // Phrase length of zero is not allowed.\r\n  // Empty phrases can only be defined with `TLS` operators.\r\n  const opTBS = (opIndex, phraseIndex) => {\r\n    const op = opcodes[opIndex];\r\n    const len = op.string.length;\r\n    sysData.state = id.NOMATCH;\r\n    if (phraseIndex + len <= chars.length) {\r\n      for (let i = 0; i < len; i += 1) {\r\n        if (chars[phraseIndex + i] !== op.string[i]) {\r\n          return;\r\n        }\r\n      }\r\n      sysData.state = id.MATCH;\r\n      sysData.phraseLength = len;\r\n    } /* implied else NOMATCH */\r\n  };\r\n  // The `TLS` operator.<br>\r\n  // Matches its pre-defined phrase against the input string.\r\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\r\n  // `TLS` is the only operator that explicitly allows empty phrases.\r\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\r\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\r\n  const opTLS = (opIndex, phraseIndex) => {\r\n    let code;\r\n    const op = opcodes[opIndex];\r\n    sysData.state = id.NOMATCH;\r\n    const len = op.string.length;\r\n    if (len === 0) {\r\n      /* EMPTY match allowed for TLS */\r\n      sysData.state = id.EMPTY;\r\n      return;\r\n    }\r\n    if (phraseIndex + len <= chars.length) {\r\n      for (let i = 0; i < len; i += 1) {\r\n        code = chars[phraseIndex + i];\r\n        if (code >= 65 && code <= 90) {\r\n          code += 32;\r\n        }\r\n        if (code !== op.string[i]) {\r\n          return;\r\n        }\r\n      }\r\n      sysData.state = id.MATCH;\r\n      sysData.phraseLength = len;\r\n    } /* implied else NOMATCH */\r\n  };\r\n  // Validate the callback function's returned sysData values.\r\n  // It's the user's responsibility to get it right but `UDT` fails if not.\r\n  const validateUdtCallbackResult = (udt, sysData, charsLeft) => {\r\n    if (sysData.phraseLength > charsLeft) {\r\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\r\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\r\n      str += ` must be <= remaining chars: ${charsLeft}`;\r\n      throw new Error(str);\r\n    }\r\n    switch (sysData.state) {\r\n      case id.ACTIVE:\r\n        throw new Error(`${thisFileName}opUDT(${udt.name}) ACTIVE state return not allowed.`);\r\n      case id.EMPTY:\r\n        if (udt.empty) {\r\n          sysData.phraseLength = 0;\r\n        } else {\r\n          throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);\r\n        }\r\n        break;\r\n      case id.MATCH:\r\n        if (sysData.phraseLength === 0) {\r\n          if (udt.empty) {\r\n            sysData.state = id.EMPTY;\r\n          } else {\r\n            throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);\r\n          }\r\n        }\r\n        break;\r\n      case id.NOMATCH:\r\n        sysData.phraseLength = 0;\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\r\n        );\r\n    }\r\n  };\r\n  // The `UDT` operator.<br>\r\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\r\n  // and back referencing.\r\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\r\n  // for `AST` nodes and back referencing.\r\n  // See [`ast.js`](./ast.html) for usage.\r\n  const opUDT = (opIndex, phraseIndex) => {\r\n    let astLength;\r\n    let astIndex;\r\n    let astDefined;\r\n    const op = opcodes[opIndex];\r\n    const udt = udts[op.index];\r\n    sysData.UdtIndex = udt.index;\r\n    /* ignore AST in look ahead */\r\n    if (!lookAhead) {\r\n      astDefined = p.ast && p.ast.udtDefined(op.index);\r\n      if (astDefined) {\r\n        astIndex = rules.length + op.index;\r\n        astLength = p.ast.getLength();\r\n        p.ast.down(astIndex, udt.name);\r\n      }\r\n    }\r\n    /* call the UDT */\r\n    const charsLeft = chars.length - phraseIndex;\r\n    udtCallbacks[op.index](sysData, chars, phraseIndex, userData);\r\n    validateUdtCallbackResult(udt, sysData, charsLeft);\r\n    if (!lookAhead) {\r\n      /* end AST */\r\n      if (astDefined) {\r\n        if (sysData.state === id.NOMATCH) {\r\n          p.ast.setLength(astLength);\r\n        } else {\r\n          p.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  // The `AND` operator.<br>\r\n  // This is the positive `look ahead` operator.\r\n  // Executes its single child node, returning the EMPTY state\r\n  // if it succeedsand NOMATCH if it fails.\r\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\r\n  const opAND = (opIndex, phraseIndex) => {\r\n    lookAhead += 1;\r\n    opExecute(opIndex + 1, phraseIndex);\r\n    lookAhead -= 1;\r\n    sysData.phraseLength = 0;\r\n    switch (sysData.state) {\r\n      case id.EMPTY:\r\n        sysData.state = id.EMPTY;\r\n        break;\r\n      case id.MATCH:\r\n        sysData.state = id.EMPTY;\r\n        break;\r\n      case id.NOMATCH:\r\n        sysData.state = id.NOMATCH;\r\n        break;\r\n      default:\r\n        throw new Error(`opAND: invalid state ${sysData.state}`);\r\n    }\r\n  };\r\n  // The `NOT` operator.<br>\r\n  // This is the negative `look ahead` operator.\r\n  // Executes its single child node, returning the EMPTY state\r\n  // if it *fails* and NOMATCH if it succeeds.\r\n  // *Always* backtracks on any matched phrase and returns EMPTY\r\n  // on success (failure of its child node).\r\n  const opNOT = (opIndex, phraseIndex) => {\r\n    lookAhead += 1;\r\n    opExecute(opIndex + 1, phraseIndex);\r\n    lookAhead -= 1;\r\n    sysData.phraseLength = 0;\r\n    switch (sysData.state) {\r\n      case id.EMPTY:\r\n      case id.MATCH:\r\n        sysData.state = id.NOMATCH;\r\n        break;\r\n      case id.NOMATCH:\r\n        sysData.state = id.EMPTY;\r\n        break;\r\n      default:\r\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\r\n    }\r\n  };\r\n\r\n  const opExecute = (opIndex, phraseIndex) => {\r\n    const functionName = `${thisFileName}opExecute(): `;\r\n    const op = opcodes[opIndex];\r\n    nodeHits += 1;\r\n    if (treeDepth > maxTreeDepth) {\r\n      maxTreeDepth = treeDepth;\r\n    }\r\n    treeDepth += 1;\r\n    sysData.refresh();\r\n    if (p.trace) {\r\n      p.trace.down(op, phraseIndex);\r\n    }\r\n    switch (op.type) {\r\n      case id.ALT:\r\n        opALT(opIndex, phraseIndex);\r\n        break;\r\n      case id.CAT:\r\n        opCAT(opIndex, phraseIndex);\r\n        break;\r\n      case id.REP:\r\n        opREP(opIndex, phraseIndex);\r\n        break;\r\n      case id.RNM:\r\n        opRNM(opIndex, phraseIndex);\r\n        break;\r\n      case id.TRG:\r\n        opTRG(opIndex, phraseIndex);\r\n        break;\r\n      case id.TBS:\r\n        opTBS(opIndex, phraseIndex);\r\n        break;\r\n      case id.TLS:\r\n        opTLS(opIndex, phraseIndex);\r\n        break;\r\n      case id.UDT:\r\n        opUDT(opIndex, phraseIndex);\r\n        break;\r\n      case id.AND:\r\n        opAND(opIndex, phraseIndex);\r\n        break;\r\n      case id.NOT:\r\n        opNOT(opIndex, phraseIndex);\r\n        break;\r\n      default:\r\n        throw new Error(`${functionName}unrecognized operator`);\r\n    }\r\n    if (!lookAhead) {\r\n      if (phraseIndex + sysData.phraseLength > maxMatched) {\r\n        maxMatched = phraseIndex + sysData.phraseLength;\r\n      }\r\n    }\r\n    if (p.stats) {\r\n      p.stats.collect(op, sysData);\r\n    }\r\n    if (p.trace) {\r\n      p.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength);\r\n    }\r\n    treeDepth -= 1;\r\n  };\r\n};\r\n\r\nconst Ast = function fnast() {\r\n  const thisFileName = 'parser.js: Ast()): ';\r\n  const id = identifiers;\r\n  const utils = utilities;\r\n  const a = this;\r\n  let rules = undefined;\r\n  let udts = undefined;\r\n  let chars = undefined;\r\n  let nodeCount = 0;\r\n  const nodeCallbacks = [];\r\n  const stack = [];\r\n  const records = [];\r\n  a.callbacks = [];\r\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\r\n  a.init = (rulesIn, udtsIn, charsIn) => {\r\n    stack.length = 0;\r\n    records.length = 0;\r\n    nodeCount = 0;\r\n    rules = rulesIn;\r\n    udts = udtsIn;\r\n    chars = charsIn;\r\n    let i;\r\n    const list = [];\r\n    for (i = 0; i < rules.length; i += 1) {\r\n      list.push(rules[i].lower);\r\n    }\r\n    for (i = 0; i < udts.length; i += 1) {\r\n      list.push(udts[i].lower);\r\n    }\r\n    nodeCount = rules.length + udts.length;\r\n    for (i = 0; i < nodeCount; i += 1) {\r\n      nodeCallbacks[i] = undefined;\r\n    }\r\n    for (const index in a.callbacks) {\r\n      if (a.callbacks.hasOwnProperty(index)) {\r\n        const lower = index.toLowerCase();\r\n        i = list.indexOf(lower);\r\n        if (i < 0) {\r\n          throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\r\n        }\r\n        nodeCallbacks[i] = a.callbacks[index];\r\n      }\r\n    }\r\n  };\r\n  /* AST node rule callbacks - called by the parser's `RNM` operator */\r\n  a.ruleDefined = (index) => !!nodeCallbacks[index];\r\n  /* AST node UDT callbacks - called by the parser's `UDT` operator */\r\n  a.udtDefined = (index) => !!nodeCallbacks[rules.length + index];\r\n  /* called by the parser's `RNM` & `UDT` operators\r\n     builds a record for the downward traversal of the node */\r\n  a.down = (callbackIndex, name) => {\r\n    const thisIndex = records.length;\r\n    stack.push(thisIndex);\r\n    records.push({\r\n      name,\r\n      thisIndex,\r\n      thatIndex: undefined,\r\n      state: id.SEM_PRE,\r\n      callbackIndex,\r\n      phraseIndex: undefined,\r\n      phraseLength: undefined,\r\n      stack: stack.length,\r\n    });\r\n    return thisIndex;\r\n  };\r\n  /* called by the parser's `RNM` & `UDT` operators */\r\n  /* builds a record for the upward traversal of the node */\r\n  a.up = (callbackIndex, name, phraseIndex, phraseLength) => {\r\n    const thisIndex = records.length;\r\n    const thatIndex = stack.pop();\r\n    records.push({\r\n      name,\r\n      thisIndex,\r\n      thatIndex,\r\n      state: id.SEM_POST,\r\n      callbackIndex,\r\n      phraseIndex,\r\n      phraseLength,\r\n      stack: stack.length,\r\n    });\r\n    records[thatIndex].thatIndex = thisIndex;\r\n    records[thatIndex].phraseIndex = phraseIndex;\r\n    records[thatIndex].phraseLength = phraseLength;\r\n    return thisIndex;\r\n  };\r\n  // Called by the user to translate the AST.\r\n  // Translate means to associate or apply some semantic action to the\r\n  // phrases that were syntactically matched to the AST nodes according\r\n  // to the defining grammar.\r\n  // ```\r\n  // data - optional user-defined data\r\n  //        passed to the callback functions by the translator\r\n  // ```\r\n  a.translate = (data) => {\r\n    let ret;\r\n    let callback;\r\n    let record;\r\n    for (let i = 0; i < records.length; i += 1) {\r\n      record = records[i];\r\n      callback = nodeCallbacks[record.callbackIndex];\r\n      if (callback) {\r\n        if (record.state === id.SEM_PRE) {\r\n          callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\r\n        } else if (callback) {\r\n          callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  /* called by the parser to reset the length of the records array */\r\n  /* necessary on backtracking */\r\n  a.setLength = (length) => {\r\n    records.length = length;\r\n    if (length > 0) {\r\n      stack.length = records[length - 1].stack;\r\n    } else {\r\n      stack.length = 0;\r\n    }\r\n  };\r\n  /* called by the parser to get the length of the records array */\r\n  a.getLength = () => records.length;\r\n  /* helper for XML display */\r\n  function indent(n) {\r\n    let ret = '';\r\n    while (n-- > 0) {\r\n      ret += ' ';\r\n    }\r\n    return ret;\r\n  }\r\n  // Generate an `XML` version of the AST.\r\n  // Useful if you want to use a special or favorite XML parser to translate the\r\n  // AST. Node data are JavaScript strings.\r\n  a.toXml = () => {\r\n    let xml = '';\r\n    let depth = 0;\r\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\r\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\r\n    xml += `<!-- input string -->\\n`;\r\n    xml += indent(depth + 2);\r\n    xml += utils.charsToString(chars);\r\n    xml += '\\n';\r\n    records.forEach((rec) => {\r\n      if (rec.state === id.SEM_PRE) {\r\n        depth += 1;\r\n        xml += indent(depth);\r\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\r\n        xml += indent(depth + 2);\r\n        xml += utils.charsToString(chars, rec.phraseIndex, rec.phraseLength);\r\n        xml += '\\n';\r\n      } else {\r\n        xml += indent(depth);\r\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\r\n        depth -= 1;\r\n      }\r\n    });\r\n\r\n    xml += '</root>\\n';\r\n    return xml;\r\n  };\r\n};\r\n\r\nconst Trace = function fntrace() {\r\n  const id = identifiers;\r\n  const utils = utilities;\r\n  const thisFile = 'parser.js: Trace(): ';\r\n  let chars = undefined;\r\n  let rules = undefined;\r\n  let udts = undefined;\r\n  let out = '';\r\n  let treeDepth = 0;\r\n  const MAX_PHRASE = 100;\r\n  const t = this;\r\n  const indent = (n) => {\r\n    let ret = '';\r\n    let count = 0;\r\n    if (n >= 0) {\r\n      while (n--) {\r\n        count += 1;\r\n        if (count === 5) {\r\n          ret += '|';\r\n          count = 0;\r\n        } else {\r\n          ret += '.';\r\n        }\r\n      }\r\n    }\r\n    return ret;\r\n  };\r\n  t.init = (r, u, c) => {\r\n    rules = r;\r\n    udts = u;\r\n    chars = c;\r\n  };\r\n  const opName = (op) => {\r\n    let name;\r\n    switch (op.type) {\r\n      case id.ALT:\r\n        name = 'ALT';\r\n        break;\r\n      case id.CAT:\r\n        name = 'CAT';\r\n        break;\r\n      case id.REP:\r\n        if (op.max === Infinity) {\r\n          name = `REP(${op.min},inf)`;\r\n        } else {\r\n          name = `REP(${op.min},${op.max})`;\r\n        }\r\n        break;\r\n      case id.RNM:\r\n        name = `RNM(${rules[op.index].name})`;\r\n        break;\r\n      case id.TRG:\r\n        name = `TRG(${op.min},${op.max})`;\r\n        break;\r\n      case id.TBS:\r\n        if (op.string.length > 6) {\r\n          name = `TBS(${utils.charsToString(op.string, 0, 3)}...)`;\r\n        } else {\r\n          name = `TBS(${utils.charsToString(op.string, 0, 6)})`;\r\n        }\r\n        break;\r\n      case id.TLS:\r\n        if (op.string.length > 6) {\r\n          name = `TLS(${utils.charsToString(op.string, 0, 3)}...)`;\r\n        } else {\r\n          name = `TLS(${utils.charsToString(op.string, 0, 6)})`;\r\n        }\r\n        break;\r\n      case id.UDT:\r\n        name = `UDT(${udts[op.index].name})`;\r\n        break;\r\n      case id.AND:\r\n        name = 'AND';\r\n        break;\r\n      case id.NOT:\r\n        name = 'NOT';\r\n        break;\r\n      default:\r\n        throw new Error(`${thisFile}Trace: opName: unrecognized opcode`);\r\n    }\r\n    return name;\r\n  };\r\n  t.down = (op, offset) => {\r\n    const lead = indent(treeDepth);\r\n    const len = Math.min(MAX_PHRASE, chars.length - offset);\r\n    let phrase = utils.charsToString(chars, offset, len);\r\n    if (len < chars.length - offset) {\r\n      phrase += '...';\r\n    }\r\n    phrase = `${lead}|-|[${opName(op)}]${phrase}\\n`;\r\n    out += phrase;\r\n    treeDepth += 1;\r\n  };\r\n  t.up = (op, state, offset, phraseLength) => {\r\n    const thisFunc = `${thisFile}trace.up: `;\r\n    treeDepth -= 1;\r\n    const lead = indent(treeDepth);\r\n    let len;\r\n    let phrase;\r\n    let st;\r\n    switch (state) {\r\n      case id.EMPTY:\r\n        st = '|E|';\r\n        phrase = `''`;\r\n        break;\r\n      case id.MATCH:\r\n        st = '|M|';\r\n        len = Math.min(MAX_PHRASE, phraseLength);\r\n        if (len < phraseLength) {\r\n          phrase = `'${utils.charsToString(chars, offset, len)}...'`;\r\n        } else {\r\n          phrase = `'${utils.charsToString(chars, offset, len)}'`;\r\n        }\r\n        break;\r\n      case id.NOMATCH:\r\n        st = '|N|';\r\n        phrase = '';\r\n        break;\r\n      default:\r\n        throw new Error(`${thisFunc} unrecognized state`);\r\n    }\r\n    phrase = `${lead}${st}[${opName(op)}]${phrase}\\n`;\r\n    out += phrase;\r\n  };\r\n  t.displayTrace = () => out;\r\n};\r\n\r\nconst Stats = function fnstats() {\r\n  const id = identifiers;\r\n  const thisFileName = 'parser.js: Stats(): ';\r\n  let rules;\r\n  let udts;\r\n  let totals;\r\n  const stats = [];\r\n  const ruleStats = [];\r\n  const udtStats = [];\r\n  /* called by parser to initialize the stats */\r\n  this.init = (r, u) => {\r\n    rules = r;\r\n    udts = u;\r\n    clear();\r\n  };\r\n  /* This function is the main interaction with the parser. */\r\n  /* The parser calls it after each node has been traversed. */\r\n  this.collect = (op, sys) => {\r\n    incStat(totals, sys.state, sys.phraseLength);\r\n    incStat(stats[op.type], sys.state, sys.phraseLength);\r\n    if (op.type === id.RNM) {\r\n      incStat(ruleStats[op.index], sys.state, sys.phraseLength);\r\n    }\r\n    if (op.type === id.UDT) {\r\n      incStat(udtStats[op.index], sys.state, sys.phraseLength);\r\n    }\r\n  };\r\n  this.displayStats = () => {\r\n    let out = '';\r\n    const totals = {\r\n      match: 0,\r\n      empty: 0,\r\n      nomatch: 0,\r\n      total: 0,\r\n    };\r\n    const displayRow = (op, m, e, n, t) => {\r\n      totals.match += m;\r\n      totals.empty += e;\r\n      totals.nomatch += n;\r\n      totals.total += t;\r\n      const mm = normalize(m);\r\n      const ee = normalize(e);\r\n      const nn = normalize(n);\r\n      const tt = normalize(t);\r\n      return `${op} | ${mm} | ${ee} | ${nn} | ${tt} |\\n`;\r\n    };\r\n    out += '          OPERATOR STATS\\n';\r\n    out += '      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\\n';\r\n    out += displayRow('  ALT', stats[id.ALT].match, stats[id.ALT].empty, stats[id.ALT].nomatch, stats[id.ALT].total);\r\n    out += displayRow('  CAT', stats[id.CAT].match, stats[id.CAT].empty, stats[id.CAT].nomatch, stats[id.CAT].total);\r\n    out += displayRow('  REP', stats[id.REP].match, stats[id.REP].empty, stats[id.REP].nomatch, stats[id.REP].total);\r\n    out += displayRow('  RNM', stats[id.RNM].match, stats[id.RNM].empty, stats[id.RNM].nomatch, stats[id.RNM].total);\r\n    out += displayRow('  TRG', stats[id.TRG].match, stats[id.TRG].empty, stats[id.TRG].nomatch, stats[id.TRG].total);\r\n    out += displayRow('  TBS', stats[id.TBS].match, stats[id.TBS].empty, stats[id.TBS].nomatch, stats[id.TBS].total);\r\n    out += displayRow('  TLS', stats[id.TLS].match, stats[id.TLS].empty, stats[id.TLS].nomatch, stats[id.TLS].total);\r\n    out += displayRow('  UDT', stats[id.UDT].match, stats[id.UDT].empty, stats[id.UDT].nomatch, stats[id.UDT].total);\r\n    out += displayRow('  AND', stats[id.AND].match, stats[id.AND].empty, stats[id.AND].nomatch, stats[id.AND].total);\r\n    out += displayRow('  NOT', stats[id.NOT].match, stats[id.NOT].empty, stats[id.NOT].nomatch, stats[id.NOT].total);\r\n    out += displayRow('TOTAL', totals.match, totals.empty, totals.nomatch, totals.total);\r\n    return out;\r\n  };\r\n  /*\r\n  Display rule/udt\r\n  */\r\n  this.displayHits = (type) => {\r\n    let out = '';\r\n    const displayRow = (m, e, n, t, name) => {\r\n      totals.match += m;\r\n      totals.empty += e;\r\n      totals.nomatch += n;\r\n      totals.total += t;\r\n      const mm = normalize(m);\r\n      const ee = normalize(e);\r\n      const nn = normalize(n);\r\n      const tt = normalize(t);\r\n      return `| ${mm} | ${ee} | ${nn} | ${tt} | ${name}\\n`;\r\n    };\r\n    if (typeof type === 'string' && type.toLowerCase()[0] === 'a') {\r\n      ruleStats.sort(sortAlpha);\r\n      udtStats.sort(sortAlpha);\r\n      out += '    RULES/UDTS ALPHABETICALLY\\n';\r\n    } else if (typeof type === 'string' && type.toLowerCase()[0] === 'i') {\r\n      ruleStats.sort(sortIndex);\r\n      udtStats.sort(sortIndex);\r\n      out += '    RULES/UDTS BY INDEX\\n';\r\n    } else {\r\n      ruleStats.sort(sortHits);\r\n      udtStats.sort(sortHits);\r\n      out += '    RULES/UDTS BY HIT COUNT\\n';\r\n    }\r\n    out += '|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\\n';\r\n    for (let i = 0; i < ruleStats.length; i += 1) {\r\n      let r = ruleStats[i];\r\n      if (r.total) {\r\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\r\n      }\r\n    }\r\n    for (let i = 0; i < udtStats.length; i += 1) {\r\n      let r = udtStats[i];\r\n      if (r.total) {\r\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\r\n      }\r\n    }\r\n    return out;\r\n  };\r\n  const normalize = (n) => {\r\n    if (n < 10) {\r\n      return `      ${n}`;\r\n    }\r\n    if (n < 100) {\r\n      return `     ${n}`;\r\n    }\r\n    if (n < 1000) {\r\n      return `    ${n}`;\r\n    }\r\n    if (n < 10000) {\r\n      return `   ${n}`;\r\n    }\r\n    if (n < 100000) {\r\n      return `  ${n}`;\r\n    }\r\n    if (n < 1000000) {\r\n      return ` ${n}`;\r\n    }\r\n    return `${n}`;\r\n  };\r\n  const sortAlpha = (lhs, rhs) => {\r\n    if (lhs.lower < rhs.lower) {\r\n      return -1;\r\n    }\r\n    if (lhs.lower > rhs.lower) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  };\r\n  const sortHits = (lhs, rhs) => {\r\n    if (lhs.total < rhs.total) {\r\n      return 1;\r\n    }\r\n    if (lhs.total > rhs.total) {\r\n      return -1;\r\n    }\r\n    return sortAlpha(lhs, rhs);\r\n  };\r\n  const sortIndex = (lhs, rhs) => {\r\n    if (lhs.index < rhs.index) {\r\n      return -1;\r\n    }\r\n    if (lhs.index > rhs.index) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  };\r\n  const EmptyStat = function fnempty() {\r\n    this.empty = 0;\r\n    this.match = 0;\r\n    this.nomatch = 0;\r\n    this.total = 0;\r\n  };\r\n  /* Zero out all stats */\r\n  const clear = () => {\r\n    stats.length = 0;\r\n    totals = new EmptyStat();\r\n    stats[id.ALT] = new EmptyStat();\r\n    stats[id.CAT] = new EmptyStat();\r\n    stats[id.REP] = new EmptyStat();\r\n    stats[id.RNM] = new EmptyStat();\r\n    stats[id.TRG] = new EmptyStat();\r\n    stats[id.TBS] = new EmptyStat();\r\n    stats[id.TLS] = new EmptyStat();\r\n    stats[id.UDT] = new EmptyStat();\r\n    stats[id.AND] = new EmptyStat();\r\n    stats[id.NOT] = new EmptyStat();\r\n    ruleStats.length = 0;\r\n    for (let i = 0; i < rules.length; i += 1) {\r\n      ruleStats.push({\r\n        empty: 0,\r\n        match: 0,\r\n        nomatch: 0,\r\n        total: 0,\r\n        name: rules[i].name,\r\n        lower: rules[i].lower,\r\n        index: rules[i].index,\r\n      });\r\n    }\r\n    if (udts.length > 0) {\r\n      udtStats.length = 0;\r\n      for (let i = 0; i < udts.length; i += 1) {\r\n        udtStats.push({\r\n          empty: 0,\r\n          match: 0,\r\n          nomatch: 0,\r\n          total: 0,\r\n          name: udts[i].name,\r\n          lower: udts[i].lower,\r\n          index: udts[i].index,\r\n        });\r\n      }\r\n    }\r\n  };\r\n  /* increment the designated operator hit count by one */\r\n  const incStat = (stat, state) => {\r\n    stat.total += 1;\r\n    switch (state) {\r\n      case id.EMPTY:\r\n        stat.empty += 1;\r\n        break;\r\n      case id.MATCH:\r\n        stat.match += 1;\r\n        break;\r\n      case id.NOMATCH:\r\n        stat.nomatch += 1;\r\n        break;\r\n      default:\r\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\r\n    }\r\n  };\r\n};\r\n\r\nconst utilities = {\r\n  // utility functions\r\n  stringToChars: (string) => [...string].map((cp) => cp.codePointAt(0)),\r\n  charsToString: (chars, beg, len) => {\r\n    let subChars = chars;\r\n    while (1) {\r\n      if (beg === undefined || beg < 0) {\r\n        break;\r\n      }\r\n      if (len === undefined) {\r\n        subChars = chars.slice(beg);\r\n        break;\r\n      }\r\n      if (len <= 0) {\r\n        // always an empty string\r\n        return '';\r\n      }\r\n      subChars = chars.slice(beg, beg + len);\r\n      break;\r\n    }\r\n    return String.fromCodePoint(...subChars);\r\n  },\r\n};\r\n\r\nconst identifiers = {\r\n  // Identifies the operator type.\r\n  // NB: These must match the values in apg-js 4.3.0, apg-lib/identifiers.\r\n  /* the original ABNF operators */\r\n  ALT: 1 /* alternation */,\r\n  CAT: 2 /* concatenation */,\r\n  REP: 3 /* repetition */,\r\n  RNM: 4 /* rule name */,\r\n  TRG: 5 /* terminal range */,\r\n  TBS: 6 /* terminal binary string, case sensitive */,\r\n  TLS: 7 /* terminal literal string, case insensitive */,\r\n  /* the super set, SABNF operators */\r\n  UDT: 11 /* user-defined terminal */,\r\n  AND: 12 /* positive look ahead */,\r\n  NOT: 13 /* negative look ahead */,\r\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\r\n  // Identifies the parser state as it traverses the parse tree nodes.\r\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\r\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\r\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\r\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\r\n  ACTIVE: 100,\r\n  MATCH: 101,\r\n  EMPTY: 102,\r\n  NOMATCH: 103,\r\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\r\n  // to indicate the direction of flow through the `AST` nodes.\r\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\r\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\r\n  SEM_PRE: 200,\r\n  SEM_POST: 201,\r\n  // Ignored. Retained for backwords compatibility.\r\n  SEM_OK: 300,\r\n  idName: (s) => {\r\n    switch (s) {\r\n      case identifiers.ALT:\r\n        return 'ALT';\r\n      case identifiers.CAT:\r\n        return 'CAT';\r\n      case identifiers.REP:\r\n        return 'REP';\r\n      case identifiers.RNM:\r\n        return 'RNM';\r\n      case identifiers.TRG:\r\n        return 'TRG';\r\n      case identifiers.TBS:\r\n        return 'TBS';\r\n      case identifiers.TLS:\r\n        return 'TLS';\r\n      case identifiers.UDT:\r\n        return 'UDT';\r\n      case identifiers.AND:\r\n        return 'AND';\r\n      case identifiers.NOT:\r\n        return 'NOT';\r\n      case identifiers.ACTIVE:\r\n        return 'ACTIVE';\r\n      case identifiers.EMPTY:\r\n        return 'EMPTY';\r\n      case identifiers.MATCH:\r\n        return 'MATCH';\r\n      case identifiers.NOMATCH:\r\n        return 'NOMATCH';\r\n      case identifiers.SEM_PRE:\r\n        return 'SEM_PRE';\r\n      case identifiers.SEM_POST:\r\n        return 'SEM_POST';\r\n      case identifiers.SEM_OK:\r\n        return 'SEM_OK';\r\n      default:\r\n        return 'UNRECOGNIZED STATE';\r\n    }\r\n  },\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}