(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.apidomNsOpenapi31 = {}));
})(this, (function (exports) { 'use strict';

  /**
   * A function that always returns `false`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.T
   * @example
   *
   *      R.F(); //=> false
   */
  var F = function () {
    return false;
  };

  /**
   * A function that always returns `true`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.F
   * @example
   *
   *      R.T(); //=> true
   */
  var T = function () {
    return true;
  };

  function _isPlaceholder(a) {
    return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
  }

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  /**
   * Private `concat` function to merge two array-like objects.
   *
   * @private
   * @param {Array|Arguments} [set1=[]] An array-like object.
   * @param {Array|Arguments} [set2=[]] An array-like object.
   * @return {Array} A new, merged array.
   * @example
   *
   *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   */
  function _concat(set1, set2) {
    set1 = set1 || [];
    set2 = set2 || [];
    var idx;
    var len1 = set1.length;
    var len2 = set2.length;
    var result = [];
    idx = 0;
    while (idx < len1) {
      result[result.length] = set1[idx];
      idx += 1;
    }
    idx = 0;
    while (idx < len2) {
      result[result.length] = set2[idx];
      idx += 1;
    }
    return result;
  }

  function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };
      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };
      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };
      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };
      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };
      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };
      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };
      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };
      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };
      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };
      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };
      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  }

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;
      var hasPlaceholder = false;
      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;
        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }
        combined[combinedIdx] = result;
        if (!_isPlaceholder(result)) {
          left -= 1;
        } else {
          hasPlaceholder = true;
        }
        combinedIdx += 1;
      }
      return !hasPlaceholder && left <= 0 ? fn.apply(this, combined) : _arity(Math.max(0, left), _curryN(length, combined, fn));
    };
  }

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      const sumArgs = (...args) => R.sum(args);
   *
   *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */
  var curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }
    return _arity(length, _curryN(length, [], fn));
  });

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;
        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });
        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }

  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  const _isArray = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };

  function _isTransformer(obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function';
  }

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer created by [transducerCreator] to return a new transformer
   * (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} transducerCreator transducer factory if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!_isArray(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  function _reduced(x) {
    return x && x['@@transducer/reduced'] ? x : {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }

  const _xfBase = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };

  var XAll = /*#__PURE__*/function () {
    function XAll(f, xf) {
      this.xf = xf;
      this.f = f;
      this.all = true;
    }
    XAll.prototype['@@transducer/init'] = _xfBase.init;
    XAll.prototype['@@transducer/result'] = function (result) {
      if (this.all) {
        result = this.xf['@@transducer/step'](result, true);
      }
      return this.xf['@@transducer/result'](result);
    };
    XAll.prototype['@@transducer/step'] = function (result, input) {
      if (!this.f(input)) {
        this.all = false;
        result = _reduced(this.xf['@@transducer/step'](result, false));
      }
      return result;
    };
    return XAll;
  }();
  function _xall(f) {
    return function (xf) {
      return new XAll(f, xf);
    };
  }

  /**
   * Returns `true` if all elements of the list match the predicate, `false` if
   * there are any that don't.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
   *         otherwise.
   * @see R.any, R.none, R.transduce
   * @example
   *
   *      const equals3 = R.equals(3);
   *      R.all(equals3)([3, 3, 3, 3]); //=> true
   *      R.all(equals3)([3, 3, 1, 3]); //=> false
   */
  var all = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['all'], _xall, function all(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (!fn(list[idx])) {
        return false;
      }
      idx += 1;
    }
    return true;
  }));

  function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  }

  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }

  function _functionName(f) {
    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var match = String(f).match(/^function (\w*)/);
    return match == null ? '' : match[1];
  }

  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  function _objectIs(a, b) {
    // SameValue algorithm
    if (a === b) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return a !== 0 || 1 / a === 1 / b;
    } else {
      // Step 6.a: NaN == NaN
      return a !== a && b !== b;
    }
  }
  const _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

  var toString$2 = Object.prototype.toString;
  var _isArguments = /*#__PURE__*/function () {
    return toString$2.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString$2.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  }();

  // cover IE < 9 keys issues
  var hasEnumBug = ! /*#__PURE__*/{
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = /*#__PURE__*/function () {

    return arguments.propertyIsEnumerable('length');
  }();
  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @see R.keysIn, R.values, R.toPairs
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */
  var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? /*#__PURE__*/_curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /*#__PURE__*/_curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });

  /**
   * Gives a single-word string description of the (native) type of a value,
   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
   * attempt to distinguish user Object types any further, reporting them all as
   * 'Object'.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Type
   * @sig * -> String
   * @param {*} val The value to test
   * @return {String}
   * @example
   *
   *      R.type({}); //=> "Object"
   *      R.type(1); //=> "Number"
   *      R.type(false); //=> "Boolean"
   *      R.type('s'); //=> "String"
   *      R.type(null); //=> "Null"
   *      R.type([]); //=> "Array"
   *      R.type(/[A-z]/); //=> "RegExp"
   *      R.type(() => {}); //=> "Function"
   *      R.type(async () => {}); //=> "AsyncFunction"
   *      R.type(undefined); //=> "Undefined"
   *      R.type(BigInt(123)); //=> "BigInt"
   */
  var type = /*#__PURE__*/_curry1(function type(val) {
    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
  });

  /**
   * private _uniqContentEquals function.
   * That function is checking equality of 2 iterator contents with 2 assumptions
   * - iterators lengths are the same
   * - iterators values are unique
   *
   * false-positive result will be returned for comparison of, e.g.
   * - [1,2,3] and [1,2,3,4]
   * - [1,1,1] and [1,2,3]
   * */

  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);
    function eq(_a, _b) {
      return _equals(_a, _b, stackA.slice(), stackB.slice());
    }

    // if *a* array contains any element that is not included in *b*
    return !_includesWith(function (b, aItem) {
      return !_includesWith(eq, aItem, b);
    }, b, a);
  }
  function _equals(a, b, stackA, stackB) {
    if (_objectIs$1(a, b)) {
      return true;
    }
    var typeA = type(a);
    if (typeA !== type(b)) {
      return false;
    }
    if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
      return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
    }
    if (typeof a.equals === 'function' || typeof b.equals === 'function') {
      return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
    }
    switch (typeA) {
      case 'Arguments':
      case 'Array':
      case 'Object':
        if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
          return a === b;
        }
        break;
      case 'Boolean':
      case 'Number':
      case 'String':
        if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case 'Date':
        if (!_objectIs$1(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case 'Error':
        return a.name === b.name && a.message === b.message;
      case 'RegExp':
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }
    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }
    switch (typeA) {
      case 'Map':
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case 'Set':
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case 'Arguments':
      case 'Array':
      case 'Object':
      case 'Boolean':
      case 'Number':
      case 'String':
      case 'Date':
      case 'Error':
      case 'RegExp':
      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'ArrayBuffer':
        break;
      default:
        // Values of other types are only equal if identical.
        return false;
    }
    var keysA = keys(a);
    if (keysA.length !== keys(b).length) {
      return false;
    }
    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }

  /**
   * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
   * cyclical data structures.
   *
   * Dispatches symmetrically to the `equals` methods of both arguments, if
   * present.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> b -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      R.equals(1, 1); //=> true
   *      R.equals(1, '1'); //=> false
   *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
   *
   *      const a = {}; a.v = a;
   *      const b = {}; b.v = b;
   *      R.equals(a, b); //=> true
   */
  var equals = /*#__PURE__*/_curry2(function equals(a, b) {
    return _equals(a, b, [], []);
  });

  function _indexOf(list, a, idx) {
    var inf, item;
    // Array.prototype.indexOf doesn't exist below IE9
    if (typeof list.indexOf === 'function') {
      switch (typeof a) {
        case 'number':
          if (a === 0) {
            // manually crawl the list to distinguish between +0 and -0
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            // NaN
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === 'number' && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          // non-zero numbers can utilise Set
          return list.indexOf(a, idx);

        // all these types can utilise Set
        case 'string':
        case 'boolean':
        case 'function':
        case 'undefined':
          return list.indexOf(a, idx);
        case 'object':
          if (a === null) {
            // null can utilise Set
            return list.indexOf(a, idx);
          }
      }
    }
    // anything else not covered above, defer to R.equals
    while (idx < list.length) {
      if (equals(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }

  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);
    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }
    return result;
  }

  function _quote(s) {
    var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
    return '"' + escaped.replace(/"/g, '\\"') + '"';
  }

  /**
   * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
   */
  var pad = function pad(n) {
    return (n < 10 ? '0' : '') + n;
  };
  var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
    return d.toISOString();
  } : function _toISOString(d) {
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
  };

  function _complement(f) {
    return function () {
      return !f.apply(this, arguments);
    };
  }

  function _arrayReduce(reducer, acc, list) {
    var index = 0;
    var length = list.length;
    while (index < length) {
      acc = reducer(acc, list[index]);
      index += 1;
    }
    return acc;
  }

  function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  }

  function _isObject(x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  }

  var XFilter = /*#__PURE__*/function () {
    function XFilter(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XFilter.prototype['@@transducer/init'] = _xfBase.init;
    XFilter.prototype['@@transducer/result'] = _xfBase.result;
    XFilter.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
    };
    return XFilter;
  }();
  function _xfilter(f) {
    return function (xf) {
      return new XFilter(f, xf);
    };
  }

  /**
   * Takes a predicate and a `Filterable`, and returns a new filterable of the
   * same type containing the members of the given filterable which satisfy the
   * given predicate. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * Dispatches to the `filter` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @category Object
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array} Filterable
   * @see R.reject, R.transduce, R.addIndex
   * @example
   *
   *      const isEven = n => n % 2 === 0;
   *
   *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */
  var filter = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/filter', 'filter'], _xfilter, function (pred, filterable) {
    return _isObject(filterable) ? _arrayReduce(function (acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }
      return acc;
    }, {}, keys(filterable)) :
    // else
    _filter(pred, filterable);
  }));

  /**
   * The complement of [`filter`](#filter).
   *
   * Acts as a transducer if a transformer is given in list position. Filterable
   * objects include plain objects or any object that has a filter method such
   * as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array}
   * @see R.filter, R.transduce, R.addIndex
   * @example
   *
   *      const isOdd = (n) => n % 2 !== 0;
   *
   *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */
  var reject = /*#__PURE__*/_curry2(function reject(pred, filterable) {
    return filter(_complement(pred), filterable);
  });

  function _toString(x, seen) {
    var recur = function recur(y) {
      var xs = seen.concat([x]);
      return _includes(y, xs) ? '<Circular>' : _toString(y, xs);
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var mapPairs = function (obj, keys) {
      return _map(function (k) {
        return _quote(k) + ': ' + recur(obj[k]);
      }, keys.slice().sort());
    };
    switch (Object.prototype.toString.call(x)) {
      case '[object Arguments]':
        return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
      case '[object Array]':
        return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
          return /^\d+$/.test(k);
        }, keys(x)))).join(', ') + ']';
      case '[object Boolean]':
        return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
      case '[object Date]':
        return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
      case '[object Map]':
        return 'new Map(' + recur(Array.from(x)) + ')';
      case '[object Null]':
        return 'null';
      case '[object Number]':
        return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
      case '[object Set]':
        return 'new Set(' + recur(Array.from(x).sort()) + ')';
      case '[object String]':
        return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
      case '[object Undefined]':
        return 'undefined';
      default:
        if (typeof x.toString === 'function') {
          var repr = x.toString();
          if (repr !== '[object Object]') {
            return repr;
          }
        }
        return '{' + mapPairs(x, keys(x)).join(', ') + '}';
    }
  }

  /**
   * Returns the string representation of the given value. `eval`'ing the output
   * should result in a value equivalent to the input value. Many of the built-in
   * `toString` methods do not satisfy this requirement.
   *
   * If the given value is an `[object Object]` with a `toString` method other
   * than `Object.prototype.toString`, this method is invoked with no arguments
   * to produce the return value. This means user-defined constructor functions
   * can provide a suitable `toString` method. For example:
   *
   *     function Point(x, y) {
   *       this.x = x;
   *       this.y = y;
   *     }
   *
   *     Point.prototype.toString = function() {
   *       return 'new Point(' + this.x + ', ' + this.y + ')';
   *     };
   *
   *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category String
   * @sig * -> String
   * @param {*} val
   * @return {String}
   * @example
   *
   *      R.toString(42); //=> '42'
   *      R.toString('abc'); //=> '"abc"'
   *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
   *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
   *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
   */
  var toString$1 = /*#__PURE__*/_curry1(function toString(val) {
    return _toString(val, []);
  });

  /**
   * Returns the larger of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.maxBy, R.min
   * @example
   *
   *      R.max(789, 123); //=> 789
   *      R.max('a', 'b'); //=> 'b'
   */
  var max = /*#__PURE__*/_curry2(function max(a, b) {
    if (a === b) {
      return b;
    }
    function safeMax(x, y) {
      if (x > y !== y > x) {
        return y > x ? y : x;
      }
      return undefined;
    }
    var maxByValue = safeMax(a, b);
    if (maxByValue !== undefined) {
      return maxByValue;
    }
    var maxByType = safeMax(typeof a, typeof b);
    if (maxByType !== undefined) {
      return maxByType === typeof a ? a : b;
    }
    var stringA = toString$1(a);
    var maxByStringValue = safeMax(stringA, toString$1(b));
    if (maxByStringValue !== undefined) {
      return maxByStringValue === stringA ? a : b;
    }
    return b;
  });

  var XMap = /*#__PURE__*/function () {
    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;
    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };
    return XMap;
  }();
  var _xmap = function _xmap(f) {
    return function (xf) {
      return new XMap(f, xf);
    };
  };

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex, R.pluck, R.project
   * @example
   *
   *      const double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */
  var map = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });
      case '[object Object]':
        return _arrayReduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));
      default:
        return _map(fn, functor);
    }
  }));

  /**
   * Determine if the passed argument is an integer.
   *
   * @private
   * @param {*} n
   * @category Type
   * @return {Boolean}
   */
  const _isInteger = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };

  function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  }

  function _nth(offset, list) {
    var idx = offset < 0 ? list.length + offset : offset;
    return _isString(list) ? list.charAt(idx) : list[idx];
  }

  /**
   * Returns a function that when supplied an object returns the indicated
   * property of that object, if it exists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx -> {s: a} -> a | Undefined
   * @param {String|Number} p The property name or array index
   * @param {Object} obj The object to query
   * @return {*} The value at `obj.p`.
   * @see R.path, R.props, R.pluck, R.project, R.nth
   * @example
   *
   *      R.prop('x', {x: 100}); //=> 100
   *      R.prop('x', {}); //=> undefined
   *      R.prop(0, [100]); //=> 100
   *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
   */

  var prop = /*#__PURE__*/_curry2(function prop(p, obj) {
    if (obj == null) {
      return;
    }
    return _isInteger(p) ? _nth(p, obj) : obj[p];
  });

  /**
   * Returns a new list by plucking the same named property off all objects in
   * the list supplied.
   *
   * `pluck` will work on
   * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
   * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => k -> f {k: v} -> f v
   * @param {Number|String} key The key name to pluck off of each object.
   * @param {Array} f The array or functor to consider.
   * @return {Array} The list of values for the given key.
   * @see R.project, R.prop, R.props
   * @example
   *
   *      var getAges = R.pluck('age');
   *      getAges([{name: 'fred', age: 29}, {name: 'wilma', age: 27}]); //=> [29, 27]
   *
   *      R.pluck(0, [[1, 2], [3, 4]]);               //=> [1, 3]
   *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
   * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
   * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
   */
  var pluck = /*#__PURE__*/_curry2(function pluck(p, list) {
    return map(prop(p), list);
  });

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @private
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @example
   *
   *      _isArrayLike([]); //=> true
   *      _isArrayLike(true); //=> false
   *      _isArrayLike({}); //=> false
   *      _isArrayLike({length: 10}); //=> false
   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   *      _isArrayLike({nodeType: 1, length: 1}) // => false
   */
  var _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }
    if (!x) {
      return false;
    }
    if (typeof x !== 'object') {
      return false;
    }
    if (_isString(x)) {
      return false;
    }
    if (x.length === 0) {
      return true;
    }
    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }
    return false;
  });

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
  function _createReduce(arrayReduce, methodReduce, iterableReduce) {
    return function _reduce(xf, acc, list) {
      if (_isArrayLike(list)) {
        return arrayReduce(xf, acc, list);
      }
      if (list == null) {
        return acc;
      }
      if (typeof list['fantasy-land/reduce'] === 'function') {
        return methodReduce(xf, acc, list, 'fantasy-land/reduce');
      }
      if (list[symIterator] != null) {
        return iterableReduce(xf, acc, list[symIterator]());
      }
      if (typeof list.next === 'function') {
        return iterableReduce(xf, acc, list);
      }
      if (typeof list.reduce === 'function') {
        return methodReduce(xf, acc, list, 'reduce');
      }
      throw new TypeError('reduce: list must be array or iterable');
    };
  }

  function _xArrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      const log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */
  var bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });

  function _xIterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }
  function _xMethodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }
  var _xReduce = /*#__PURE__*/_createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);

  var XWrap = /*#__PURE__*/function () {
    function XWrap(fn) {
      this.f = fn;
    }
    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };
    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };
    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };
    return XWrap;
  }();
  function _xwrap(fn) {
    return new XWrap(fn);
  }

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to shortcut the iteration.
   *
   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
   * is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Be cautious of mutating and returning the accumulator. If you reuse it across
   * invocations, it will continue to accumulate onto the same value. The general
   * recommendation is to always return a new value. If you can't do so for
   * performance reasons, then be sure to reinitialize the accumulator on each
   * invocation.
   *
   * Dispatches to the `reduce` method of the third argument, if present. When
   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
   * shortcuting, as this is not implemented by `reduce`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *      //          -               -10
   *      //         / \              / \
   *      //        -   4           -6   4
   *      //       / \              / \
   *      //      -   3   ==>     -3   3
   *      //     / \              / \
   *      //    -   2           -1   2
   *      //   / \              / \
   *      //  0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */
  var reduce = /*#__PURE__*/_curry3(function (xf, acc, list) {
    return _xReduce(typeof xf === 'function' ? _xwrap(xf) : xf, acc, list);
  });

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if every one of the provided predicates is satisfied
   * by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.anyPass, R.both
   * @example
   *
   *      const isQueen = R.propEq('Q', 'rank');
   *      const isSpade = R.propEq('♠︎', 'suit');
   *      const isQueenOfSpades = R.allPass([isQueen, isSpade]);
   *
   *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
   *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
   */
  var allPass = /*#__PURE__*/_curry1(function allPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;
      while (idx < len) {
        if (!preds[idx].apply(this, arguments)) {
          return false;
        }
        idx += 1;
      }
      return true;
    });
  });

  /**
   * Returns a function that always returns the given value. Note that for
   * non-primitives the value returned is a reference to the original value.
   *
   * This function is known as `const`, `constant`, or `K` (for K combinator) in
   * other languages and libraries.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> (* -> a)
   * @param {*} val The value to wrap in a function
   * @return {Function} A Function :: * -> val.
   * @example
   *
   *      const t = R.always('Tee');
   *      t(); //=> 'Tee'
   */
  var always = /*#__PURE__*/_curry1(function always(val) {
    return function () {
      return val;
    };
  });

  /**
   * Returns the first argument if it is falsy, otherwise the second argument.
   * Acts as the boolean `and` statement if both inputs are `Boolean`s.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any}
   * @see R.both, R.or
   * @example
   *
   *      R.and(true, true); //=> true
   *      R.and(true, false); //=> false
   *      R.and(false, true); //=> false
   *      R.and(false, false); //=> false
   */
  var and = /*#__PURE__*/_curry2(function and(a, b) {
    return a && b;
  });

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if at least one of the provided predicates is
   * satisfied by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.allPass, R.either
   * @example
   *
   *      const isClub = R.propEq('♣', 'suit');
   *      const isSpade = R.propEq('♠', 'suit');
   *      const isBlackCard = R.anyPass([isClub, isSpade]);
   *
   *      isBlackCard({rank: '10', suit: '♣'}); //=> true
   *      isBlackCard({rank: 'Q', suit: '♠'}); //=> true
   *      isBlackCard({rank: 'Q', suit: '♦'}); //=> false
   */
  var anyPass = /*#__PURE__*/_curry1(function anyPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;
      while (idx < len) {
        if (preds[idx].apply(this, arguments)) {
          return true;
        }
        idx += 1;
      }
      return false;
    });
  });

  function _iterableReduce(reducer, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = reducer(acc, step.value);
      step = iter.next();
    }
    return acc;
  }
  function _methodReduce(reducer, acc, obj, methodName) {
    return obj[methodName](reducer, acc);
  }
  var _reduce = /*#__PURE__*/_createReduce(_arrayReduce, _methodReduce, _iterableReduce);

  /**
   * ap applies a list of functions to a list of values.
   *
   * Dispatches to the `ap` method of the first argument, if present. Also
   * treats curried functions as applicatives.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig [a -> b] -> [a] -> [b]
   * @sig Apply f => f (a -> b) -> f a -> f b
   * @sig (r -> a -> b) -> (r -> a) -> (r -> b)
   * @param {*} applyF
   * @param {*} applyX
   * @return {*}
   * @example
   *
   *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
   *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
   *
   *      // R.ap can also be used as S combinator
   *      // when only two functions are passed
   *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
   * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
   */
  var ap = /*#__PURE__*/_curry2(function ap(applyF, applyX) {
    return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
      return applyF(x)(applyX(x));
    } : _reduce(function (acc, f) {
      return _concat(acc, map(f, applyX));
    }, [], applyF);
  });

  /**
   * Applies function `fn` to the argument list `args`. This is useful for
   * creating a fixed-arity function from a variadic function. `fn` should be a
   * bound function if context is significant.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> a) -> [*] -> a
   * @param {Function} fn The function which will be called with `args`
   * @param {Array} args The arguments to call `fn` with
   * @return {*} result The result, equivalent to `fn(...args)`
   * @see R.call, R.unapply
   * @example
   *
   *      const nums = [1, 2, 3, -99, 42, 6, 7];
   *      R.apply(Math.max, nums); //=> 42
   * @symb R.apply(f, [a, b, c]) = f(a, b, c)
   */
  var apply = /*#__PURE__*/_curry2(function apply(fn, args) {
    return fn.apply(this, args);
  });

  /**
   * Returns a curried equivalent of the provided function. The curried function
   * has two unusual capabilities. First, its arguments needn't be provided one
   * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * Please note that default parameters don't count towards a [function arity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length)
   * and therefore `curry` won't work well with those.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> a) -> (* -> a)
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curryN, R.partial
   * @example
   *
   *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
   *      const curriedAddFourNumbers = R.curry(addFourNumbers);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   *
   *      // R.curry not working well with default parameters
   *      const h = R.curry((a, b, c = 2) => a + b + c);
   *      h(1)(2)(7); //=> Error! (`3` is not a function!)
   */
  var curry = /*#__PURE__*/_curry1(function curry(fn) {
    return curryN(fn.length, fn);
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @private
   * @param {String|Number} prop The property name to set
   * @param {*} val The new value
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original except for the changed property.
   */
  function _assoc(prop, val, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[prop] = val;
      return arr;
    }
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    result[prop] = val;
    return result;
  }

  /**
   * Checks if the input value is `null` or `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Type
   * @sig * -> Boolean
   * @param {*} x The value to test.
   * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
   * @example
   *
   *      R.isNil(null); //=> true
   *      R.isNil(undefined); //=> true
   *      R.isNil(0); //=> false
   *      R.isNil([]); //=> false
   */
  var isNil = /*#__PURE__*/_curry1(function isNil(x) {
    return x == null;
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the nodes required
   * to create the given path, and placing the specific value at the tail end of
   * that path. Note that this copies and flattens prototype properties onto the
   * new object as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> a -> {a} -> {a}
   * @param {Array} path the path to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except along the specified path.
   * @see R.dissocPath
   * @example
   *
   *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
   *
   *      // Any missing or non-object keys in path will be overridden
   *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
   */
  var assocPath = /*#__PURE__*/_curry3(function assocPath(path, val, obj) {
    if (path.length === 0) {
      return val;
    }
    var idx = path[0];
    if (path.length > 1) {
      var nextObj = !isNil(obj) && _has(idx, obj) && typeof obj[idx] === 'object' ? obj[idx] : _isInteger(path[1]) ? [] : {};
      val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
    }
    return _assoc(idx, val, obj);
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig Idx -> a -> {k: v} -> {k: v}
   * @param {String|Number} prop The property name to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except for the changed property.
   * @see R.dissoc, R.pick
   * @example
   *
   *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
   */
  var assoc = /*#__PURE__*/_curry3(function assoc(prop, val, obj) {
    return assocPath([prop], val, obj);
  });

  function _isFunction(x) {
    var type = Object.prototype.toString.call(x);
    return type === '[object Function]' || type === '[object AsyncFunction]' || type === '[object GeneratorFunction]' || type === '[object AsyncGeneratorFunction]';
  }

  /**
   * "lifts" a function to be the specified arity, so that it may "map over" that
   * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig Number -> (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.lift, R.ap
   * @example
   *
   *      const madd3 = R.liftN(3, (...args) => R.sum(args));
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   */
  var liftN = /*#__PURE__*/_curry2(function liftN(arity, fn) {
    var lifted = curryN(arity, fn);
    return curryN(arity, function () {
      return _arrayReduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
    });
  });

  /**
   * "lifts" a function of arity >= 1 so that it may "map over" a list, Function or other
   * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.liftN
   * @example
   *
   *      const madd3 = R.lift((a, b, c) => a + b + c);
   *
   *      madd3([100, 200], [30, 40], [5, 6, 7]); //=> [135, 136, 137, 145, 146, 147, 235, 236, 237, 245, 246, 247]
   *
   *      const madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
   *
   *      madd5([10, 20], [1], [2, 3], [4], [100, 200]); //=> [117, 217, 118, 218, 127, 227, 128, 228]
   */
  var lift = /*#__PURE__*/_curry1(function lift(fn) {
    return liftN(fn.length, fn);
  });

  /**
   * A function which calls the two provided functions and returns the `&&`
   * of the results.
   * It returns the result of the first function if it is false-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * false-y value.
   *
   * In addition to functions, `R.both` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f A predicate
   * @param {Function} g Another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
   * @see R.either, R.allPass, R.and
   * @example
   *
   *      const gt10 = R.gt(R.__, 10)
   *      const lt20 = R.lt(R.__, 20)
   *      const f = R.both(gt10, lt20);
   *      f(15); //=> true
   *      f(30); //=> false
   *
   *      R.both(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(false)
   *      R.both([false, false, 'a'], [11]); //=> [false, false, 11]
   */
  var both = /*#__PURE__*/_curry2(function both(f, g) {
    return _isFunction(f) ? function _both() {
      return f.apply(this, arguments) && g.apply(this, arguments);
    } : lift(and)(f, g);
  });

  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : '') + (pattern.dotAll ? 's' : ''));
  }

  /**
   * Copies an object.
   *
   * @private
   * @param {*} value The value to be copied
   * @param {Boolean} deep Whether or not to perform deep cloning.
   * @return {*} The copied value.
   */
  function _clone(value, deep, map) {
    map || (map = new _ObjectMap());

    // this avoids the slower switch with a quick if decision removing some milliseconds in each run.
    if (_isPrimitive(value)) {
      return value;
    }
    var copy = function copy(copiedValue) {
      // Check for circular and same references on the object graph and return its corresponding clone.
      var cachedCopy = map.get(value);
      if (cachedCopy) {
        return cachedCopy;
      }
      map.set(value, copiedValue);
      for (var key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          copiedValue[key] = value[key];
        }
      }
      return copiedValue;
    };
    switch (type(value)) {
      case 'Object':
        return copy(Object.create(Object.getPrototypeOf(value)));
      case 'Array':
        return copy(Array(value.length));
      case 'Date':
        return new Date(value.valueOf());
      case 'RegExp':
        return _cloneRegExp(value);
      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'BigInt64Array':
      case 'BigUint64Array':
        return value.slice();
      default:
        return value;
    }
  }
  function _isPrimitive(param) {
    var type = typeof param;
    return param == null || type != 'object' && type != 'function';
  }
  var _ObjectMap = /*#__PURE__*/function () {
    function _ObjectMap() {
      this.map = {};
      this.length = 0;
    }
    _ObjectMap.prototype.set = function (key, value) {
      var hashedKey = this.hash(key);
      var bucket = this.map[hashedKey];
      if (!bucket) {
        this.map[hashedKey] = bucket = [];
      }
      bucket.push([key, value]);
      this.length += 1;
    };
    _ObjectMap.prototype.hash = function (key) {
      var hashedKey = [];
      for (var value in key) {
        hashedKey.push(Object.prototype.toString.call(key[value]));
      }
      return hashedKey.join();
    };
    _ObjectMap.prototype.get = function (key) {
      /**
       * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,
       * on my tests this number is 180, anything above that using the hash function is faster.
       */
      if (this.length <= 180) {
        for (var p in this.map) {
          var bucket = this.map[p];
          for (var i = 0; i < bucket.length; i += 1) {
            var element = bucket[i];
            if (element[0] === key) {
              return element[1];
            }
          }
        }
        return;
      }
      var hashedKey = this.hash(key);
      var bucket = this.map[hashedKey];
      if (!bucket) {
        return;
      }
      for (var i = 0; i < bucket.length; i += 1) {
        var element = bucket[i];
        if (element[0] === key) {
          return element[1];
        }
      }
    };
    return _ObjectMap;
  }();

  /**
   * Makes a comparator function out of a function that reports whether the first
   * element is less than the second.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
   * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
   * is less than the second, `false` otherwise
   * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
   * @example
   *
   *      const byAge = R.comparator((a, b) => a.age < b.age);
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByIncreasingAge = R.sort(byAge, people);
   *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
   */
  var comparator = /*#__PURE__*/_curry1(function comparator(pred) {
    return function (a, b) {
      return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
    };
  });

  /**
   * A function that returns the `!` of its argument. It will return `true` when
   * passed false-y value, and `false` when passed a truth-y one.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig * -> Boolean
   * @param {*} a any value
   * @return {Boolean} the logical inverse of passed argument.
   * @see R.complement
   * @example
   *
   *      R.not(true); //=> false
   *      R.not(false); //=> true
   *      R.not(0); //=> true
   *      R.not(1); //=> false
   */
  var not = /*#__PURE__*/_curry1(function not(a) {
    return !a;
  });

  /**
   * Takes a function `f` and returns a function `g` such that if called with the same arguments
   * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
   *
   * `R.complement` may be applied to any functor
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> *) -> (*... -> Boolean)
   * @param {Function} f
   * @return {Function}
   * @see R.not
   * @example
   *
   *      const isNotNil = R.complement(R.isNil);
   *      R.isNil(null); //=> true
   *      isNotNil(null); //=> false
   *      R.isNil(7); //=> false
   *      isNotNil(7); //=> true
   */
  var complement = /*#__PURE__*/lift(not);

  function _pipe(f, g) {
    return function () {
      return g.call(this, f.apply(this, arguments));
    };
  }

  /**
   * This checks whether a function has a [methodname] function. If it isn't an
   * array it will execute that function otherwise it will default to the ramda
   * implementation.
   *
   * @private
   * @param {Function} fn ramda implementation
   * @param {String} methodname property to check for a custom implementation
   * @return {Object} Whatever the return value of the method is.
   */
  function _checkForMethod(methodname, fn) {
    return function () {
      var length = arguments.length;
      if (length === 0) {
        return fn();
      }
      var obj = arguments[length - 1];
      return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  }

  /**
   * Returns the elements of the given list or string (or object with a `slice`
   * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * Dispatches to the `slice` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @sig Number -> Number -> String -> String
   * @param {Number} fromIndex The start index (inclusive).
   * @param {Number} toIndex The end index (exclusive).
   * @param {*} list
   * @return {*}
   * @example
   *
   *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
   *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
   *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
   *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
   *      R.slice(0, 3, 'ramda');                     //=> 'ram'
   */
  var slice = /*#__PURE__*/_curry3( /*#__PURE__*/_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  }));

  /**
   * Returns all but the first element of the given list or string (or object
   * with a `tail` method).
   *
   * Dispatches to the `slice` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.head, R.init, R.last
   * @example
   *
   *      R.tail([1, 2, 3]);  //=> [2, 3]
   *      R.tail([1, 2]);     //=> [2]
   *      R.tail([1]);        //=> []
   *      R.tail([]);         //=> []
   *
   *      R.tail('abc');  //=> 'bc'
   *      R.tail('ab');   //=> 'b'
   *      R.tail('a');    //=> ''
   *      R.tail('');     //=> ''
   */
  var tail = /*#__PURE__*/_curry1( /*#__PURE__*/_checkForMethod('tail', /*#__PURE__*/slice(1, Infinity)));

  /**
   * Performs left-to-right function composition. The first argument may have
   * any arity; the remaining arguments must be unary.
   *
   * In some libraries this function is named `sequence`.
   *
   * **Note:** The result of pipe is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.compose
   * @example
   *
   *      const f = R.pipe(Math.pow, R.negate, R.inc);
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
   * @symb R.pipe(f, g, h)(a)(b) = h(g(f(a)))(b)
   */
  function pipe() {
    if (arguments.length === 0) {
      throw new Error('pipe requires at least one argument');
    }
    return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
  }

  /**
   * Returns the first element of the given list or string. In some libraries
   * this function is named `first`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String | Undefined
   * @param {Array|String} list
   * @return {*}
   * @see R.tail, R.init, R.last
   * @example
   *
   *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
   *      R.head([]); //=> undefined
   *
   *      R.head('abc'); //=> 'a'
   *      R.head(''); //=> undefined
   */
  var head = /*#__PURE__*/_curry1(function (list) {
    return _nth(0, list);
  });

  var XReduceBy = /*#__PURE__*/function () {
    function XReduceBy(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }
    XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
    XReduceBy.prototype['@@transducer/result'] = function (result) {
      var key;
      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf['@@transducer/step'](result, this.inputs[key]);
          if (result['@@transducer/reduced']) {
            result = result['@@transducer/value'];
            break;
          }
        }
      }
      this.inputs = null;
      return this.xf['@@transducer/result'](result);
    };
    XReduceBy.prototype['@@transducer/step'] = function (result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, _clone(this.valueAcc)];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };
    return XReduceBy;
  }();
  function _xreduceBy(valueFn, valueAcc, keyFn) {
    return function (xf) {
      return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    };
  }

  /**
   * Groups the elements of the list according to the result of calling
   * the String-returning function `keyFn` on each element and reduces the elements
   * of each group to a single value via the reducer function `valueFn`.
   *
   * The value function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to short circuit the iteration.
   *
   * This function is basically a more general [`groupBy`](#groupBy) function.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category List
   * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
   * @param {Function} valueFn The function that reduces the elements of each group to a single
   *        value. Receives two values, accumulator for a particular group and the current element.
   * @param {*} acc The (initial) accumulator value for each group.
   * @param {Function} keyFn The function that maps the list's element into a key.
   * @param {Array} list The array to group.
   * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
   *         `valueFn` for elements which produced that key when passed to `keyFn`.
   * @see R.groupBy, R.reduce, R.reduced
   * @example
   *
   *      const groupNames = (acc, {name}) => acc.concat(name)
   *      const toGrade = ({score}) =>
   *        score < 65 ? 'F' :
   *        score < 70 ? 'D' :
   *        score < 80 ? 'C' :
   *        score < 90 ? 'B' : 'A'
   *
   *      var students = [
   *        {name: 'Abby', score: 83},
   *        {name: 'Bart', score: 62},
   *        {name: 'Curt', score: 88},
   *        {name: 'Dora', score: 92},
   *      ]
   *
   *      reduceBy(groupNames, [], toGrade, students)
   *      //=> {"A": ["Dora"], "B": ["Abby", "Curt"], "F": ["Bart"]}
   */
  var reduceBy = /*#__PURE__*/_curryN(4, [], /*#__PURE__*/_dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
    var xf = _xwrap(function (acc, elt) {
      var key = keyFn(elt);
      var value = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc), elt);
      if (value && value['@@transducer/reduced']) {
        return _reduced(acc);
      }
      acc[key] = value;
      return acc;
    });
    return _xReduce(xf, {}, list);
  }));

  /**
   * Returns the second argument if it is not `null`, `undefined` or `NaN`;
   * otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {a} default The default value.
   * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
   * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
   * @example
   *
   *      const defaultTo42 = R.defaultTo(42);
   *
   *      defaultTo42(null);  //=> 42
   *      defaultTo42(undefined);  //=> 42
   *      defaultTo42(false);  //=> false
   *      defaultTo42('Ramda');  //=> 'Ramda'
   *      // parseInt('string') results in NaN
   *      defaultTo42(parseInt('string')); //=> 42
   */
  var defaultTo = /*#__PURE__*/_curry2(function defaultTo(d, v) {
    return v == null || v !== v ? d : v;
  });

  var _Set$1 = /*#__PURE__*/function () {
    function _Set() {
      /* globals Set */
      this._nativeSet = typeof Set === 'function' ? new Set() : null;
      this._items = {};
    }
    // until we figure out why jsdoc chokes on this
    // @param item The item to add to the Set
    // @returns {boolean} true if the item did not exist prior, otherwise false
    //
    _Set.prototype.add = function (item) {
      return !hasOrAdd(item, true, this);
    };

    //
    // @param item The item to check for existence in the Set
    // @returns {boolean} true if the item exists in the Set, otherwise false
    //
    _Set.prototype.has = function (item) {
      return hasOrAdd(item, false, this);
    };

    //
    // Combines the logic for checking whether an item is a member of the set and
    // for adding a new item to the set.
    //
    // @param item       The item to check or add to the Set instance.
    // @param shouldAdd  If true, the item will be added to the set if it doesn't
    //                   already exist.
    // @param set        The set instance to check or add to.
    // @return {boolean} true if the item already existed, otherwise false.
    //
    return _Set;
  }();
  function hasOrAdd(item, shouldAdd, set) {
    var type = typeof item;
    var prevSize, newSize;
    switch (type) {
      case 'string':
      case 'number':
        // distinguish between +0 and -0
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items['-0']) {
            return true;
          } else {
            if (shouldAdd) {
              set._items['-0'] = true;
            }
            return false;
          }
        }
        // these types can all utilise the native Set
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = {};
              set._items[type][item] = true;
            }
            return false;
          } else if (item in set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][item] = true;
            }
            return false;
          }
        }
      case 'boolean':
        // set._items['boolean'] holds a two element array
        // representing [ falseExists, trueExists ]
        if (type in set._items) {
          var bIdx = item ? 1 : 0;
          if (set._items[type][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type] = item ? [false, true] : [true, false];
          }
          return false;
        }
      case 'function':
        // compare functions for reference equality
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }
            return false;
          }
          if (!_includes(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }
            return false;
          }
          return true;
        }
      case 'undefined':
        if (set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type] = true;
          }
          return false;
        }
      case 'object':
        if (item === null) {
          if (!set._items['null']) {
            if (shouldAdd) {
              set._items['null'] = true;
            }
            return false;
          }
          return true;
        }
      /* falls through */
      default:
        // reduce the search size of heterogeneous sets by creating buckets
        // for each type.
        type = Object.prototype.toString.call(item);
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }
          return false;
        }
        // scan through all previously applied items
        if (!_includes(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }
          return false;
        }
        return true;
    }
  }

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Objects and Arrays are compared in terms of
   * value equality, not reference equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
   * @example
   *
   *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
   *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
   *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
   */
  var difference = /*#__PURE__*/_curry2(function difference(first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    var secondLen = second.length;
    var toFilterOut = new _Set$1();
    for (var i = 0; i < secondLen; i += 1) {
      toFilterOut.add(second[i]);
    }
    while (idx < firstLen) {
      if (toFilterOut.add(first[idx])) {
        out[out.length] = first[idx];
      }
      idx += 1;
    }
    return out;
  });

  /**
   * Removes the sub-list of `list` starting at index `start` and containing
   * `count` elements. _Note that this is not destructive_: it returns a copy of
   * the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} start The position to start removing elements
   * @param {Number} count The number of elements to remove
   * @param {Array} list The list to remove from
   * @return {Array} A new Array with `count` elements from `start` removed.
   * @see R.without
   * @example
   *
   *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
   */
  var remove = /*#__PURE__*/_curry3(function remove(start, count, list) {
    var result = Array.prototype.slice.call(list, 0);
    result.splice(start, count);
    return result;
  });

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @private
   * @param {String|Number} prop The name of the property to dissociate
   * @param {Object|Array} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   */
  function _dissoc(prop, obj) {
    if (obj == null) {
      return obj;
    }
    if (_isInteger(prop) && _isArray(obj)) {
      return remove(prop, 1, obj);
    }
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    delete result[prop];
    return result;
  }

  /**
   * Makes a shallow clone of an object. Note that this copies and flattens
   * prototype properties onto the new object as well. All non-primitive
   * properties are copied by reference.
   *
   * @private
   * @param {String|Integer} prop The prop operating
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original.
   */
  function _shallowCloneObject(prop, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      return [].concat(obj);
    }
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    return result;
  }

  /**
   * Makes a shallow clone of an object, omitting the property at the given path.
   * Note that this copies and flattens prototype properties onto the new object
   * as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.11.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {k: v} -> {k: v}
   * @param {Array} path The path to the value to omit
   * @param {Object} obj The object to clone
   * @return {Object} A new object without the property at path
   * @see R.assocPath
   * @example
   *
   *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
   */
  var dissocPath = /*#__PURE__*/_curry2(function dissocPath(path, obj) {
    if (obj == null) {
      return obj;
    }
    switch (path.length) {
      case 0:
        return obj;
      case 1:
        return _dissoc(path[0], obj);
      default:
        var head = path[0];
        var tail = Array.prototype.slice.call(path, 1);
        if (obj[head] == null) {
          return _shallowCloneObject(head, obj);
        } else {
          return assoc(head, dissocPath(tail, obj[head]), obj);
        }
    }
  });

  var XTake = /*#__PURE__*/function () {
    function XTake(n, xf) {
      this.xf = xf;
      this.n = n;
      this.i = 0;
    }
    XTake.prototype['@@transducer/init'] = _xfBase.init;
    XTake.prototype['@@transducer/result'] = _xfBase.result;
    XTake.prototype['@@transducer/step'] = function (result, input) {
      this.i += 1;
      var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
      return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
    };
    return XTake;
  }();
  function _xtake(n) {
    return function (xf) {
      return new XTake(n, xf);
    };
  }

  /**
   * Returns the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `take` method).
   *
   * Dispatches to the `take` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*}
   * @see R.drop
   * @example
   *
   *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(3, 'ramda');               //=> 'ram'
   *
   *      const personnel = [
   *        'Dave Brubeck',
   *        'Paul Desmond',
   *        'Eugene Wright',
   *        'Joe Morello',
   *        'Gerry Mulligan',
   *        'Bob Bates',
   *        'Joe Dodge',
   *        'Ron Crotty'
   *      ];
   *
   *      const takeFive = R.take(5);
   *      takeFive(personnel);
   *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
   * @symb R.take(-1, [a, b]) = [a, b]
   * @symb R.take(0, [a, b]) = []
   * @symb R.take(1, [a, b]) = [a]
   * @symb R.take(2, [a, b]) = [a, b]
   */
  var take = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['take'], _xtake, function take(n, xs) {
    return slice(0, n < 0 ? Infinity : n, xs);
  }));

  /**
   * Returns the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String | Undefined
   * @param {*} list
   * @return {*}
   * @see R.init, R.head, R.tail
   * @example
   *
   *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
   *      R.last([]); //=> undefined
   *
   *      R.last('abc'); //=> 'c'
   *      R.last(''); //=> undefined
   */
  var last = /*#__PURE__*/_curry1(function (list) {
    return _nth(-1, list);
  });

  var XDropWhile = /*#__PURE__*/function () {
    function XDropWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
    XDropWhile.prototype['@@transducer/step'] = function (result, input) {
      if (this.f) {
        if (this.f(input)) {
          return result;
        }
        this.f = null;
      }
      return this.xf['@@transducer/step'](result, input);
    };
    return XDropWhile;
  }();
  function _xdropWhile(f) {
    return function (xf) {
      return new XDropWhile(f, xf);
    };
  }

  /**
   * Returns a new list excluding the leading elements of a given list which
   * satisfy the supplied predicate function. It passes each value to the supplied
   * predicate function, skipping elements while the predicate function returns
   * `true`. The predicate function is applied to one argument: *(value)*.
   *
   * Dispatches to the `dropWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.takeWhile, R.transduce, R.addIndex
   * @example
   *
   *      const lteTwo = x => x <= 2;
   *
   *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
   *
   *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
   */
  var dropWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, xs) {
    var idx = 0;
    var len = xs.length;
    while (idx < len && pred(xs[idx])) {
      idx += 1;
    }
    return slice(idx, Infinity, xs);
  }));

  /**
   * Returns the first argument if it is truthy, otherwise the second argument.
   * Acts as the boolean `or` statement if both inputs are `Boolean`s.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any}
   * @see R.either, R.and
   * @example
   *
   *      R.or(true, true); //=> true
   *      R.or(true, false); //=> true
   *      R.or(false, true); //=> true
   *      R.or(false, false); //=> false
   */
  var or = /*#__PURE__*/_curry2(function or(a, b) {
    return a || b;
  });

  /**
   * A function wrapping calls to the two functions in an `||` operation,
   * returning the result of the first function if it is truth-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * truth-y value.
   *
   * In addition to functions, `R.either` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f a predicate
   * @param {Function} g another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
   * @see R.both, R.anyPass, R.or
   * @example
   *
   *      const gt10 = x => x > 10;
   *      const even = x => x % 2 === 0;
   *      const f = R.either(gt10, even);
   *      f(101); //=> true
   *      f(8); //=> true
   *
   *      R.either(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(55)
   *      R.either([false, false, 'a'], [11]) // => [11, 11, "a"]
   */
  var either = /*#__PURE__*/_curry2(function either(f, g) {
    return _isFunction(f) ? function _either() {
      return f.apply(this, arguments) || g.apply(this, arguments);
    } : lift(or)(f, g);
  });

  /**
   * Tests whether or not an object is a typed array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is a typed array, `false` otherwise.
   * @example
   *
   *      _isTypedArray(new Uint8Array([])); //=> true
   *      _isTypedArray(new Float32Array([])); //=> true
   *      _isTypedArray([]); //=> false
   *      _isTypedArray(null); //=> false
   *      _isTypedArray({}); //=> false
   */
  function _isTypedArray(val) {
    var type = Object.prototype.toString.call(val);
    return type === '[object Uint8ClampedArray]' || type === '[object Int8Array]' || type === '[object Uint8Array]' || type === '[object Int16Array]' || type === '[object Uint16Array]' || type === '[object Int32Array]' || type === '[object Uint32Array]' || type === '[object Float32Array]' || type === '[object Float64Array]' || type === '[object BigInt64Array]' || type === '[object BigUint64Array]';
  }

  /**
   * Returns the empty value of its argument's type. Ramda defines the empty
   * value of Array (`[]`), Object (`{}`), String (`''`),
   * TypedArray (`Uint8Array []`, `Float32Array []`, etc), and Arguments. Other
   * types are supported if they define `<Type>.empty`,
   * `<Type>.prototype.empty` or implement the
   * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
   *
   * Dispatches to the `empty` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> a
   * @param {*} x
   * @return {*}
   * @example
   *
   *      R.empty(Just(42));               //=> Nothing()
   *      R.empty([1, 2, 3]);              //=> []
   *      R.empty('unicorns');             //=> ''
   *      R.empty({x: 1, y: 2});           //=> {}
   *      R.empty(Uint8Array.from('123')); //=> Uint8Array []
   */
  var empty = /*#__PURE__*/_curry1(function empty(x) {
    return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
      return arguments;
    }() : _isTypedArray(x) ? x.constructor.from('') : void 0 // else
    ;
  });

  /**
   * Returns a new function much like the supplied one, except that the first two
   * arguments' order is reversed.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
   * @param {Function} fn The function to invoke with its first two parameters reversed.
   * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
   * @example
   *
   *      const mergeThree = (a, b, c) => [].concat(a, b, c);
   *
   *      mergeThree(1, 2, 3); //=> [1, 2, 3]
   *
   *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
   * @symb R.flip(f)(a, b, c) = f(b, a, c)
   */
  var flip = /*#__PURE__*/_curry1(function flip(fn) {
    return curryN(fn.length, function (a, b) {
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = b;
      args[1] = a;
      return fn.apply(this, args);
    });
  });

  /**
   * Splits a list into sub-lists stored in an object, based on the result of
   * calling a key-returning function on each element, and grouping the
   * results according to values returned.
   *
   * Dispatches to the `groupBy` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> {a: [b]}
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} list The array to group
   * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
   *         that produced that key when passed to `fn`.
   * @see R.reduceBy, R.transduce, R.indexBy, R.collectBy
   * @example
   *
   *      const byGrade = R.groupBy(function(student) {
   *        const score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      const students = [{name: 'Abby', score: 84},
   *                      {name: 'Eddy', score: 58},
   *                      // ...
   *                      {name: 'Jack', score: 69}];
   *      byGrade(students);
   *      // {
   *      //   'A': [{name: 'Dianne', score: 99}],
   *      //   'B': [{name: 'Abby', score: 84}]
   *      //   // ...,
   *      //   'F': [{name: 'Eddy', score: 58}]
   *      // }
   */
  var groupBy = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('groupBy', /*#__PURE__*/reduceBy(function (acc, item) {
    acc.push(item);
    return acc;
  }, [])));

  /**
   * Returns whether or not a path exists in an object. Only the object's
   * own properties are checked.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {a} -> Boolean
   * @param {Array} path The path to use.
   * @param {Object} obj The object to check the path in.
   * @return {Boolean} Whether the path exists.
   * @see R.has
   * @example
   *
   *      R.hasPath(['a', 'b'], {a: {b: 2}});         // => true
   *      R.hasPath(['a', 'b'], {a: {b: undefined}}); // => true
   *      R.hasPath(['a', 'b'], {a: {c: 2}});         // => false
   *      R.hasPath(['a', 'b'], {});                  // => false
   */
  var hasPath = /*#__PURE__*/_curry2(function hasPath(_path, obj) {
    if (_path.length === 0 || isNil(obj)) {
      return false;
    }
    var val = obj;
    var idx = 0;
    while (idx < _path.length) {
      if (!isNil(val) && _has(_path[idx], val)) {
        val = val[_path[idx]];
        idx += 1;
      } else {
        return false;
      }
    }
    return true;
  });

  /**
   * Returns whether or not an object has an own property with the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      const hasName = R.has('name');
   *      hasName({name: 'alice'});   //=> true
   *      hasName({name: 'bob'});     //=> true
   *      hasName({});                //=> false
   *
   *      const point = {x: 0, y: 0};
   *      const pointHas = R.has(R.__, point);
   *      pointHas('x');  //=> true
   *      pointHas('y');  //=> true
   *      pointHas('z');  //=> false
   */
  var has = /*#__PURE__*/_curry2(function has(prop, obj) {
    return hasPath([prop], obj);
  });

  /**
   * Returns true if its arguments are identical, false otherwise. Values are
   * identical if they reference the same memory. `NaN` is identical to `NaN`;
   * `0` and `-0` are not identical.
   *
   * Note this is merely a curried version of ES6 `Object.is`.
   *
   * `identical` does not support the `__` placeholder.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      const o = {};
   *      R.identical(o, o); //=> true
   *      R.identical(1, 1); //=> true
   *      R.identical(1, '1'); //=> false
   *      R.identical([], []); //=> false
   *      R.identical(0, -0); //=> false
   *      R.identical(NaN, NaN); //=> true
   */
  var identical = function (a, b) {
    switch (arguments.length) {
      case 0:
        return identical;
      case 1:
        return function () {
          return function unaryIdentical(_b) {
            switch (arguments.length) {
              case 0:
                return unaryIdentical;
              default:
                return _objectIs$1(a, _b);
            }
          };
        }();
      default:
        return _objectIs$1(a, b);
    }
  };

  /**
   * Creates a function that will process either the `onTrue` or the `onFalse`
   * function depending upon the result of the `condition` predicate.
   *
   * Note that `ifElse` takes its arity from the longest of the three functions passed to it.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
   * @param {Function} condition A predicate function
   * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
   * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
   * @return {Function} A new function that will process either the `onTrue` or the `onFalse`
   *                    function depending upon the result of the `condition` predicate.
   * @see R.unless, R.when, R.cond
   * @example
   *
   *      const incCount = R.ifElse(
   *        R.has('count'),
   *        R.over(R.lensProp('count'), R.inc),
   *        R.assoc('count', 1)
   *      );
   *      incCount({ count: 1 }); //=> { count: 2 }
   *      incCount({});           //=> { count: 1 }
   */
  var ifElse = /*#__PURE__*/_curry3(function ifElse(condition, onTrue, onFalse) {
    return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    });
  });

  /**
   * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
   * terms, to at least one element of the given list; `false` otherwise.
   * Also works with strings.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category List
   * @sig a -> [a] -> Boolean
   * @param {Object} a The item to compare against.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
   * @see R.any
   * @example
   *
   *      R.includes(3, [1, 2, 3]); //=> true
   *      R.includes(4, [1, 2, 3]); //=> false
   *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
   *      R.includes([42], [[42]]); //=> true
   *      R.includes('ba', 'banana'); //=>true
   */
  var includes = /*#__PURE__*/_curry2(_includes);

  /**
   * Returns all but the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.last, R.head, R.tail
   * @example
   *
   *      R.init([1, 2, 3]);  //=> [1, 2]
   *      R.init([1, 2]);     //=> [1]
   *      R.init([1]);        //=> []
   *      R.init([]);         //=> []
   *
   *      R.init('abc');  //=> 'ab'
   *      R.init('ab');   //=> 'a'
   *      R.init('a');    //=> ''
   *      R.init('');     //=> ''
   */
  var init = /*#__PURE__*/slice(0, -1);

  /**
   * Given an `arity` (Number) and a `name` (String) the `invoker` function
   * returns a curried function that takes `arity` arguments and a `context`
   * object. It will "invoke" the `name`'d function (a method) on the `context`
   * object.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
   * @param {Number} arity Number of arguments the returned function should take
   *        before the target object.
   * @param {String} method Name of any of the target object's methods to call.
   * @return {Function} A new curried function.
   * @see R.construct
   * @example
   *      // A function with no arguments
   *      const asJson = invoker(0, "json")
   *      // Just like calling .then((response) => response.json())
   *      fetch("http://example.com/index.json").then(asJson)
   *
   *      // A function with one argument
   *      const sliceFrom = invoker(1, 'slice');
   *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
   *
   *      // A function with two arguments
   *      const sliceFrom6 = invoker(2, 'slice')(6);
   *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
   *
   *      // NOTE: You can't simply pass some of the arguments to the initial invoker function.
   *      const firstCreditCardSection = invoker(2, "slice", 0, 4)
   *      firstCreditCardSection("4242 4242 4242 4242") // => Function<...>
   *
   *      // Since invoker returns a curried function, you may partially apply it to create the function you need.
   *      const firstCreditCardSection = invoker(2, "slice")(0, 4)
   *      firstCreditCardSection("4242 4242 4242 4242") // => "4242"
   *
   * @symb R.invoker(0, 'method')(o) = o['method']()
   * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
   * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
   */
  var invoker = /*#__PURE__*/_curry2(function invoker(arity, method) {
    return curryN(arity + 1, function () {
      var target = arguments[arity];
      if (target != null && _isFunction(target[method])) {
        return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
      }
      throw new TypeError(toString$1(target) + ' does not have a method named "' + method + '"');
    });
  });

  /**
   * Returns `true` if the given value is its type's empty value; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> Boolean
   * @param {*} x
   * @return {Boolean}
   * @see R.empty, R.isNotEmpty
   * @example
   *
   *      R.isEmpty([1, 2, 3]);           //=> false
   *      R.isEmpty([]);                  //=> true
   *      R.isEmpty('');                  //=> true
   *      R.isEmpty(null);                //=> false
   *      R.isEmpty({});                  //=> true
   *      R.isEmpty({length: 0});         //=> false
   *      R.isEmpty(Uint8Array.from('')); //=> true
   */
  var isEmpty = /*#__PURE__*/_curry1(function isEmpty(x) {
    return x != null && equals(x, empty(x));
  });

  /**
   * Returns `false` if the given value is its type's empty value; `true`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.29.2
   * @category Logic
   * @sig a -> Boolean
   * @param {*} x
   * @return {Boolean}
   * @see R.empty, R.isEmpty
   * @example
   *
   *      R.isNotEmpty([1, 2, 3]);           //=> true
   *      R.isNotEmpty([]);                  //=> false
   *      R.isNotEmpty('');                  //=> false
   *      R.isNotEmpty(null);                //=> true
   *      R.isNotEmpty({});                  //=> false
   *      R.isNotEmpty({length: 0});         //=> true
   *      R.isNotEmpty(Uint8Array.from('')); //=> false
   */
  var isNotEmpty = /*#__PURE__*/_curry1(function isNotEmpty(x) {
    return !isEmpty(x);
  });

  /**
   * Returns a string made by inserting the `separator` between each element and
   * concatenating all the elements into a single string.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig String -> [a] -> String
   * @param {Number|String} separator The string used to separate the elements.
   * @param {Array} xs The elements to join into a string.
   * @return {String} str The string made by concatenating `xs` with `separator`.
   * @see R.split
   * @example
   *
   *      const spacer = R.join(' ');
   *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
   *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
   */
  var join = /*#__PURE__*/invoker(1, 'join');

  function _isNumber(x) {
    return Object.prototype.toString.call(x) === '[object Number]';
  }

  function _path(pathAr, obj) {
    var val = obj;
    for (var i = 0; i < pathAr.length; i += 1) {
      if (val == null) {
        return undefined;
      }
      var p = pathAr[i];
      if (_isInteger(p)) {
        val = _nth(p, val);
      } else {
        val = val[p];
      }
    }
    return val;
  }

  /**
   * An Object-specific version of [`map`](#map). The function is applied to three
   * arguments: *(value, key, obj)*. If only the value is significant, use
   * [`map`](#map) instead.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig ((*, String, Object) -> *) -> Object -> Object
   * @param {Function} fn
   * @param {Object} obj
   * @return {Object}
   * @see R.map
   * @example
   *
   *      const xyz = { x: 1, y: 2, z: 3 };
   *      const prependKeyAndDouble = (num, key, obj) => key + (num * 2);
   *
   *      R.mapObjIndexed(prependKeyAndDouble, xyz); //=> { x: 'x2', y: 'y4', z: 'z6' }
   */
  var mapObjIndexed = /*#__PURE__*/_curry2(function mapObjIndexed(fn, obj) {
    return _arrayReduce(function (acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys(obj));
  });

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the key
   * and the values associated with the key in each object, with the result being
   * used as the value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWithKey, R.merge, R.mergeWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeWithKey(concatValues,
   *                     { a: true, thing: 'foo', values: [10, 20] },
   *                     { b: true, thing: 'bar', values: [15, 35] });
   *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
   * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
   */
  var mergeWithKey = /*#__PURE__*/_curry3(function mergeWithKey(fn, l, r) {
    var result = {};
    var k;
    l = l || {};
    r = r || {};
    for (k in l) {
      if (_has(k, l)) {
        result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
      }
    }
    for (k in r) {
      if (_has(k, r) && !_has(k, result)) {
        result[k] = r[k];
      }
    }
    return result;
  });

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to the key and associated values
   *   using the resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWithKey, R.mergeDeepWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeDeepWithKey(concatValues,
   *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
   *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
   *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
   */
  var mergeDeepWithKey = /*#__PURE__*/_curry3(function mergeDeepWithKey(fn, lObj, rObj) {
    return mergeWithKey(function (k, lVal, rVal) {
      if (_isObject(lVal) && _isObject(rVal)) {
        return mergeDeepWithKey(fn, lVal, rVal);
      } else {
        return fn(k, lVal, rVal);
      }
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                       { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
   */
  var mergeDeepRight = /*#__PURE__*/_curry2(function mergeDeepRight(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return rVal;
    }, lObj, rObj);
  });

  /**
   * Retrieves the value at a given path. The nodes of the path can be arbitrary strings or non-negative integers.
   * For anything else, the value is unspecified. Integer paths are meant to index arrays, strings are meant for objects.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {a} -> a | Undefined
   * @sig Idx = String | NonNegativeInt
   * @param {Array} path The path to use.
   * @param {Object} obj The object or array to retrieve the nested property from.
   * @return {*} The data at `path`.
   * @see R.prop, R.nth, R.assocPath, R.dissocPath
   * @example
   *
   *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
   *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
   *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
   *      R.path([2], {'2': 2}); //=> 2
   *      R.path([-2], {'-2': 'a'}); //=> undefined
   */

  var path$1 = /*#__PURE__*/_curry2(_path);

  /**
   * If the given, non-null object has a value at the given path, returns the
   * value at that path. Otherwise returns the provided default value.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig a -> [Idx] -> {a} -> a
   * @param {*} d The default value.
   * @param {Array} p The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path` of the supplied object or the default value.
   * @example
   *
   *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
   */
  var pathOr = /*#__PURE__*/_curry3(function pathOr(d, p, obj) {
    return defaultTo(d, _path(p, obj));
  });

  /**
   * Returns `true` if the specified object property at given path satisfies the
   * given predicate; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Logic
   * @typedefn Idx = String | Int | Symbol
   * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
   * @param {Function} pred
   * @param {Array} propPath
   * @param {*} obj
   * @return {Boolean}
   * @see R.propSatisfies, R.path
   * @example
   *
   *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
   *      R.pathSatisfies(R.is(Object), [], {x: {y: 2}}); //=> true
   */
  var pathSatisfies = /*#__PURE__*/_curry3(function pathSatisfies(pred, propPath, obj) {
    return pred(_path(propPath, obj));
  });

  /**
   * Returns a partial copy of an object containing only the keys specified. If
   * the key does not exist, the property is ignored.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.omit, R.props
   * @example
   *
   *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
   */
  var pick = /*#__PURE__*/_curry2(function pick(names, obj) {
    var result = {};
    var idx = 0;
    while (idx < names.length) {
      if (names[idx] in obj) {
        result[names[idx]] = obj[names[idx]];
      }
      idx += 1;
    }
    return result;
  });

  /**
   * Return the specified property of the given non-null object if the property
   * is present and it's value is not `null`, `undefined` or `NaN`.
   *
   * Otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Object
   * @sig a -> String -> Object -> a
   * @param {*} val The default value.
   * @param {String} p The name of the property to return.
   * @param {Object} obj The object to query.
   * @return {*} The value of given property of the supplied object or the default value.
   * @example
   *
   *      const alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      const favorite = R.prop('favoriteLibrary');
   *      const favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
   *
   *      favorite(alice);  //=> undefined
   *      favoriteWithDefault(alice);  //=> 'Ramda'
   */
  var propOr = /*#__PURE__*/_curry3(function propOr(val, p, obj) {
    return defaultTo(val, prop(p, obj));
  });

  /**
   * Returns `true` if the specified object property satisfies the given
   * predicate; `false` otherwise. You can test multiple properties with
   * [`R.where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Logic
   * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
   * @param {Function} pred
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.where, R.propEq, R.propIs
   * @example
   *
   *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
   */
  var propSatisfies = /*#__PURE__*/_curry3(function propSatisfies(pred, name, obj) {
    return pred(prop(name, obj));
  });

  /**
   * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> Number -> [Number]
   * @param {Number} from The first number in the list.
   * @param {Number} to One more than the last number in the list.
   * @return {Array} The list of numbers in the set `[a, b)`.
   * @example
   *
   *      R.range(1, 5);    //=> [1, 2, 3, 4]
   *      R.range(50, 53);  //=> [50, 51, 52]
   */
  var range = /*#__PURE__*/_curry2(function range(from, to) {
    if (!(_isNumber(from) && _isNumber(to))) {
      throw new TypeError('Both arguments to range must be numbers');
    }
    var result = Array(from < to ? to - from : 0);
    var finish = from < 0 ? to + Math.abs(from) : to - from;
    var idx = 0;
    while (idx < finish) {
      result[idx] = idx + from;
      idx += 1;
    }
    return result;
  });

  /**
   * Returns a value wrapped to indicate that it is the final value of the reduce
   * and transduce functions. The returned value should be considered a black
   * box: the internal structure is not guaranteed to be stable.
   *
   * This optimization is available to the below functions:
   * - [`reduce`](#reduce)
   * - [`reduceWhile`](#reduceWhile)
   * - [`reduceBy`](#reduceBy)
   * - [`reduceRight`](#reduceRight)
   * - [`transduce`](#transduce)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category List
   * @sig a -> *
   * @param {*} x The final value of the reduce.
   * @return {*} The wrapped value.
   * @see R.reduce, R.reduceWhile, R.reduceBy, R.reduceRight, R.transduce
   * @example
   *
   *     R.reduce(
   *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
   *       [],
   *       [1, 2, 3, 4, 5]) // [1, 2, 3]
   */
  var reduced = /*#__PURE__*/_curry1(_reduced);

  /**
   * Returns a copy of the list, sorted according to the comparator function,
   * which should accept two values at a time and return a negative number if the
   * first value is smaller, a positive number if it's larger, and zero if they
   * are equal. Please note that this is a **copy** of the list. It does not
   * modify the original.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, a) -> Number) -> [a] -> [a]
   * @param {Function} comparator A sorting function :: a -> b -> Int
   * @param {Array} list The list to sort
   * @return {Array} a new array with its elements sorted by the comparator function.
   * @see R.ascend, R.descend
   * @example
   *
   *      const diff = function(a, b) { return a - b; };
   *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
   */
  var sort = /*#__PURE__*/_curry2(function sort(comparator, list) {
    return Array.prototype.slice.call(list, 0).sort(comparator);
  });

  /**
   * Splits a string into an array of strings based on the given
   * separator.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig (String | RegExp) -> String -> [String]
   * @param {String|RegExp} sep The pattern.
   * @param {String} str The string to separate into an array.
   * @return {Array} The array of strings from `str` separated by `sep`.
   * @see R.join
   * @example
   *
   *      const pathComponents = R.split('/');
   *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
   *
   *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
   */
  var split = /*#__PURE__*/invoker(1, 'split');

  /**
   * Checks if a list starts with the provided sublist.
   *
   * Similarly, checks if a string starts with the provided substring.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> [a] -> Boolean
   * @sig String -> String -> Boolean
   * @param {*} prefix
   * @param {*} list
   * @return {Boolean}
   * @see R.endsWith
   * @example
   *
   *      R.startsWith('a', 'abc')                //=> true
   *      R.startsWith('b', 'abc')                //=> false
   *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
   *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
   */
  var startsWith = /*#__PURE__*/_curry2(function (prefix, list) {
    return equals(take(prefix.length, list), prefix);
  });

  var XUniqWith = /*#__PURE__*/function () {
    function XUniqWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.items = [];
    }
    XUniqWith.prototype['@@transducer/init'] = _xfBase.init;
    XUniqWith.prototype['@@transducer/result'] = _xfBase.result;
    XUniqWith.prototype['@@transducer/step'] = function (result, input) {
      if (_includesWith(this.pred, input, this.items)) {
        return result;
      } else {
        this.items.push(input);
        return this.xf['@@transducer/step'](result, input);
      }
    };
    return XUniqWith;
  }();
  function _xuniqWith(pred) {
    return function (xf) {
      return new XUniqWith(pred, xf);
    };
  }

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied predicate to
   * two list elements. Prefers the first item if two items compare equal based
   * on the predicate.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      const strEq = R.eqBy(String);
   *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
   *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
   *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
   *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
   */
  var uniqWith = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xuniqWith, function (pred, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var item;
    while (idx < len) {
      item = list[idx];
      if (!_includesWith(pred, item, result)) {
        result[result.length] = item;
      }
      idx += 1;
    }
    return result;
  }));

  /**
   * A function that returns `undefined`.
   *
   * @func stubUndefined
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/1.0.0|v1.0.0}
   * @category Function
   * @sig ... -> undefined
   * @return {undefined}
   * @example
   *
   * RA.stubUndefined(); //=> undefined
   * RA.stubUndefined(1, 2, 3); //=> undefined
   */
  var stubUndefined = always(void 0); // eslint-disable-line no-void

  /**
   * Checks if input value is `undefined`.
   *
   * @func isUndefined
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.0.1|v0.0.1}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotUndefined|isNotUndefined}
   * @example
   *
   * RA.isUndefined(1); //=> false
   * RA.isUndefined(undefined); //=> true
   * RA.isUndefined(null); //=> false
   */
  var isUndefined = equals(stubUndefined());

  /**
   * Checks if input value is `null`.
   *
   * @func isNull
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.1.0|v0.1.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotNull|isNotNull}
   * @example
   *
   * RA.isNull(1); //=> false
   * RA.isNull(undefined); //=> false
   * RA.isNull(null); //=> true
   */
  var isNull = equals(null);

  /**
   * Checks if input value is complement of `null`.
   *
   * @func isNotNull
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.1.0|v0.1.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNull|isNull}
   * @example
   *
   * RA.isNotNull(1); //=> true
   * RA.isNotNull(undefined); //=> true
   * RA.isNotNull(null); //=> false
   */
  var isNotNull = complement(isNull);

  /**
   * Checks if input value is complement of `null` or `undefined`.
   *
   * @func isNotNil
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link http://ramdajs.com/docs/#isNil|R.isNil}
   * @example
   *
   * RA.isNotNil(null); //=> false
   * RA.isNotNil(undefined); //=> false
   * RA.isNotNil(0); //=> true
   * RA.isNotNil([]); //=> true
   */
  var isNotNil = complement(isNil);

  /**
   * Checks if input value is `Generator Function`.
   *
   * @func isGeneratorFunction
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isAsyncFunction}, {@link RA.isNotGeneratorFunction|isNotGeneratorFunction}
   * @example
   *
   * RA.isGeneratorFunction(function* test() { }); //=> true
   * RA.isGeneratorFunction(null); //=> false
   * RA.isGeneratorFunction(function test() { }); //=> false
   * RA.isGeneratorFunction(() => {}); //=> false
   */
  var isGeneratorFunction = curryN(1, pipe(type, identical('GeneratorFunction')));

  /**
   * Checks if input value is `Async Function`.
   *
   * @func isAsyncFunction
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isFunction|isFunction}, {@link RA.isNotAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
   * @example
   *
   * RA.isAsyncFunction(async function test() { }); //=> true
   * RA.isAsyncFunction(null); //=> false
   * RA.isAsyncFunction(function test() { }); //=> false
   * RA.isAsyncFunction(() => {}); //=> false
   */
  var isAsyncFunction = curryN(1, pipe(type, identical('AsyncFunction')));

  /**
   * Checks if input value is `Function`.
   *
   * @func isFunction
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotFunction|isNotFunction}, {@link RA.isAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
   * @example
   *
   * RA.isFunction(function test() { }); //=> true
   * RA.isFunction(function* test() { }); //=> true
   * RA.isFunction(async function test() { }); //=> true
   * RA.isFunction(() => {}); //=> true
   * RA.isFunction(null); //=> false
   * RA.isFunction('abc'); //=> false
   */
  var isFunction = anyPass([pipe(type, identical('Function')), isGeneratorFunction, isAsyncFunction]);

  /**
   * Checks if input value is `Array`.
   *
   * @func isArray
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotArray|isNotArray}
   * @example
   *
   * RA.isArray([]); //=> true
   * RA.isArray(null); //=> false
   * RA.isArray({}); //=> false
   */
  var isArray = curryN(1, isFunction(Array.isArray) ? Array.isArray : pipe(type, identical('Array')));

  /**
   * Checks if input value is an empty `Array`.
   *
   * @func isEmptyArray
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotEmptyArray|isNotEmptyArray}
   * @example
   *
   * RA.isEmptyArray([]); // => true
   * RA.isEmptyArray([42]); // => false
   * RA.isEmptyArray({}); // => false
   * RA.isEmptyArray(null); // => false
   * RA.isEmptyArray(undefined); // => false
   * RA.isEmptyArray(42); // => false
   * RA.isEmptyArray('42'); // => false
   */
  var isEmptyArray = both(isArray, isEmpty);

  /**
   * Checks if input value is not an empty `Array`.
   *
   * @func isNonEmptyArray
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isEmptyArray|isEmptyArray}
   * @example
   *
   * RA.isNonEmptyArray([42]); // => true
   * RA.isNonEmptyArray([]); // => false
   * RA.isNonEmptyArray({}); // => false
   * RA.isNonEmptyArray(null); // => false
   * RA.isNonEmptyArray(undefined); // => false
   * RA.isNonEmptyArray(42); // => false
   * RA.isNonEmptyArray('42'); // => false
   */
  var isNonEmptyArray = both(isArray, isNotEmpty);

  /**
   * Checks if input value is `String`.
   *
   * @func isString
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.4.0|v0.4.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotString|isNotString}
   * @example
   *
   * RA.isString('abc'); //=> true
   * RA.isString(1); //=> false
   */
  var isString = curryN(1, pipe(type, identical('String')));

  function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  var isOfTypeObject = function isOfTypeObject(val) {
    return _typeof(val) === 'object';
  };

  /* eslint-disable max-len */
  /**
   * Checks if input value is language type of `Object`.
   *
   * @func isObj
   * @aliases isObject
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotObj|isNotObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isPlainObj|isPlainObj}
   * @example
   *
   * RA.isObj({}); //=> true
   * RA.isObj([]); //=> true
   * RA.isObj(() => {}); //=> true
   * RA.isObj(null); //=> false
   * RA.isObj(undefined); //=> false
   */
  /* eslint-enable max-len */
  var isObj = curryN(1, both(isNotNull, either(isOfTypeObject, isFunction)));

  /* eslint-disable max-len */
  /**
   * Checks if input value is complement of language type of `Object`.
   *
   * @func isNotObj
   * @aliases isNotObject
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isObj|isObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isPlainObj|isPlainObj}
   * @example
   *
   * RA.isNotObj({}); //=> false
   * RA.isNotObj([]); //=> false
   * RA.isNotObj(() => {}); //=> false
   * RA.isNotObj(null); //=> true
   * RA.isNotObj(undefined); //=> true
   */
  /* eslint-enable max-len */
  var isNotObj = complement(isObj);

  /**
   * Checks if input value is not an empty `String`.
   *
   * @func isNonEmptyString
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isEmptyString|isEmptyString}
   * @example
   *
   * RA.isNonEmptyString('42'); // => true
   * RA.isNonEmptyString(''); // => false
   * RA.isNonEmptyString(new String('42')); // => false
   * RA.isNonEmptyString(new String('')); // => false
   * RA.isNonEmptyString([42]); // => false
   * RA.isNonEmptyString({}); // => false
   * RA.isNonEmptyString(null); // => false
   * RA.isNonEmptyString(undefined); // => false
   * RA.isNonEmptyString(42); // => false
   */
  var isNonEmptyString = allPass([isString, isNotObj, isNotEmpty]);

  /* eslint-disable max-len */
  /**
   * Checks if input value is complement of `Function`.
   *
   * @func isNotFunction
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
   * @example
   *
   * RA.isNotFunction(function test() { }); //=> false
   * RA.isNotFunction(function* test() { }); //=> false
   * RA.isNotFunction(async function test() { }); //=> false
   * RA.isNotFunction(() => {}); //=> false
   * RA.isNotFunction(null); //=> true
   * RA.isNotFunction('abc'); //=> true
   */
  /* eslint-enable max-len */
  var isNotFunction = complement(isFunction);

  /* eslint-disable max-len */
  /**
   * Checks if value is object-like. A value is object-like if it's not null and has a typeof result of "object".
   *
   * @func isObjLike
   * @aliases isObjectLike
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotObjLike|isNotObjLike}, {@link RA.isObj|isObj}, {@link RA.isPlainObj|isPlainObj}
   * @example
   *
   * RA.isObjLike({}); //=> true
   * RA.isObjLike([]); //=> true
   * RA.isObjLike(() => {}); //=> false
   * RA.isObjLike(null); //=> false
   * RA.isObjLike(undefined); //=> false
   */
  /* eslint-enable max-len */
  var isObjLike = curryN(1, both(isNotNull, isOfTypeObject));

  var isObject$1 = pipe(type, identical('Object'));
  var isObjectConstructor = pipe(toString$1, equals(toString$1(Object)));
  var hasObjectConstructor = pathSatisfies(both(isFunction, isObjectConstructor), ['constructor']);

  /* eslint-disable max-len */
  /**
   * Check to see if an object is a plain object (created using `{}`, `new Object()` or `Object.create(null)`).
   *
   * @func isPlainObj
   * @aliases isPlainObject
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
   * @category Type
   * @sig * -> Boolean
   * @param {*} val The value to test
   * @return {boolean}
   * @see {@link RA.isNotPlainObj|isNotPlainObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isObj|isObj}
   * @example
   *
   * class Bar {
   *   constructor() {
   *     this.prop = 'value';
   *   }
   * }
   *
   * RA.isPlainObj(new Bar()); //=> false
   * RA.isPlainObj({ prop: 'value' }); //=> true
   * RA.isPlainObj(['a', 'b', 'c']); //=> false
   * RA.isPlainObj(Object.create(null); //=> true
   * RA.isPlainObj(new Object()); //=> true
   */
  /* eslint-enable max-len */
  var isPlainObj = curryN(1, function (val) {
    if (!isObjLike(val) || !isObject$1(val)) {
      return false;
    }
    var proto = Object.getPrototypeOf(val);
    if (isNull(proto)) {
      return true;
    }
    return hasObjectConstructor(proto);
  });

  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  var byArity = comparator(function (a, b) {
    return a.length > b.length;
  });
  var getMaxArity = pipe(sort(byArity), head, prop('length'));
  var iteratorFn = curry(function (args, accumulator, fn) {
    var result = fn.apply(void 0, _toConsumableArray(args));
    return isNotNil(result) ? reduced(result) : accumulator;
  });
  var dispatchImpl = function dispatchImpl(functions) {
    var arity = getMaxArity(functions);
    return curryN(arity, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return reduce(iteratorFn(args), undefined, functions);
    });
  };
  var dispatch = ifElse(isNonEmptyArray, dispatchImpl, stubUndefined);

  /**
   * Returns true if the specified value is equal, in R.equals terms,
   * to at least one element of the given list or false otherwise.
   * Given list can be a string.
   *
   * Like {@link http://ramdajs.com/docs/#includes|R.includes} but with argument order reversed.
   *
   * @func included
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/3.0.0|v3.0.0}
   * @category List
   * @sig [a] -> a -> Boolean
   * @param {Array|String} list The list to consider
   * @param {*} a The item to compare against
   * @return {boolean} Returns Boolean `true` if an equivalent item is in the list or `false` otherwise
   * @see {@link http://ramdajs.com/docs/#includes|R.includes}
   * @example
   *
   * RA.included([1, 2, 3], 3); //=> true
   * RA.included([1, 2, 3], 4); //=> false
   * RA.included([{ name: 'Fred' }], { name: 'Fred' }); //=> true
   * RA.included([[42]], [42]); //=> true
   */
  var included = flip(includes);

  /**
   * Invokes the method at path of object with given arguments.
   *
   * @func invokeArgs
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/2.27.0|v2.27.0}
   * @category Object
   * @sig Array -> Array -> Object -> *
   * @param {Array.<string|number>} path The path of the method to invoke
   * @param {Array} args The arguments to invoke the method with
   * @param {Object} obj The object to query
   * @return {*}
   * @example
   *
   * RA.invokeArgs(['abs'], [-1], Math); //=> 1
   * RA.invokeArgs(['path', 'to', 'non-existent', 'method'], [-1], Math); //=> undefined
   */

  var invokeArgs = curryN(3, function (mpath, args, obj) {
    var method = path$1(mpath, obj);
    var context = path$1(init(mpath), obj);
    if (isNotFunction(method)) return undefined;
    if (isEmptyArray(mpath)) return undefined;
    var boundMethod = bind(method, context);
    return apply(boundMethod, args);
  });

  /**
   * Removes specified characters from the beginning of a string.
   *
   * @func trimCharsStart
   * @memberOf RA
   * @since {@link https://char0n.github.io/ramda-adjunct/2.24.0|v2.24.0}
   * @category String
   * @sig String -> String
   * @param {string} chars The characters to trim
   * @param {string} value The string to trim
   * @return {string} Returns the trimmed string.
   * @example
   *
   * RA.trimCharsStart('_-', '-_-abc-_-'); //=> 'abc-_-'
   */

  var trimCharsStart = curry(function (chars, value) {
    return pipe(split(''), dropWhile(included(chars)), join(''))(value);
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var minim = {};

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */

  var isNull_1;
  var hasRequiredIsNull;

  function requireIsNull () {
  	if (hasRequiredIsNull) return isNull_1;
  	hasRequiredIsNull = 1;
  	function isNull(value) {
  	  return value === null;
  	}

  	isNull_1 = isNull;
  	return isNull_1;
  }

  /** Detect free variable `global` from Node.js. */

  var _freeGlobal;
  var hasRequired_freeGlobal;

  function require_freeGlobal () {
  	if (hasRequired_freeGlobal) return _freeGlobal;
  	hasRequired_freeGlobal = 1;
  	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  	_freeGlobal = freeGlobal;
  	return _freeGlobal;
  }

  var _root;
  var hasRequired_root;

  function require_root () {
  	if (hasRequired_root) return _root;
  	hasRequired_root = 1;
  	var freeGlobal = require_freeGlobal();

  	/** Detect free variable `self`. */
  	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  	/** Used as a reference to the global object. */
  	var root = freeGlobal || freeSelf || Function('return this')();

  	_root = root;
  	return _root;
  }

  var _Symbol;
  var hasRequired_Symbol;

  function require_Symbol () {
  	if (hasRequired_Symbol) return _Symbol;
  	hasRequired_Symbol = 1;
  	var root = require_root();

  	/** Built-in value references. */
  	var Symbol = root.Symbol;

  	_Symbol = Symbol;
  	return _Symbol;
  }

  var _getRawTag;
  var hasRequired_getRawTag;

  function require_getRawTag () {
  	if (hasRequired_getRawTag) return _getRawTag;
  	hasRequired_getRawTag = 1;
  	var Symbol = require_Symbol();

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * Used to resolve the
  	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
  	 * of values.
  	 */
  	var nativeObjectToString = objectProto.toString;

  	/** Built-in value references. */
  	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  	/**
  	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
  	 *
  	 * @private
  	 * @param {*} value The value to query.
  	 * @returns {string} Returns the raw `toStringTag`.
  	 */
  	function getRawTag(value) {
  	  var isOwn = hasOwnProperty.call(value, symToStringTag),
  	      tag = value[symToStringTag];

  	  try {
  	    value[symToStringTag] = undefined;
  	    var unmasked = true;
  	  } catch (e) {}

  	  var result = nativeObjectToString.call(value);
  	  if (unmasked) {
  	    if (isOwn) {
  	      value[symToStringTag] = tag;
  	    } else {
  	      delete value[symToStringTag];
  	    }
  	  }
  	  return result;
  	}

  	_getRawTag = getRawTag;
  	return _getRawTag;
  }

  /** Used for built-in method references. */

  var _objectToString;
  var hasRequired_objectToString;

  function require_objectToString () {
  	if (hasRequired_objectToString) return _objectToString;
  	hasRequired_objectToString = 1;
  	var objectProto = Object.prototype;

  	/**
  	 * Used to resolve the
  	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
  	 * of values.
  	 */
  	var nativeObjectToString = objectProto.toString;

  	/**
  	 * Converts `value` to a string using `Object.prototype.toString`.
  	 *
  	 * @private
  	 * @param {*} value The value to convert.
  	 * @returns {string} Returns the converted string.
  	 */
  	function objectToString(value) {
  	  return nativeObjectToString.call(value);
  	}

  	_objectToString = objectToString;
  	return _objectToString;
  }

  var _baseGetTag;
  var hasRequired_baseGetTag;

  function require_baseGetTag () {
  	if (hasRequired_baseGetTag) return _baseGetTag;
  	hasRequired_baseGetTag = 1;
  	var Symbol = require_Symbol(),
  	    getRawTag = require_getRawTag(),
  	    objectToString = require_objectToString();

  	/** `Object#toString` result references. */
  	var nullTag = '[object Null]',
  	    undefinedTag = '[object Undefined]';

  	/** Built-in value references. */
  	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  	/**
  	 * The base implementation of `getTag` without fallbacks for buggy environments.
  	 *
  	 * @private
  	 * @param {*} value The value to query.
  	 * @returns {string} Returns the `toStringTag`.
  	 */
  	function baseGetTag(value) {
  	  if (value == null) {
  	    return value === undefined ? undefinedTag : nullTag;
  	  }
  	  return (symToStringTag && symToStringTag in Object(value))
  	    ? getRawTag(value)
  	    : objectToString(value);
  	}

  	_baseGetTag = baseGetTag;
  	return _baseGetTag;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray_1;
  var hasRequiredIsArray;

  function requireIsArray () {
  	if (hasRequiredIsArray) return isArray_1;
  	hasRequiredIsArray = 1;
  	var isArray = Array.isArray;

  	isArray_1 = isArray;
  	return isArray_1;
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  var isObjectLike_1;
  var hasRequiredIsObjectLike;

  function requireIsObjectLike () {
  	if (hasRequiredIsObjectLike) return isObjectLike_1;
  	hasRequiredIsObjectLike = 1;
  	function isObjectLike(value) {
  	  return value != null && typeof value == 'object';
  	}

  	isObjectLike_1 = isObjectLike;
  	return isObjectLike_1;
  }

  var isString_1;
  var hasRequiredIsString;

  function requireIsString () {
  	if (hasRequiredIsString) return isString_1;
  	hasRequiredIsString = 1;
  	var baseGetTag = require_baseGetTag(),
  	    isArray = requireIsArray(),
  	    isObjectLike = requireIsObjectLike();

  	/** `Object#toString` result references. */
  	var stringTag = '[object String]';

  	/**
  	 * Checks if `value` is classified as a `String` primitive or object.
  	 *
  	 * @static
  	 * @since 0.1.0
  	 * @memberOf _
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
  	 * @example
  	 *
  	 * _.isString('abc');
  	 * // => true
  	 *
  	 * _.isString(1);
  	 * // => false
  	 */
  	function isString(value) {
  	  return typeof value == 'string' ||
  	    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  	}

  	isString_1 = isString;
  	return isString_1;
  }

  var isNumber_1;
  var hasRequiredIsNumber;

  function requireIsNumber () {
  	if (hasRequiredIsNumber) return isNumber_1;
  	hasRequiredIsNumber = 1;
  	var baseGetTag = require_baseGetTag(),
  	    isObjectLike = requireIsObjectLike();

  	/** `Object#toString` result references. */
  	var numberTag = '[object Number]';

  	/**
  	 * Checks if `value` is classified as a `Number` primitive or object.
  	 *
  	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
  	 * classified as numbers, use the `_.isFinite` method.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 0.1.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
  	 * @example
  	 *
  	 * _.isNumber(3);
  	 * // => true
  	 *
  	 * _.isNumber(Number.MIN_VALUE);
  	 * // => true
  	 *
  	 * _.isNumber(Infinity);
  	 * // => true
  	 *
  	 * _.isNumber('3');
  	 * // => false
  	 */
  	function isNumber(value) {
  	  return typeof value == 'number' ||
  	    (isObjectLike(value) && baseGetTag(value) == numberTag);
  	}

  	isNumber_1 = isNumber;
  	return isNumber_1;
  }

  var isBoolean_1;
  var hasRequiredIsBoolean;

  function requireIsBoolean () {
  	if (hasRequiredIsBoolean) return isBoolean_1;
  	hasRequiredIsBoolean = 1;
  	var baseGetTag = require_baseGetTag(),
  	    isObjectLike = requireIsObjectLike();

  	/** `Object#toString` result references. */
  	var boolTag = '[object Boolean]';

  	/**
  	 * Checks if `value` is classified as a boolean primitive or object.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 0.1.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
  	 * @example
  	 *
  	 * _.isBoolean(false);
  	 * // => true
  	 *
  	 * _.isBoolean(null);
  	 * // => false
  	 */
  	function isBoolean(value) {
  	  return value === true || value === false ||
  	    (isObjectLike(value) && baseGetTag(value) == boolTag);
  	}

  	isBoolean_1 = isBoolean;
  	return isBoolean_1;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  var isObject_1;
  var hasRequiredIsObject$1;

  function requireIsObject$1 () {
  	if (hasRequiredIsObject$1) return isObject_1;
  	hasRequiredIsObject$1 = 1;
  	function isObject(value) {
  	  var type = typeof value;
  	  return value != null && (type == 'object' || type == 'function');
  	}

  	isObject_1 = isObject;
  	return isObject_1;
  }

  /**
   * @class JSONSerialiser
   *
   * @param {Namespace} namespace
   *
   * @property {Namespace} namespace
   */

  var JSONSerialiser_1;
  var hasRequiredJSONSerialiser;

  function requireJSONSerialiser () {
  	if (hasRequiredJSONSerialiser) return JSONSerialiser_1;
  	hasRequiredJSONSerialiser = 1;
  	class JSONSerialiser {
  	  constructor(namespace) {
  	    this.namespace = namespace || new this.Namespace();
  	  }

  	  /**
  	   * @param {Element} element
  	   * @returns {object}
  	   */
  	  serialise(element) {
  	    if (!(element instanceof this.namespace.elements.Element)) {
  	      throw new TypeError(`Given element \`${element}\` is not an Element instance`);
  	    }

  	    const payload = {
  	      element: element.element,
  	    };

  	    if (element._meta && element._meta.length > 0) {
  	      payload.meta = this.serialiseObject(element.meta);
  	    }

  	    if (element._attributes && element._attributes.length > 0) {
  	      payload.attributes = this.serialiseObject(element.attributes);
  	    }

  	    const content = this.serialiseContent(element.content);

  	    if (content !== undefined) {
  	      payload.content = content;
  	    }

  	    return payload;
  	  }

  	  /**
  	   * @param {object} value
  	   * @returns {Element}
  	   */
  	  deserialise(value) {
  	    if (!value.element) {
  	      throw new Error('Given value is not an object containing an element name');
  	    }

  	    const ElementClass = this.namespace.getElementClass(value.element);
  	    const element = new ElementClass();

  	    if (element.element !== value.element) {
  	      element.element = value.element;
  	    }

  	    if (value.meta) {
  	      this.deserialiseObject(value.meta, element.meta);
  	    }

  	    if (value.attributes) {
  	      this.deserialiseObject(value.attributes, element.attributes);
  	    }

  	    const content = this.deserialiseContent(value.content);
  	    if (content !== undefined || element.content === null) {
  	      element.content = content;
  	    }

  	    return element;
  	  }

  	  // Private API

  	  serialiseContent(content) {
  	    if (content instanceof this.namespace.elements.Element) {
  	      return this.serialise(content);
  	    }

  	    if (content instanceof this.namespace.KeyValuePair) {
  	      const pair = {
  	        key: this.serialise(content.key),
  	      };

  	      if (content.value) {
  	        pair.value = this.serialise(content.value);
  	      }

  	      return pair;
  	    }

  	    if (content && content.map) {
  	      if (content.length === 0) {
  	        return undefined;
  	      }

  	      return content.map(this.serialise, this);
  	    }

  	    return content;
  	  }

  	  deserialiseContent(content) {
  	    if (content) {
  	      if (content.element) {
  	        return this.deserialise(content);
  	      }

  	      if (content.key) {
  	        const pair = new this.namespace.KeyValuePair(this.deserialise(content.key));

  	        if (content.value) {
  	          pair.value = this.deserialise(content.value);
  	        }

  	        return pair;
  	      }

  	      if (content.map) {
  	        return content.map(this.deserialise, this);
  	      }
  	    }

  	    return content;
  	  }

  	  serialiseObject(obj) {
  	    const result = {};

  	    obj.forEach((value, key) => {
  	      if (value) {
  	        result[key.toValue()] = this.serialise(value);
  	      }
  	    });

  	    if (Object.keys(result).length === 0) {
  	      return undefined;
  	    }

  	    return result;
  	  }

  	  deserialiseObject(from, to) {
  	    Object.keys(from).forEach((key) => {
  	      to.set(key, this.deserialise(from[key]));
  	    });
  	  }
  	}


  	JSONSerialiser_1 = JSONSerialiser;
  	return JSONSerialiser_1;
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */

  var _listCacheClear;
  var hasRequired_listCacheClear;

  function require_listCacheClear () {
  	if (hasRequired_listCacheClear) return _listCacheClear;
  	hasRequired_listCacheClear = 1;
  	function listCacheClear() {
  	  this.__data__ = [];
  	  this.size = 0;
  	}

  	_listCacheClear = listCacheClear;
  	return _listCacheClear;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */

  var eq_1;
  var hasRequiredEq;

  function requireEq () {
  	if (hasRequiredEq) return eq_1;
  	hasRequiredEq = 1;
  	function eq(value, other) {
  	  return value === other || (value !== value && other !== other);
  	}

  	eq_1 = eq;
  	return eq_1;
  }

  var _assocIndexOf;
  var hasRequired_assocIndexOf;

  function require_assocIndexOf () {
  	if (hasRequired_assocIndexOf) return _assocIndexOf;
  	hasRequired_assocIndexOf = 1;
  	var eq = requireEq();

  	/**
  	 * Gets the index at which the `key` is found in `array` of key-value pairs.
  	 *
  	 * @private
  	 * @param {Array} array The array to inspect.
  	 * @param {*} key The key to search for.
  	 * @returns {number} Returns the index of the matched value, else `-1`.
  	 */
  	function assocIndexOf(array, key) {
  	  var length = array.length;
  	  while (length--) {
  	    if (eq(array[length][0], key)) {
  	      return length;
  	    }
  	  }
  	  return -1;
  	}

  	_assocIndexOf = assocIndexOf;
  	return _assocIndexOf;
  }

  var _listCacheDelete;
  var hasRequired_listCacheDelete;

  function require_listCacheDelete () {
  	if (hasRequired_listCacheDelete) return _listCacheDelete;
  	hasRequired_listCacheDelete = 1;
  	var assocIndexOf = require_assocIndexOf();

  	/** Used for built-in method references. */
  	var arrayProto = Array.prototype;

  	/** Built-in value references. */
  	var splice = arrayProto.splice;

  	/**
  	 * Removes `key` and its value from the list cache.
  	 *
  	 * @private
  	 * @name delete
  	 * @memberOf ListCache
  	 * @param {string} key The key of the value to remove.
  	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  	 */
  	function listCacheDelete(key) {
  	  var data = this.__data__,
  	      index = assocIndexOf(data, key);

  	  if (index < 0) {
  	    return false;
  	  }
  	  var lastIndex = data.length - 1;
  	  if (index == lastIndex) {
  	    data.pop();
  	  } else {
  	    splice.call(data, index, 1);
  	  }
  	  --this.size;
  	  return true;
  	}

  	_listCacheDelete = listCacheDelete;
  	return _listCacheDelete;
  }

  var _listCacheGet;
  var hasRequired_listCacheGet;

  function require_listCacheGet () {
  	if (hasRequired_listCacheGet) return _listCacheGet;
  	hasRequired_listCacheGet = 1;
  	var assocIndexOf = require_assocIndexOf();

  	/**
  	 * Gets the list cache value for `key`.
  	 *
  	 * @private
  	 * @name get
  	 * @memberOf ListCache
  	 * @param {string} key The key of the value to get.
  	 * @returns {*} Returns the entry value.
  	 */
  	function listCacheGet(key) {
  	  var data = this.__data__,
  	      index = assocIndexOf(data, key);

  	  return index < 0 ? undefined : data[index][1];
  	}

  	_listCacheGet = listCacheGet;
  	return _listCacheGet;
  }

  var _listCacheHas;
  var hasRequired_listCacheHas;

  function require_listCacheHas () {
  	if (hasRequired_listCacheHas) return _listCacheHas;
  	hasRequired_listCacheHas = 1;
  	var assocIndexOf = require_assocIndexOf();

  	/**
  	 * Checks if a list cache value for `key` exists.
  	 *
  	 * @private
  	 * @name has
  	 * @memberOf ListCache
  	 * @param {string} key The key of the entry to check.
  	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	 */
  	function listCacheHas(key) {
  	  return assocIndexOf(this.__data__, key) > -1;
  	}

  	_listCacheHas = listCacheHas;
  	return _listCacheHas;
  }

  var _listCacheSet;
  var hasRequired_listCacheSet;

  function require_listCacheSet () {
  	if (hasRequired_listCacheSet) return _listCacheSet;
  	hasRequired_listCacheSet = 1;
  	var assocIndexOf = require_assocIndexOf();

  	/**
  	 * Sets the list cache `key` to `value`.
  	 *
  	 * @private
  	 * @name set
  	 * @memberOf ListCache
  	 * @param {string} key The key of the value to set.
  	 * @param {*} value The value to set.
  	 * @returns {Object} Returns the list cache instance.
  	 */
  	function listCacheSet(key, value) {
  	  var data = this.__data__,
  	      index = assocIndexOf(data, key);

  	  if (index < 0) {
  	    ++this.size;
  	    data.push([key, value]);
  	  } else {
  	    data[index][1] = value;
  	  }
  	  return this;
  	}

  	_listCacheSet = listCacheSet;
  	return _listCacheSet;
  }

  var _ListCache;
  var hasRequired_ListCache;

  function require_ListCache () {
  	if (hasRequired_ListCache) return _ListCache;
  	hasRequired_ListCache = 1;
  	var listCacheClear = require_listCacheClear(),
  	    listCacheDelete = require_listCacheDelete(),
  	    listCacheGet = require_listCacheGet(),
  	    listCacheHas = require_listCacheHas(),
  	    listCacheSet = require_listCacheSet();

  	/**
  	 * Creates an list cache object.
  	 *
  	 * @private
  	 * @constructor
  	 * @param {Array} [entries] The key-value pairs to cache.
  	 */
  	function ListCache(entries) {
  	  var index = -1,
  	      length = entries == null ? 0 : entries.length;

  	  this.clear();
  	  while (++index < length) {
  	    var entry = entries[index];
  	    this.set(entry[0], entry[1]);
  	  }
  	}

  	// Add methods to `ListCache`.
  	ListCache.prototype.clear = listCacheClear;
  	ListCache.prototype['delete'] = listCacheDelete;
  	ListCache.prototype.get = listCacheGet;
  	ListCache.prototype.has = listCacheHas;
  	ListCache.prototype.set = listCacheSet;

  	_ListCache = ListCache;
  	return _ListCache;
  }

  var _stackClear;
  var hasRequired_stackClear;

  function require_stackClear () {
  	if (hasRequired_stackClear) return _stackClear;
  	hasRequired_stackClear = 1;
  	var ListCache = require_ListCache();

  	/**
  	 * Removes all key-value entries from the stack.
  	 *
  	 * @private
  	 * @name clear
  	 * @memberOf Stack
  	 */
  	function stackClear() {
  	  this.__data__ = new ListCache;
  	  this.size = 0;
  	}

  	_stackClear = stackClear;
  	return _stackClear;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  var _stackDelete;
  var hasRequired_stackDelete;

  function require_stackDelete () {
  	if (hasRequired_stackDelete) return _stackDelete;
  	hasRequired_stackDelete = 1;
  	function stackDelete(key) {
  	  var data = this.__data__,
  	      result = data['delete'](key);

  	  this.size = data.size;
  	  return result;
  	}

  	_stackDelete = stackDelete;
  	return _stackDelete;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  var _stackGet;
  var hasRequired_stackGet;

  function require_stackGet () {
  	if (hasRequired_stackGet) return _stackGet;
  	hasRequired_stackGet = 1;
  	function stackGet(key) {
  	  return this.__data__.get(key);
  	}

  	_stackGet = stackGet;
  	return _stackGet;
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  var _stackHas;
  var hasRequired_stackHas;

  function require_stackHas () {
  	if (hasRequired_stackHas) return _stackHas;
  	hasRequired_stackHas = 1;
  	function stackHas(key) {
  	  return this.__data__.has(key);
  	}

  	_stackHas = stackHas;
  	return _stackHas;
  }

  var isFunction_1;
  var hasRequiredIsFunction;

  function requireIsFunction () {
  	if (hasRequiredIsFunction) return isFunction_1;
  	hasRequiredIsFunction = 1;
  	var baseGetTag = require_baseGetTag(),
  	    isObject = requireIsObject$1();

  	/** `Object#toString` result references. */
  	var asyncTag = '[object AsyncFunction]',
  	    funcTag = '[object Function]',
  	    genTag = '[object GeneratorFunction]',
  	    proxyTag = '[object Proxy]';

  	/**
  	 * Checks if `value` is classified as a `Function` object.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 0.1.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
  	 * @example
  	 *
  	 * _.isFunction(_);
  	 * // => true
  	 *
  	 * _.isFunction(/abc/);
  	 * // => false
  	 */
  	function isFunction(value) {
  	  if (!isObject(value)) {
  	    return false;
  	  }
  	  // The use of `Object#toString` avoids issues with the `typeof` operator
  	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  	  var tag = baseGetTag(value);
  	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  	}

  	isFunction_1 = isFunction;
  	return isFunction_1;
  }

  var _coreJsData;
  var hasRequired_coreJsData;

  function require_coreJsData () {
  	if (hasRequired_coreJsData) return _coreJsData;
  	hasRequired_coreJsData = 1;
  	var root = require_root();

  	/** Used to detect overreaching core-js shims. */
  	var coreJsData = root['__core-js_shared__'];

  	_coreJsData = coreJsData;
  	return _coreJsData;
  }

  var _isMasked;
  var hasRequired_isMasked;

  function require_isMasked () {
  	if (hasRequired_isMasked) return _isMasked;
  	hasRequired_isMasked = 1;
  	var coreJsData = require_coreJsData();

  	/** Used to detect methods masquerading as native. */
  	var maskSrcKey = (function() {
  	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  	  return uid ? ('Symbol(src)_1.' + uid) : '';
  	}());

  	/**
  	 * Checks if `func` has its source masked.
  	 *
  	 * @private
  	 * @param {Function} func The function to check.
  	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
  	 */
  	function isMasked(func) {
  	  return !!maskSrcKey && (maskSrcKey in func);
  	}

  	_isMasked = isMasked;
  	return _isMasked;
  }

  /** Used for built-in method references. */

  var _toSource;
  var hasRequired_toSource;

  function require_toSource () {
  	if (hasRequired_toSource) return _toSource;
  	hasRequired_toSource = 1;
  	var funcProto = Function.prototype;

  	/** Used to resolve the decompiled source of functions. */
  	var funcToString = funcProto.toString;

  	/**
  	 * Converts `func` to its source code.
  	 *
  	 * @private
  	 * @param {Function} func The function to convert.
  	 * @returns {string} Returns the source code.
  	 */
  	function toSource(func) {
  	  if (func != null) {
  	    try {
  	      return funcToString.call(func);
  	    } catch (e) {}
  	    try {
  	      return (func + '');
  	    } catch (e) {}
  	  }
  	  return '';
  	}

  	_toSource = toSource;
  	return _toSource;
  }

  var _baseIsNative;
  var hasRequired_baseIsNative;

  function require_baseIsNative () {
  	if (hasRequired_baseIsNative) return _baseIsNative;
  	hasRequired_baseIsNative = 1;
  	var isFunction = requireIsFunction(),
  	    isMasked = require_isMasked(),
  	    isObject = requireIsObject$1(),
  	    toSource = require_toSource();

  	/**
  	 * Used to match `RegExp`
  	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
  	 */
  	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  	/** Used to detect host constructors (Safari). */
  	var reIsHostCtor = /^\[object .+?Constructor\]$/;

  	/** Used for built-in method references. */
  	var funcProto = Function.prototype,
  	    objectProto = Object.prototype;

  	/** Used to resolve the decompiled source of functions. */
  	var funcToString = funcProto.toString;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/** Used to detect if a method is native. */
  	var reIsNative = RegExp('^' +
  	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  	);

  	/**
  	 * The base implementation of `_.isNative` without bad shim checks.
  	 *
  	 * @private
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a native function,
  	 *  else `false`.
  	 */
  	function baseIsNative(value) {
  	  if (!isObject(value) || isMasked(value)) {
  	    return false;
  	  }
  	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  	  return pattern.test(toSource(value));
  	}

  	_baseIsNative = baseIsNative;
  	return _baseIsNative;
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  var _getValue;
  var hasRequired_getValue;

  function require_getValue () {
  	if (hasRequired_getValue) return _getValue;
  	hasRequired_getValue = 1;
  	function getValue(object, key) {
  	  return object == null ? undefined : object[key];
  	}

  	_getValue = getValue;
  	return _getValue;
  }

  var _getNative;
  var hasRequired_getNative;

  function require_getNative () {
  	if (hasRequired_getNative) return _getNative;
  	hasRequired_getNative = 1;
  	var baseIsNative = require_baseIsNative(),
  	    getValue = require_getValue();

  	/**
  	 * Gets the native function at `key` of `object`.
  	 *
  	 * @private
  	 * @param {Object} object The object to query.
  	 * @param {string} key The key of the method to get.
  	 * @returns {*} Returns the function if it's native, else `undefined`.
  	 */
  	function getNative(object, key) {
  	  var value = getValue(object, key);
  	  return baseIsNative(value) ? value : undefined;
  	}

  	_getNative = getNative;
  	return _getNative;
  }

  var _Map;
  var hasRequired_Map;

  function require_Map () {
  	if (hasRequired_Map) return _Map;
  	hasRequired_Map = 1;
  	var getNative = require_getNative(),
  	    root = require_root();

  	/* Built-in method references that are verified to be native. */
  	var Map = getNative(root, 'Map');

  	_Map = Map;
  	return _Map;
  }

  var _nativeCreate;
  var hasRequired_nativeCreate;

  function require_nativeCreate () {
  	if (hasRequired_nativeCreate) return _nativeCreate;
  	hasRequired_nativeCreate = 1;
  	var getNative = require_getNative();

  	/* Built-in method references that are verified to be native. */
  	var nativeCreate = getNative(Object, 'create');

  	_nativeCreate = nativeCreate;
  	return _nativeCreate;
  }

  var _hashClear;
  var hasRequired_hashClear;

  function require_hashClear () {
  	if (hasRequired_hashClear) return _hashClear;
  	hasRequired_hashClear = 1;
  	var nativeCreate = require_nativeCreate();

  	/**
  	 * Removes all key-value entries from the hash.
  	 *
  	 * @private
  	 * @name clear
  	 * @memberOf Hash
  	 */
  	function hashClear() {
  	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  	  this.size = 0;
  	}

  	_hashClear = hashClear;
  	return _hashClear;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  var _hashDelete;
  var hasRequired_hashDelete;

  function require_hashDelete () {
  	if (hasRequired_hashDelete) return _hashDelete;
  	hasRequired_hashDelete = 1;
  	function hashDelete(key) {
  	  var result = this.has(key) && delete this.__data__[key];
  	  this.size -= result ? 1 : 0;
  	  return result;
  	}

  	_hashDelete = hashDelete;
  	return _hashDelete;
  }

  var _hashGet;
  var hasRequired_hashGet;

  function require_hashGet () {
  	if (hasRequired_hashGet) return _hashGet;
  	hasRequired_hashGet = 1;
  	var nativeCreate = require_nativeCreate();

  	/** Used to stand-in for `undefined` hash values. */
  	var HASH_UNDEFINED = '__lodash_hash_undefined__';

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * Gets the hash value for `key`.
  	 *
  	 * @private
  	 * @name get
  	 * @memberOf Hash
  	 * @param {string} key The key of the value to get.
  	 * @returns {*} Returns the entry value.
  	 */
  	function hashGet(key) {
  	  var data = this.__data__;
  	  if (nativeCreate) {
  	    var result = data[key];
  	    return result === HASH_UNDEFINED ? undefined : result;
  	  }
  	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
  	}

  	_hashGet = hashGet;
  	return _hashGet;
  }

  var _hashHas;
  var hasRequired_hashHas;

  function require_hashHas () {
  	if (hasRequired_hashHas) return _hashHas;
  	hasRequired_hashHas = 1;
  	var nativeCreate = require_nativeCreate();

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * Checks if a hash value for `key` exists.
  	 *
  	 * @private
  	 * @name has
  	 * @memberOf Hash
  	 * @param {string} key The key of the entry to check.
  	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	 */
  	function hashHas(key) {
  	  var data = this.__data__;
  	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  	}

  	_hashHas = hashHas;
  	return _hashHas;
  }

  var _hashSet;
  var hasRequired_hashSet;

  function require_hashSet () {
  	if (hasRequired_hashSet) return _hashSet;
  	hasRequired_hashSet = 1;
  	var nativeCreate = require_nativeCreate();

  	/** Used to stand-in for `undefined` hash values. */
  	var HASH_UNDEFINED = '__lodash_hash_undefined__';

  	/**
  	 * Sets the hash `key` to `value`.
  	 *
  	 * @private
  	 * @name set
  	 * @memberOf Hash
  	 * @param {string} key The key of the value to set.
  	 * @param {*} value The value to set.
  	 * @returns {Object} Returns the hash instance.
  	 */
  	function hashSet(key, value) {
  	  var data = this.__data__;
  	  this.size += this.has(key) ? 0 : 1;
  	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  	  return this;
  	}

  	_hashSet = hashSet;
  	return _hashSet;
  }

  var _Hash;
  var hasRequired_Hash;

  function require_Hash () {
  	if (hasRequired_Hash) return _Hash;
  	hasRequired_Hash = 1;
  	var hashClear = require_hashClear(),
  	    hashDelete = require_hashDelete(),
  	    hashGet = require_hashGet(),
  	    hashHas = require_hashHas(),
  	    hashSet = require_hashSet();

  	/**
  	 * Creates a hash object.
  	 *
  	 * @private
  	 * @constructor
  	 * @param {Array} [entries] The key-value pairs to cache.
  	 */
  	function Hash(entries) {
  	  var index = -1,
  	      length = entries == null ? 0 : entries.length;

  	  this.clear();
  	  while (++index < length) {
  	    var entry = entries[index];
  	    this.set(entry[0], entry[1]);
  	  }
  	}

  	// Add methods to `Hash`.
  	Hash.prototype.clear = hashClear;
  	Hash.prototype['delete'] = hashDelete;
  	Hash.prototype.get = hashGet;
  	Hash.prototype.has = hashHas;
  	Hash.prototype.set = hashSet;

  	_Hash = Hash;
  	return _Hash;
  }

  var _mapCacheClear;
  var hasRequired_mapCacheClear;

  function require_mapCacheClear () {
  	if (hasRequired_mapCacheClear) return _mapCacheClear;
  	hasRequired_mapCacheClear = 1;
  	var Hash = require_Hash(),
  	    ListCache = require_ListCache(),
  	    Map = require_Map();

  	/**
  	 * Removes all key-value entries from the map.
  	 *
  	 * @private
  	 * @name clear
  	 * @memberOf MapCache
  	 */
  	function mapCacheClear() {
  	  this.size = 0;
  	  this.__data__ = {
  	    'hash': new Hash,
  	    'map': new (Map || ListCache),
  	    'string': new Hash
  	  };
  	}

  	_mapCacheClear = mapCacheClear;
  	return _mapCacheClear;
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */

  var _isKeyable;
  var hasRequired_isKeyable;

  function require_isKeyable () {
  	if (hasRequired_isKeyable) return _isKeyable;
  	hasRequired_isKeyable = 1;
  	function isKeyable(value) {
  	  var type = typeof value;
  	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
  	    ? (value !== '__proto__')
  	    : (value === null);
  	}

  	_isKeyable = isKeyable;
  	return _isKeyable;
  }

  var _getMapData;
  var hasRequired_getMapData;

  function require_getMapData () {
  	if (hasRequired_getMapData) return _getMapData;
  	hasRequired_getMapData = 1;
  	var isKeyable = require_isKeyable();

  	/**
  	 * Gets the data for `map`.
  	 *
  	 * @private
  	 * @param {Object} map The map to query.
  	 * @param {string} key The reference key.
  	 * @returns {*} Returns the map data.
  	 */
  	function getMapData(map, key) {
  	  var data = map.__data__;
  	  return isKeyable(key)
  	    ? data[typeof key == 'string' ? 'string' : 'hash']
  	    : data.map;
  	}

  	_getMapData = getMapData;
  	return _getMapData;
  }

  var _mapCacheDelete;
  var hasRequired_mapCacheDelete;

  function require_mapCacheDelete () {
  	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  	hasRequired_mapCacheDelete = 1;
  	var getMapData = require_getMapData();

  	/**
  	 * Removes `key` and its value from the map.
  	 *
  	 * @private
  	 * @name delete
  	 * @memberOf MapCache
  	 * @param {string} key The key of the value to remove.
  	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  	 */
  	function mapCacheDelete(key) {
  	  var result = getMapData(this, key)['delete'](key);
  	  this.size -= result ? 1 : 0;
  	  return result;
  	}

  	_mapCacheDelete = mapCacheDelete;
  	return _mapCacheDelete;
  }

  var _mapCacheGet;
  var hasRequired_mapCacheGet;

  function require_mapCacheGet () {
  	if (hasRequired_mapCacheGet) return _mapCacheGet;
  	hasRequired_mapCacheGet = 1;
  	var getMapData = require_getMapData();

  	/**
  	 * Gets the map value for `key`.
  	 *
  	 * @private
  	 * @name get
  	 * @memberOf MapCache
  	 * @param {string} key The key of the value to get.
  	 * @returns {*} Returns the entry value.
  	 */
  	function mapCacheGet(key) {
  	  return getMapData(this, key).get(key);
  	}

  	_mapCacheGet = mapCacheGet;
  	return _mapCacheGet;
  }

  var _mapCacheHas;
  var hasRequired_mapCacheHas;

  function require_mapCacheHas () {
  	if (hasRequired_mapCacheHas) return _mapCacheHas;
  	hasRequired_mapCacheHas = 1;
  	var getMapData = require_getMapData();

  	/**
  	 * Checks if a map value for `key` exists.
  	 *
  	 * @private
  	 * @name has
  	 * @memberOf MapCache
  	 * @param {string} key The key of the entry to check.
  	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	 */
  	function mapCacheHas(key) {
  	  return getMapData(this, key).has(key);
  	}

  	_mapCacheHas = mapCacheHas;
  	return _mapCacheHas;
  }

  var _mapCacheSet;
  var hasRequired_mapCacheSet;

  function require_mapCacheSet () {
  	if (hasRequired_mapCacheSet) return _mapCacheSet;
  	hasRequired_mapCacheSet = 1;
  	var getMapData = require_getMapData();

  	/**
  	 * Sets the map `key` to `value`.
  	 *
  	 * @private
  	 * @name set
  	 * @memberOf MapCache
  	 * @param {string} key The key of the value to set.
  	 * @param {*} value The value to set.
  	 * @returns {Object} Returns the map cache instance.
  	 */
  	function mapCacheSet(key, value) {
  	  var data = getMapData(this, key),
  	      size = data.size;

  	  data.set(key, value);
  	  this.size += data.size == size ? 0 : 1;
  	  return this;
  	}

  	_mapCacheSet = mapCacheSet;
  	return _mapCacheSet;
  }

  var _MapCache;
  var hasRequired_MapCache;

  function require_MapCache () {
  	if (hasRequired_MapCache) return _MapCache;
  	hasRequired_MapCache = 1;
  	var mapCacheClear = require_mapCacheClear(),
  	    mapCacheDelete = require_mapCacheDelete(),
  	    mapCacheGet = require_mapCacheGet(),
  	    mapCacheHas = require_mapCacheHas(),
  	    mapCacheSet = require_mapCacheSet();

  	/**
  	 * Creates a map cache object to store key-value pairs.
  	 *
  	 * @private
  	 * @constructor
  	 * @param {Array} [entries] The key-value pairs to cache.
  	 */
  	function MapCache(entries) {
  	  var index = -1,
  	      length = entries == null ? 0 : entries.length;

  	  this.clear();
  	  while (++index < length) {
  	    var entry = entries[index];
  	    this.set(entry[0], entry[1]);
  	  }
  	}

  	// Add methods to `MapCache`.
  	MapCache.prototype.clear = mapCacheClear;
  	MapCache.prototype['delete'] = mapCacheDelete;
  	MapCache.prototype.get = mapCacheGet;
  	MapCache.prototype.has = mapCacheHas;
  	MapCache.prototype.set = mapCacheSet;

  	_MapCache = MapCache;
  	return _MapCache;
  }

  var _stackSet;
  var hasRequired_stackSet;

  function require_stackSet () {
  	if (hasRequired_stackSet) return _stackSet;
  	hasRequired_stackSet = 1;
  	var ListCache = require_ListCache(),
  	    Map = require_Map(),
  	    MapCache = require_MapCache();

  	/** Used as the size to enable large array optimizations. */
  	var LARGE_ARRAY_SIZE = 200;

  	/**
  	 * Sets the stack `key` to `value`.
  	 *
  	 * @private
  	 * @name set
  	 * @memberOf Stack
  	 * @param {string} key The key of the value to set.
  	 * @param {*} value The value to set.
  	 * @returns {Object} Returns the stack cache instance.
  	 */
  	function stackSet(key, value) {
  	  var data = this.__data__;
  	  if (data instanceof ListCache) {
  	    var pairs = data.__data__;
  	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
  	      pairs.push([key, value]);
  	      this.size = ++data.size;
  	      return this;
  	    }
  	    data = this.__data__ = new MapCache(pairs);
  	  }
  	  data.set(key, value);
  	  this.size = data.size;
  	  return this;
  	}

  	_stackSet = stackSet;
  	return _stackSet;
  }

  var _Stack;
  var hasRequired_Stack;

  function require_Stack () {
  	if (hasRequired_Stack) return _Stack;
  	hasRequired_Stack = 1;
  	var ListCache = require_ListCache(),
  	    stackClear = require_stackClear(),
  	    stackDelete = require_stackDelete(),
  	    stackGet = require_stackGet(),
  	    stackHas = require_stackHas(),
  	    stackSet = require_stackSet();

  	/**
  	 * Creates a stack cache object to store key-value pairs.
  	 *
  	 * @private
  	 * @constructor
  	 * @param {Array} [entries] The key-value pairs to cache.
  	 */
  	function Stack(entries) {
  	  var data = this.__data__ = new ListCache(entries);
  	  this.size = data.size;
  	}

  	// Add methods to `Stack`.
  	Stack.prototype.clear = stackClear;
  	Stack.prototype['delete'] = stackDelete;
  	Stack.prototype.get = stackGet;
  	Stack.prototype.has = stackHas;
  	Stack.prototype.set = stackSet;

  	_Stack = Stack;
  	return _Stack;
  }

  /** Used to stand-in for `undefined` hash values. */

  var _setCacheAdd;
  var hasRequired_setCacheAdd;

  function require_setCacheAdd () {
  	if (hasRequired_setCacheAdd) return _setCacheAdd;
  	hasRequired_setCacheAdd = 1;
  	var HASH_UNDEFINED = '__lodash_hash_undefined__';

  	/**
  	 * Adds `value` to the array cache.
  	 *
  	 * @private
  	 * @name add
  	 * @memberOf SetCache
  	 * @alias push
  	 * @param {*} value The value to cache.
  	 * @returns {Object} Returns the cache instance.
  	 */
  	function setCacheAdd(value) {
  	  this.__data__.set(value, HASH_UNDEFINED);
  	  return this;
  	}

  	_setCacheAdd = setCacheAdd;
  	return _setCacheAdd;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */

  var _setCacheHas;
  var hasRequired_setCacheHas;

  function require_setCacheHas () {
  	if (hasRequired_setCacheHas) return _setCacheHas;
  	hasRequired_setCacheHas = 1;
  	function setCacheHas(value) {
  	  return this.__data__.has(value);
  	}

  	_setCacheHas = setCacheHas;
  	return _setCacheHas;
  }

  var _SetCache;
  var hasRequired_SetCache;

  function require_SetCache () {
  	if (hasRequired_SetCache) return _SetCache;
  	hasRequired_SetCache = 1;
  	var MapCache = require_MapCache(),
  	    setCacheAdd = require_setCacheAdd(),
  	    setCacheHas = require_setCacheHas();

  	/**
  	 *
  	 * Creates an array cache object to store unique values.
  	 *
  	 * @private
  	 * @constructor
  	 * @param {Array} [values] The values to cache.
  	 */
  	function SetCache(values) {
  	  var index = -1,
  	      length = values == null ? 0 : values.length;

  	  this.__data__ = new MapCache;
  	  while (++index < length) {
  	    this.add(values[index]);
  	  }
  	}

  	// Add methods to `SetCache`.
  	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  	SetCache.prototype.has = setCacheHas;

  	_SetCache = SetCache;
  	return _SetCache;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */

  var _arraySome;
  var hasRequired_arraySome;

  function require_arraySome () {
  	if (hasRequired_arraySome) return _arraySome;
  	hasRequired_arraySome = 1;
  	function arraySome(array, predicate) {
  	  var index = -1,
  	      length = array == null ? 0 : array.length;

  	  while (++index < length) {
  	    if (predicate(array[index], index, array)) {
  	      return true;
  	    }
  	  }
  	  return false;
  	}

  	_arraySome = arraySome;
  	return _arraySome;
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  var _cacheHas;
  var hasRequired_cacheHas;

  function require_cacheHas () {
  	if (hasRequired_cacheHas) return _cacheHas;
  	hasRequired_cacheHas = 1;
  	function cacheHas(cache, key) {
  	  return cache.has(key);
  	}

  	_cacheHas = cacheHas;
  	return _cacheHas;
  }

  var _equalArrays;
  var hasRequired_equalArrays;

  function require_equalArrays () {
  	if (hasRequired_equalArrays) return _equalArrays;
  	hasRequired_equalArrays = 1;
  	var SetCache = require_SetCache(),
  	    arraySome = require_arraySome(),
  	    cacheHas = require_cacheHas();

  	/** Used to compose bitmasks for value comparisons. */
  	var COMPARE_PARTIAL_FLAG = 1,
  	    COMPARE_UNORDERED_FLAG = 2;

  	/**
  	 * A specialized version of `baseIsEqualDeep` for arrays with support for
  	 * partial deep comparisons.
  	 *
  	 * @private
  	 * @param {Array} array The array to compare.
  	 * @param {Array} other The other array to compare.
  	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	 * @param {Function} customizer The function to customize comparisons.
  	 * @param {Function} equalFunc The function to determine equivalents of values.
  	 * @param {Object} stack Tracks traversed `array` and `other` objects.
  	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
  	 */
  	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
  	      arrLength = array.length,
  	      othLength = other.length;

  	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
  	    return false;
  	  }
  	  // Check that cyclic values are equal.
  	  var arrStacked = stack.get(array);
  	  var othStacked = stack.get(other);
  	  if (arrStacked && othStacked) {
  	    return arrStacked == other && othStacked == array;
  	  }
  	  var index = -1,
  	      result = true,
  	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  	  stack.set(array, other);
  	  stack.set(other, array);

  	  // Ignore non-index properties.
  	  while (++index < arrLength) {
  	    var arrValue = array[index],
  	        othValue = other[index];

  	    if (customizer) {
  	      var compared = isPartial
  	        ? customizer(othValue, arrValue, index, other, array, stack)
  	        : customizer(arrValue, othValue, index, array, other, stack);
  	    }
  	    if (compared !== undefined) {
  	      if (compared) {
  	        continue;
  	      }
  	      result = false;
  	      break;
  	    }
  	    // Recursively compare arrays (susceptible to call stack limits).
  	    if (seen) {
  	      if (!arraySome(other, function(othValue, othIndex) {
  	            if (!cacheHas(seen, othIndex) &&
  	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
  	              return seen.push(othIndex);
  	            }
  	          })) {
  	        result = false;
  	        break;
  	      }
  	    } else if (!(
  	          arrValue === othValue ||
  	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
  	        )) {
  	      result = false;
  	      break;
  	    }
  	  }
  	  stack['delete'](array);
  	  stack['delete'](other);
  	  return result;
  	}

  	_equalArrays = equalArrays;
  	return _equalArrays;
  }

  var _Uint8Array;
  var hasRequired_Uint8Array;

  function require_Uint8Array () {
  	if (hasRequired_Uint8Array) return _Uint8Array;
  	hasRequired_Uint8Array = 1;
  	var root = require_root();

  	/** Built-in value references. */
  	var Uint8Array = root.Uint8Array;

  	_Uint8Array = Uint8Array;
  	return _Uint8Array;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */

  var _mapToArray;
  var hasRequired_mapToArray;

  function require_mapToArray () {
  	if (hasRequired_mapToArray) return _mapToArray;
  	hasRequired_mapToArray = 1;
  	function mapToArray(map) {
  	  var index = -1,
  	      result = Array(map.size);

  	  map.forEach(function(value, key) {
  	    result[++index] = [key, value];
  	  });
  	  return result;
  	}

  	_mapToArray = mapToArray;
  	return _mapToArray;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */

  var _setToArray;
  var hasRequired_setToArray;

  function require_setToArray () {
  	if (hasRequired_setToArray) return _setToArray;
  	hasRequired_setToArray = 1;
  	function setToArray(set) {
  	  var index = -1,
  	      result = Array(set.size);

  	  set.forEach(function(value) {
  	    result[++index] = value;
  	  });
  	  return result;
  	}

  	_setToArray = setToArray;
  	return _setToArray;
  }

  var _equalByTag;
  var hasRequired_equalByTag;

  function require_equalByTag () {
  	if (hasRequired_equalByTag) return _equalByTag;
  	hasRequired_equalByTag = 1;
  	var Symbol = require_Symbol(),
  	    Uint8Array = require_Uint8Array(),
  	    eq = requireEq(),
  	    equalArrays = require_equalArrays(),
  	    mapToArray = require_mapToArray(),
  	    setToArray = require_setToArray();

  	/** Used to compose bitmasks for value comparisons. */
  	var COMPARE_PARTIAL_FLAG = 1,
  	    COMPARE_UNORDERED_FLAG = 2;

  	/** `Object#toString` result references. */
  	var boolTag = '[object Boolean]',
  	    dateTag = '[object Date]',
  	    errorTag = '[object Error]',
  	    mapTag = '[object Map]',
  	    numberTag = '[object Number]',
  	    regexpTag = '[object RegExp]',
  	    setTag = '[object Set]',
  	    stringTag = '[object String]',
  	    symbolTag = '[object Symbol]';

  	var arrayBufferTag = '[object ArrayBuffer]',
  	    dataViewTag = '[object DataView]';

  	/** Used to convert symbols to primitives and strings. */
  	var symbolProto = Symbol ? Symbol.prototype : undefined,
  	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  	/**
  	 * A specialized version of `baseIsEqualDeep` for comparing objects of
  	 * the same `toStringTag`.
  	 *
  	 * **Note:** This function only supports comparing values with tags of
  	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
  	 *
  	 * @private
  	 * @param {Object} object The object to compare.
  	 * @param {Object} other The other object to compare.
  	 * @param {string} tag The `toStringTag` of the objects to compare.
  	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	 * @param {Function} customizer The function to customize comparisons.
  	 * @param {Function} equalFunc The function to determine equivalents of values.
  	 * @param {Object} stack Tracks traversed `object` and `other` objects.
  	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	 */
  	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  	  switch (tag) {
  	    case dataViewTag:
  	      if ((object.byteLength != other.byteLength) ||
  	          (object.byteOffset != other.byteOffset)) {
  	        return false;
  	      }
  	      object = object.buffer;
  	      other = other.buffer;

  	    case arrayBufferTag:
  	      if ((object.byteLength != other.byteLength) ||
  	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
  	        return false;
  	      }
  	      return true;

  	    case boolTag:
  	    case dateTag:
  	    case numberTag:
  	      // Coerce booleans to `1` or `0` and dates to milliseconds.
  	      // Invalid dates are coerced to `NaN`.
  	      return eq(+object, +other);

  	    case errorTag:
  	      return object.name == other.name && object.message == other.message;

  	    case regexpTag:
  	    case stringTag:
  	      // Coerce regexes to strings and treat strings, primitives and objects,
  	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
  	      // for more details.
  	      return object == (other + '');

  	    case mapTag:
  	      var convert = mapToArray;

  	    case setTag:
  	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
  	      convert || (convert = setToArray);

  	      if (object.size != other.size && !isPartial) {
  	        return false;
  	      }
  	      // Assume cyclic values are equal.
  	      var stacked = stack.get(object);
  	      if (stacked) {
  	        return stacked == other;
  	      }
  	      bitmask |= COMPARE_UNORDERED_FLAG;

  	      // Recursively compare objects (susceptible to call stack limits).
  	      stack.set(object, other);
  	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
  	      stack['delete'](object);
  	      return result;

  	    case symbolTag:
  	      if (symbolValueOf) {
  	        return symbolValueOf.call(object) == symbolValueOf.call(other);
  	      }
  	  }
  	  return false;
  	}

  	_equalByTag = equalByTag;
  	return _equalByTag;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */

  var _arrayPush;
  var hasRequired_arrayPush;

  function require_arrayPush () {
  	if (hasRequired_arrayPush) return _arrayPush;
  	hasRequired_arrayPush = 1;
  	function arrayPush(array, values) {
  	  var index = -1,
  	      length = values.length,
  	      offset = array.length;

  	  while (++index < length) {
  	    array[offset + index] = values[index];
  	  }
  	  return array;
  	}

  	_arrayPush = arrayPush;
  	return _arrayPush;
  }

  var _baseGetAllKeys;
  var hasRequired_baseGetAllKeys;

  function require_baseGetAllKeys () {
  	if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  	hasRequired_baseGetAllKeys = 1;
  	var arrayPush = require_arrayPush(),
  	    isArray = requireIsArray();

  	/**
  	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
  	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
  	 * symbols of `object`.
  	 *
  	 * @private
  	 * @param {Object} object The object to query.
  	 * @param {Function} keysFunc The function to get the keys of `object`.
  	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
  	 * @returns {Array} Returns the array of property names and symbols.
  	 */
  	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  	  var result = keysFunc(object);
  	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  	}

  	_baseGetAllKeys = baseGetAllKeys;
  	return _baseGetAllKeys;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */

  var _arrayFilter;
  var hasRequired_arrayFilter;

  function require_arrayFilter () {
  	if (hasRequired_arrayFilter) return _arrayFilter;
  	hasRequired_arrayFilter = 1;
  	function arrayFilter(array, predicate) {
  	  var index = -1,
  	      length = array == null ? 0 : array.length,
  	      resIndex = 0,
  	      result = [];

  	  while (++index < length) {
  	    var value = array[index];
  	    if (predicate(value, index, array)) {
  	      result[resIndex++] = value;
  	    }
  	  }
  	  return result;
  	}

  	_arrayFilter = arrayFilter;
  	return _arrayFilter;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  var stubArray_1;
  var hasRequiredStubArray;

  function requireStubArray () {
  	if (hasRequiredStubArray) return stubArray_1;
  	hasRequiredStubArray = 1;
  	function stubArray() {
  	  return [];
  	}

  	stubArray_1 = stubArray;
  	return stubArray_1;
  }

  var _getSymbols;
  var hasRequired_getSymbols;

  function require_getSymbols () {
  	if (hasRequired_getSymbols) return _getSymbols;
  	hasRequired_getSymbols = 1;
  	var arrayFilter = require_arrayFilter(),
  	    stubArray = requireStubArray();

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Built-in value references. */
  	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

  	/* Built-in method references for those with the same name as other `lodash` methods. */
  	var nativeGetSymbols = Object.getOwnPropertySymbols;

  	/**
  	 * Creates an array of the own enumerable symbols of `object`.
  	 *
  	 * @private
  	 * @param {Object} object The object to query.
  	 * @returns {Array} Returns the array of symbols.
  	 */
  	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  	  if (object == null) {
  	    return [];
  	  }
  	  object = Object(object);
  	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
  	    return propertyIsEnumerable.call(object, symbol);
  	  });
  	};

  	_getSymbols = getSymbols;
  	return _getSymbols;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */

  var _baseTimes;
  var hasRequired_baseTimes;

  function require_baseTimes () {
  	if (hasRequired_baseTimes) return _baseTimes;
  	hasRequired_baseTimes = 1;
  	function baseTimes(n, iteratee) {
  	  var index = -1,
  	      result = Array(n);

  	  while (++index < n) {
  	    result[index] = iteratee(index);
  	  }
  	  return result;
  	}

  	_baseTimes = baseTimes;
  	return _baseTimes;
  }

  var _baseIsArguments;
  var hasRequired_baseIsArguments;

  function require_baseIsArguments () {
  	if (hasRequired_baseIsArguments) return _baseIsArguments;
  	hasRequired_baseIsArguments = 1;
  	var baseGetTag = require_baseGetTag(),
  	    isObjectLike = requireIsObjectLike();

  	/** `Object#toString` result references. */
  	var argsTag = '[object Arguments]';

  	/**
  	 * The base implementation of `_.isArguments`.
  	 *
  	 * @private
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
  	 */
  	function baseIsArguments(value) {
  	  return isObjectLike(value) && baseGetTag(value) == argsTag;
  	}

  	_baseIsArguments = baseIsArguments;
  	return _baseIsArguments;
  }

  var isArguments_1;
  var hasRequiredIsArguments;

  function requireIsArguments () {
  	if (hasRequiredIsArguments) return isArguments_1;
  	hasRequiredIsArguments = 1;
  	var baseIsArguments = require_baseIsArguments(),
  	    isObjectLike = requireIsObjectLike();

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/** Built-in value references. */
  	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

  	/**
  	 * Checks if `value` is likely an `arguments` object.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 0.1.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
  	 *  else `false`.
  	 * @example
  	 *
  	 * _.isArguments(function() { return arguments; }());
  	 * // => true
  	 *
  	 * _.isArguments([1, 2, 3]);
  	 * // => false
  	 */
  	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
  	    !propertyIsEnumerable.call(value, 'callee');
  	};

  	isArguments_1 = isArguments;
  	return isArguments_1;
  }

  var isBuffer = {exports: {}};

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */

  var stubFalse_1;
  var hasRequiredStubFalse;

  function requireStubFalse () {
  	if (hasRequiredStubFalse) return stubFalse_1;
  	hasRequiredStubFalse = 1;
  	function stubFalse() {
  	  return false;
  	}

  	stubFalse_1 = stubFalse;
  	return stubFalse_1;
  }

  isBuffer.exports;

  var hasRequiredIsBuffer;

  function requireIsBuffer () {
  	if (hasRequiredIsBuffer) return isBuffer.exports;
  	hasRequiredIsBuffer = 1;
  	(function (module, exports$1) {
  		var root = require_root(),
  		    stubFalse = requireStubFalse();

  		/** Detect free variable `exports`. */
  		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

  		/** Detect free variable `module`. */
  		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  		/** Detect the popular CommonJS extension `module.exports`. */
  		var moduleExports = freeModule && freeModule.exports === freeExports;

  		/** Built-in value references. */
  		var Buffer = moduleExports ? root.Buffer : undefined;

  		/* Built-in method references for those with the same name as other `lodash` methods. */
  		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  		/**
  		 * Checks if `value` is a buffer.
  		 *
  		 * @static
  		 * @memberOf _
  		 * @since 4.3.0
  		 * @category Lang
  		 * @param {*} value The value to check.
  		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
  		 * @example
  		 *
  		 * _.isBuffer(new Buffer(2));
  		 * // => true
  		 *
  		 * _.isBuffer(new Uint8Array(2));
  		 * // => false
  		 */
  		var isBuffer = nativeIsBuffer || stubFalse;

  		module.exports = isBuffer; 
  	} (isBuffer, isBuffer.exports));
  	return isBuffer.exports;
  }

  /** Used as references for various `Number` constants. */

  var _isIndex;
  var hasRequired_isIndex;

  function require_isIndex () {
  	if (hasRequired_isIndex) return _isIndex;
  	hasRequired_isIndex = 1;
  	var MAX_SAFE_INTEGER = 9007199254740991;

  	/** Used to detect unsigned integer values. */
  	var reIsUint = /^(?:0|[1-9]\d*)$/;

  	/**
  	 * Checks if `value` is a valid array-like index.
  	 *
  	 * @private
  	 * @param {*} value The value to check.
  	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
  	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
  	 */
  	function isIndex(value, length) {
  	  var type = typeof value;
  	  length = length == null ? MAX_SAFE_INTEGER : length;

  	  return !!length &&
  	    (type == 'number' ||
  	      (type != 'symbol' && reIsUint.test(value))) &&
  	        (value > -1 && value % 1 == 0 && value < length);
  	}

  	_isIndex = isIndex;
  	return _isIndex;
  }

  /** Used as references for various `Number` constants. */

  var isLength_1;
  var hasRequiredIsLength;

  function requireIsLength () {
  	if (hasRequiredIsLength) return isLength_1;
  	hasRequiredIsLength = 1;
  	var MAX_SAFE_INTEGER = 9007199254740991;

  	/**
  	 * Checks if `value` is a valid array-like length.
  	 *
  	 * **Note:** This method is loosely based on
  	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 4.0.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
  	 * @example
  	 *
  	 * _.isLength(3);
  	 * // => true
  	 *
  	 * _.isLength(Number.MIN_VALUE);
  	 * // => false
  	 *
  	 * _.isLength(Infinity);
  	 * // => false
  	 *
  	 * _.isLength('3');
  	 * // => false
  	 */
  	function isLength(value) {
  	  return typeof value == 'number' &&
  	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  	}

  	isLength_1 = isLength;
  	return isLength_1;
  }

  var _baseIsTypedArray;
  var hasRequired_baseIsTypedArray;

  function require_baseIsTypedArray () {
  	if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  	hasRequired_baseIsTypedArray = 1;
  	var baseGetTag = require_baseGetTag(),
  	    isLength = requireIsLength(),
  	    isObjectLike = requireIsObjectLike();

  	/** `Object#toString` result references. */
  	var argsTag = '[object Arguments]',
  	    arrayTag = '[object Array]',
  	    boolTag = '[object Boolean]',
  	    dateTag = '[object Date]',
  	    errorTag = '[object Error]',
  	    funcTag = '[object Function]',
  	    mapTag = '[object Map]',
  	    numberTag = '[object Number]',
  	    objectTag = '[object Object]',
  	    regexpTag = '[object RegExp]',
  	    setTag = '[object Set]',
  	    stringTag = '[object String]',
  	    weakMapTag = '[object WeakMap]';

  	var arrayBufferTag = '[object ArrayBuffer]',
  	    dataViewTag = '[object DataView]',
  	    float32Tag = '[object Float32Array]',
  	    float64Tag = '[object Float64Array]',
  	    int8Tag = '[object Int8Array]',
  	    int16Tag = '[object Int16Array]',
  	    int32Tag = '[object Int32Array]',
  	    uint8Tag = '[object Uint8Array]',
  	    uint8ClampedTag = '[object Uint8ClampedArray]',
  	    uint16Tag = '[object Uint16Array]',
  	    uint32Tag = '[object Uint32Array]';

  	/** Used to identify `toStringTag` values of typed arrays. */
  	var typedArrayTags = {};
  	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  	typedArrayTags[uint32Tag] = true;
  	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  	typedArrayTags[setTag] = typedArrayTags[stringTag] =
  	typedArrayTags[weakMapTag] = false;

  	/**
  	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
  	 *
  	 * @private
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
  	 */
  	function baseIsTypedArray(value) {
  	  return isObjectLike(value) &&
  	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  	}

  	_baseIsTypedArray = baseIsTypedArray;
  	return _baseIsTypedArray;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  var _baseUnary;
  var hasRequired_baseUnary;

  function require_baseUnary () {
  	if (hasRequired_baseUnary) return _baseUnary;
  	hasRequired_baseUnary = 1;
  	function baseUnary(func) {
  	  return function(value) {
  	    return func(value);
  	  };
  	}

  	_baseUnary = baseUnary;
  	return _baseUnary;
  }

  var _nodeUtil = {exports: {}};

  _nodeUtil.exports;

  var hasRequired_nodeUtil;

  function require_nodeUtil () {
  	if (hasRequired_nodeUtil) return _nodeUtil.exports;
  	hasRequired_nodeUtil = 1;
  	(function (module, exports$1) {
  		var freeGlobal = require_freeGlobal();

  		/** Detect free variable `exports`. */
  		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

  		/** Detect free variable `module`. */
  		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  		/** Detect the popular CommonJS extension `module.exports`. */
  		var moduleExports = freeModule && freeModule.exports === freeExports;

  		/** Detect free variable `process` from Node.js. */
  		var freeProcess = moduleExports && freeGlobal.process;

  		/** Used to access faster Node.js helpers. */
  		var nodeUtil = (function() {
  		  try {
  		    // Use `util.types` for Node.js 10+.
  		    var types = freeModule && freeModule.require && freeModule.require('util').types;

  		    if (types) {
  		      return types;
  		    }

  		    // Legacy `process.binding('util')` for Node.js < 10.
  		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  		  } catch (e) {}
  		}());

  		module.exports = nodeUtil; 
  	} (_nodeUtil, _nodeUtil.exports));
  	return _nodeUtil.exports;
  }

  var isTypedArray_1;
  var hasRequiredIsTypedArray;

  function requireIsTypedArray () {
  	if (hasRequiredIsTypedArray) return isTypedArray_1;
  	hasRequiredIsTypedArray = 1;
  	var baseIsTypedArray = require_baseIsTypedArray(),
  	    baseUnary = require_baseUnary(),
  	    nodeUtil = require_nodeUtil();

  	/* Node.js helper references. */
  	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  	/**
  	 * Checks if `value` is classified as a typed array.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 3.0.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
  	 * @example
  	 *
  	 * _.isTypedArray(new Uint8Array);
  	 * // => true
  	 *
  	 * _.isTypedArray([]);
  	 * // => false
  	 */
  	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  	isTypedArray_1 = isTypedArray;
  	return isTypedArray_1;
  }

  var _arrayLikeKeys;
  var hasRequired_arrayLikeKeys;

  function require_arrayLikeKeys () {
  	if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  	hasRequired_arrayLikeKeys = 1;
  	var baseTimes = require_baseTimes(),
  	    isArguments = requireIsArguments(),
  	    isArray = requireIsArray(),
  	    isBuffer = requireIsBuffer(),
  	    isIndex = require_isIndex(),
  	    isTypedArray = requireIsTypedArray();

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * Creates an array of the enumerable property names of the array-like `value`.
  	 *
  	 * @private
  	 * @param {*} value The value to query.
  	 * @param {boolean} inherited Specify returning inherited property names.
  	 * @returns {Array} Returns the array of property names.
  	 */
  	function arrayLikeKeys(value, inherited) {
  	  var isArr = isArray(value),
  	      isArg = !isArr && isArguments(value),
  	      isBuff = !isArr && !isArg && isBuffer(value),
  	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
  	      skipIndexes = isArr || isArg || isBuff || isType,
  	      result = skipIndexes ? baseTimes(value.length, String) : [],
  	      length = result.length;

  	  for (var key in value) {
  	    if ((inherited || hasOwnProperty.call(value, key)) &&
  	        !(skipIndexes && (
  	           // Safari 9 has enumerable `arguments.length` in strict mode.
  	           key == 'length' ||
  	           // Node.js 0.10 has enumerable non-index properties on buffers.
  	           (isBuff && (key == 'offset' || key == 'parent')) ||
  	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
  	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
  	           // Skip index properties.
  	           isIndex(key, length)
  	        ))) {
  	      result.push(key);
  	    }
  	  }
  	  return result;
  	}

  	_arrayLikeKeys = arrayLikeKeys;
  	return _arrayLikeKeys;
  }

  /** Used for built-in method references. */

  var _isPrototype;
  var hasRequired_isPrototype;

  function require_isPrototype () {
  	if (hasRequired_isPrototype) return _isPrototype;
  	hasRequired_isPrototype = 1;
  	var objectProto = Object.prototype;

  	/**
  	 * Checks if `value` is likely a prototype object.
  	 *
  	 * @private
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
  	 */
  	function isPrototype(value) {
  	  var Ctor = value && value.constructor,
  	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  	  return value === proto;
  	}

  	_isPrototype = isPrototype;
  	return _isPrototype;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */

  var _overArg;
  var hasRequired_overArg;

  function require_overArg () {
  	if (hasRequired_overArg) return _overArg;
  	hasRequired_overArg = 1;
  	function overArg(func, transform) {
  	  return function(arg) {
  	    return func(transform(arg));
  	  };
  	}

  	_overArg = overArg;
  	return _overArg;
  }

  var _nativeKeys;
  var hasRequired_nativeKeys;

  function require_nativeKeys () {
  	if (hasRequired_nativeKeys) return _nativeKeys;
  	hasRequired_nativeKeys = 1;
  	var overArg = require_overArg();

  	/* Built-in method references for those with the same name as other `lodash` methods. */
  	var nativeKeys = overArg(Object.keys, Object);

  	_nativeKeys = nativeKeys;
  	return _nativeKeys;
  }

  var _baseKeys;
  var hasRequired_baseKeys;

  function require_baseKeys () {
  	if (hasRequired_baseKeys) return _baseKeys;
  	hasRequired_baseKeys = 1;
  	var isPrototype = require_isPrototype(),
  	    nativeKeys = require_nativeKeys();

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
  	 *
  	 * @private
  	 * @param {Object} object The object to query.
  	 * @returns {Array} Returns the array of property names.
  	 */
  	function baseKeys(object) {
  	  if (!isPrototype(object)) {
  	    return nativeKeys(object);
  	  }
  	  var result = [];
  	  for (var key in Object(object)) {
  	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
  	      result.push(key);
  	    }
  	  }
  	  return result;
  	}

  	_baseKeys = baseKeys;
  	return _baseKeys;
  }

  var isArrayLike_1;
  var hasRequiredIsArrayLike;

  function requireIsArrayLike () {
  	if (hasRequiredIsArrayLike) return isArrayLike_1;
  	hasRequiredIsArrayLike = 1;
  	var isFunction = requireIsFunction(),
  	    isLength = requireIsLength();

  	/**
  	 * Checks if `value` is array-like. A value is considered array-like if it's
  	 * not a function and has a `value.length` that's an integer greater than or
  	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 4.0.0
  	 * @category Lang
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
  	 * @example
  	 *
  	 * _.isArrayLike([1, 2, 3]);
  	 * // => true
  	 *
  	 * _.isArrayLike(document.body.children);
  	 * // => true
  	 *
  	 * _.isArrayLike('abc');
  	 * // => true
  	 *
  	 * _.isArrayLike(_.noop);
  	 * // => false
  	 */
  	function isArrayLike(value) {
  	  return value != null && isLength(value.length) && !isFunction(value);
  	}

  	isArrayLike_1 = isArrayLike;
  	return isArrayLike_1;
  }

  var keys_1;
  var hasRequiredKeys;

  function requireKeys () {
  	if (hasRequiredKeys) return keys_1;
  	hasRequiredKeys = 1;
  	var arrayLikeKeys = require_arrayLikeKeys(),
  	    baseKeys = require_baseKeys(),
  	    isArrayLike = requireIsArrayLike();

  	/**
  	 * Creates an array of the own enumerable property names of `object`.
  	 *
  	 * **Note:** Non-object values are coerced to objects. See the
  	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
  	 * for more details.
  	 *
  	 * @static
  	 * @since 0.1.0
  	 * @memberOf _
  	 * @category Object
  	 * @param {Object} object The object to query.
  	 * @returns {Array} Returns the array of property names.
  	 * @example
  	 *
  	 * function Foo() {
  	 *   this.a = 1;
  	 *   this.b = 2;
  	 * }
  	 *
  	 * Foo.prototype.c = 3;
  	 *
  	 * _.keys(new Foo);
  	 * // => ['a', 'b'] (iteration order is not guaranteed)
  	 *
  	 * _.keys('hi');
  	 * // => ['0', '1']
  	 */
  	function keys(object) {
  	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  	}

  	keys_1 = keys;
  	return keys_1;
  }

  var _getAllKeys;
  var hasRequired_getAllKeys;

  function require_getAllKeys () {
  	if (hasRequired_getAllKeys) return _getAllKeys;
  	hasRequired_getAllKeys = 1;
  	var baseGetAllKeys = require_baseGetAllKeys(),
  	    getSymbols = require_getSymbols(),
  	    keys = requireKeys();

  	/**
  	 * Creates an array of own enumerable property names and symbols of `object`.
  	 *
  	 * @private
  	 * @param {Object} object The object to query.
  	 * @returns {Array} Returns the array of property names and symbols.
  	 */
  	function getAllKeys(object) {
  	  return baseGetAllKeys(object, keys, getSymbols);
  	}

  	_getAllKeys = getAllKeys;
  	return _getAllKeys;
  }

  var _equalObjects;
  var hasRequired_equalObjects;

  function require_equalObjects () {
  	if (hasRequired_equalObjects) return _equalObjects;
  	hasRequired_equalObjects = 1;
  	var getAllKeys = require_getAllKeys();

  	/** Used to compose bitmasks for value comparisons. */
  	var COMPARE_PARTIAL_FLAG = 1;

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * A specialized version of `baseIsEqualDeep` for objects with support for
  	 * partial deep comparisons.
  	 *
  	 * @private
  	 * @param {Object} object The object to compare.
  	 * @param {Object} other The other object to compare.
  	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	 * @param {Function} customizer The function to customize comparisons.
  	 * @param {Function} equalFunc The function to determine equivalents of values.
  	 * @param {Object} stack Tracks traversed `object` and `other` objects.
  	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	 */
  	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
  	      objProps = getAllKeys(object),
  	      objLength = objProps.length,
  	      othProps = getAllKeys(other),
  	      othLength = othProps.length;

  	  if (objLength != othLength && !isPartial) {
  	    return false;
  	  }
  	  var index = objLength;
  	  while (index--) {
  	    var key = objProps[index];
  	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
  	      return false;
  	    }
  	  }
  	  // Check that cyclic values are equal.
  	  var objStacked = stack.get(object);
  	  var othStacked = stack.get(other);
  	  if (objStacked && othStacked) {
  	    return objStacked == other && othStacked == object;
  	  }
  	  var result = true;
  	  stack.set(object, other);
  	  stack.set(other, object);

  	  var skipCtor = isPartial;
  	  while (++index < objLength) {
  	    key = objProps[index];
  	    var objValue = object[key],
  	        othValue = other[key];

  	    if (customizer) {
  	      var compared = isPartial
  	        ? customizer(othValue, objValue, key, other, object, stack)
  	        : customizer(objValue, othValue, key, object, other, stack);
  	    }
  	    // Recursively compare objects (susceptible to call stack limits).
  	    if (!(compared === undefined
  	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
  	          : compared
  	        )) {
  	      result = false;
  	      break;
  	    }
  	    skipCtor || (skipCtor = key == 'constructor');
  	  }
  	  if (result && !skipCtor) {
  	    var objCtor = object.constructor,
  	        othCtor = other.constructor;

  	    // Non `Object` object instances with different constructors are not equal.
  	    if (objCtor != othCtor &&
  	        ('constructor' in object && 'constructor' in other) &&
  	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
  	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
  	      result = false;
  	    }
  	  }
  	  stack['delete'](object);
  	  stack['delete'](other);
  	  return result;
  	}

  	_equalObjects = equalObjects;
  	return _equalObjects;
  }

  var _DataView;
  var hasRequired_DataView;

  function require_DataView () {
  	if (hasRequired_DataView) return _DataView;
  	hasRequired_DataView = 1;
  	var getNative = require_getNative(),
  	    root = require_root();

  	/* Built-in method references that are verified to be native. */
  	var DataView = getNative(root, 'DataView');

  	_DataView = DataView;
  	return _DataView;
  }

  var _Promise;
  var hasRequired_Promise;

  function require_Promise () {
  	if (hasRequired_Promise) return _Promise;
  	hasRequired_Promise = 1;
  	var getNative = require_getNative(),
  	    root = require_root();

  	/* Built-in method references that are verified to be native. */
  	var Promise = getNative(root, 'Promise');

  	_Promise = Promise;
  	return _Promise;
  }

  var _Set;
  var hasRequired_Set;

  function require_Set () {
  	if (hasRequired_Set) return _Set;
  	hasRequired_Set = 1;
  	var getNative = require_getNative(),
  	    root = require_root();

  	/* Built-in method references that are verified to be native. */
  	var Set = getNative(root, 'Set');

  	_Set = Set;
  	return _Set;
  }

  var _WeakMap;
  var hasRequired_WeakMap;

  function require_WeakMap () {
  	if (hasRequired_WeakMap) return _WeakMap;
  	hasRequired_WeakMap = 1;
  	var getNative = require_getNative(),
  	    root = require_root();

  	/* Built-in method references that are verified to be native. */
  	var WeakMap = getNative(root, 'WeakMap');

  	_WeakMap = WeakMap;
  	return _WeakMap;
  }

  var _getTag;
  var hasRequired_getTag;

  function require_getTag () {
  	if (hasRequired_getTag) return _getTag;
  	hasRequired_getTag = 1;
  	var DataView = require_DataView(),
  	    Map = require_Map(),
  	    Promise = require_Promise(),
  	    Set = require_Set(),
  	    WeakMap = require_WeakMap(),
  	    baseGetTag = require_baseGetTag(),
  	    toSource = require_toSource();

  	/** `Object#toString` result references. */
  	var mapTag = '[object Map]',
  	    objectTag = '[object Object]',
  	    promiseTag = '[object Promise]',
  	    setTag = '[object Set]',
  	    weakMapTag = '[object WeakMap]';

  	var dataViewTag = '[object DataView]';

  	/** Used to detect maps, sets, and weakmaps. */
  	var dataViewCtorString = toSource(DataView),
  	    mapCtorString = toSource(Map),
  	    promiseCtorString = toSource(Promise),
  	    setCtorString = toSource(Set),
  	    weakMapCtorString = toSource(WeakMap);

  	/**
  	 * Gets the `toStringTag` of `value`.
  	 *
  	 * @private
  	 * @param {*} value The value to query.
  	 * @returns {string} Returns the `toStringTag`.
  	 */
  	var getTag = baseGetTag;

  	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
  	    (Map && getTag(new Map) != mapTag) ||
  	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
  	    (Set && getTag(new Set) != setTag) ||
  	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  	  getTag = function(value) {
  	    var result = baseGetTag(value),
  	        Ctor = result == objectTag ? value.constructor : undefined,
  	        ctorString = Ctor ? toSource(Ctor) : '';

  	    if (ctorString) {
  	      switch (ctorString) {
  	        case dataViewCtorString: return dataViewTag;
  	        case mapCtorString: return mapTag;
  	        case promiseCtorString: return promiseTag;
  	        case setCtorString: return setTag;
  	        case weakMapCtorString: return weakMapTag;
  	      }
  	    }
  	    return result;
  	  };
  	}

  	_getTag = getTag;
  	return _getTag;
  }

  var _baseIsEqualDeep;
  var hasRequired_baseIsEqualDeep;

  function require_baseIsEqualDeep () {
  	if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
  	hasRequired_baseIsEqualDeep = 1;
  	var Stack = require_Stack(),
  	    equalArrays = require_equalArrays(),
  	    equalByTag = require_equalByTag(),
  	    equalObjects = require_equalObjects(),
  	    getTag = require_getTag(),
  	    isArray = requireIsArray(),
  	    isBuffer = requireIsBuffer(),
  	    isTypedArray = requireIsTypedArray();

  	/** Used to compose bitmasks for value comparisons. */
  	var COMPARE_PARTIAL_FLAG = 1;

  	/** `Object#toString` result references. */
  	var argsTag = '[object Arguments]',
  	    arrayTag = '[object Array]',
  	    objectTag = '[object Object]';

  	/** Used for built-in method references. */
  	var objectProto = Object.prototype;

  	/** Used to check objects for own properties. */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * A specialized version of `baseIsEqual` for arrays and objects which performs
  	 * deep comparisons and tracks traversed objects enabling objects with circular
  	 * references to be compared.
  	 *
  	 * @private
  	 * @param {Object} object The object to compare.
  	 * @param {Object} other The other object to compare.
  	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	 * @param {Function} customizer The function to customize comparisons.
  	 * @param {Function} equalFunc The function to determine equivalents of values.
  	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
  	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	 */
  	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  	  var objIsArr = isArray(object),
  	      othIsArr = isArray(other),
  	      objTag = objIsArr ? arrayTag : getTag(object),
  	      othTag = othIsArr ? arrayTag : getTag(other);

  	  objTag = objTag == argsTag ? objectTag : objTag;
  	  othTag = othTag == argsTag ? objectTag : othTag;

  	  var objIsObj = objTag == objectTag,
  	      othIsObj = othTag == objectTag,
  	      isSameTag = objTag == othTag;

  	  if (isSameTag && isBuffer(object)) {
  	    if (!isBuffer(other)) {
  	      return false;
  	    }
  	    objIsArr = true;
  	    objIsObj = false;
  	  }
  	  if (isSameTag && !objIsObj) {
  	    stack || (stack = new Stack);
  	    return (objIsArr || isTypedArray(object))
  	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
  	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  	  }
  	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
  	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
  	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

  	    if (objIsWrapped || othIsWrapped) {
  	      var objUnwrapped = objIsWrapped ? object.value() : object,
  	          othUnwrapped = othIsWrapped ? other.value() : other;

  	      stack || (stack = new Stack);
  	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
  	    }
  	  }
  	  if (!isSameTag) {
  	    return false;
  	  }
  	  stack || (stack = new Stack);
  	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  	}

  	_baseIsEqualDeep = baseIsEqualDeep;
  	return _baseIsEqualDeep;
  }

  var _baseIsEqual;
  var hasRequired_baseIsEqual;

  function require_baseIsEqual () {
  	if (hasRequired_baseIsEqual) return _baseIsEqual;
  	hasRequired_baseIsEqual = 1;
  	var baseIsEqualDeep = require_baseIsEqualDeep(),
  	    isObjectLike = requireIsObjectLike();

  	/**
  	 * The base implementation of `_.isEqual` which supports partial comparisons
  	 * and tracks traversed objects.
  	 *
  	 * @private
  	 * @param {*} value The value to compare.
  	 * @param {*} other The other value to compare.
  	 * @param {boolean} bitmask The bitmask flags.
  	 *  1 - Unordered comparison
  	 *  2 - Partial comparison
  	 * @param {Function} [customizer] The function to customize comparisons.
  	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
  	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
  	 */
  	function baseIsEqual(value, other, bitmask, customizer, stack) {
  	  if (value === other) {
  	    return true;
  	  }
  	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
  	    return value !== value && other !== other;
  	  }
  	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  	}

  	_baseIsEqual = baseIsEqual;
  	return _baseIsEqual;
  }

  var isEqual_1;
  var hasRequiredIsEqual;

  function requireIsEqual () {
  	if (hasRequiredIsEqual) return isEqual_1;
  	hasRequiredIsEqual = 1;
  	var baseIsEqual = require_baseIsEqual();

  	/**
  	 * Performs a deep comparison between two values to determine if they are
  	 * equivalent.
  	 *
  	 * **Note:** This method supports comparing arrays, array buffers, booleans,
  	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
  	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
  	 * by their own, not inherited, enumerable properties. Functions and DOM
  	 * nodes are compared by strict equality, i.e. `===`.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 0.1.0
  	 * @category Lang
  	 * @param {*} value The value to compare.
  	 * @param {*} other The other value to compare.
  	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
  	 * @example
  	 *
  	 * var object = { 'a': 1 };
  	 * var other = { 'a': 1 };
  	 *
  	 * _.isEqual(object, other);
  	 * // => true
  	 *
  	 * object === other;
  	 * // => false
  	 */
  	function isEqual(value, other) {
  	  return baseIsEqual(value, other);
  	}

  	isEqual_1 = isEqual;
  	return isEqual_1;
  }

  /**
   * @class
   *
   * @property {Element} key
   * @property {Element} value
   */

  var KeyValuePair_1;
  var hasRequiredKeyValuePair;

  function requireKeyValuePair () {
  	if (hasRequiredKeyValuePair) return KeyValuePair_1;
  	hasRequiredKeyValuePair = 1;
  	class KeyValuePair {
  	  constructor(key, value) {
  	    this.key = key;
  	    this.value = value;
  	  }

  	  /**
  	   * @returns {KeyValuePair}
  	   */
  	  clone() {
  	    const clone = new KeyValuePair();

  	    if (this.key) {
  	      clone.key = this.key.clone();
  	    }

  	    if (this.value) {
  	      clone.value = this.value.clone();
  	    }

  	    return clone;
  	  }
  	}

  	KeyValuePair_1 = KeyValuePair;
  	return KeyValuePair_1;
  }

  /** Error message constants. */

  var negate_1;
  var hasRequiredNegate;

  function requireNegate () {
  	if (hasRequiredNegate) return negate_1;
  	hasRequiredNegate = 1;
  	var FUNC_ERROR_TEXT = 'Expected a function';

  	/**
  	 * Creates a function that negates the result of the predicate `func`. The
  	 * `func` predicate is invoked with the `this` binding and arguments of the
  	 * created function.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @since 3.0.0
  	 * @category Function
  	 * @param {Function} predicate The predicate to negate.
  	 * @returns {Function} Returns the new negated function.
  	 * @example
  	 *
  	 * function isEven(n) {
  	 *   return n % 2 == 0;
  	 * }
  	 *
  	 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
  	 * // => [1, 3, 5]
  	 */
  	function negate(predicate) {
  	  if (typeof predicate != 'function') {
  	    throw new TypeError(FUNC_ERROR_TEXT);
  	  }
  	  return function() {
  	    var args = arguments;
  	    switch (args.length) {
  	      case 0: return !predicate.call(this);
  	      case 1: return !predicate.call(this, args[0]);
  	      case 2: return !predicate.call(this, args[0], args[1]);
  	      case 3: return !predicate.call(this, args[0], args[1], args[2]);
  	    }
  	    return !predicate.apply(this, args);
  	  };
  	}

  	negate_1 = negate;
  	return negate_1;
  }

  var ArraySlice_1;
  var hasRequiredArraySlice;

  function requireArraySlice () {
  	if (hasRequiredArraySlice) return ArraySlice_1;
  	hasRequiredArraySlice = 1;
  	const negate = requireNegate();

  	// Coerces an a parameter into a callback for matching elements.
  	// This accepts an element name, an element type and returns a
  	// callback to match for those elements.
  	function coerceElementMatchingCallback(value) {
  	  // Element Name
  	  if (typeof value === 'string') {
  	    return element => element.element === value;
  	  }

  	  // Element Type
  	  if (value.constructor && value.extend) {
  	    return element => element instanceof value;
  	  }

  	  return value;
  	}

  	/**
  	 * @class
  	 *
  	 * @param {Element[]} elements
  	 *
  	 * @property {Element[]} elements
  	 */
  	class ArraySlice {
  	  constructor(elements) {
  	    this.elements = elements || [];
  	  }

  	  /**
  	   * @returns {Array}
  	   */
  	  toValue() {
  	    return this.elements.map(element => element.toValue());
  	  }

  	  // High Order Functions

  	  /**
  	   * @param callback - Function to execute for each element
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {array} A new array with each element being the result of the callback function
  	   */
  	  map(callback, thisArg) {
  	    return this.elements.map(callback, thisArg);
  	  }

  	  /**
  	   * Maps and then flattens the results.
  	   * @param callback - Function to execute for each element.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {array}
  	   */
  	  flatMap(callback, thisArg) {
  	    return this
  	      .map(callback, thisArg)
  	      .reduce((a, b) => a.concat(b), []);
  	  }

  	  /**
  	   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
  	   * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @memberof ArraySlice.prototype
  	   * @returns An array of the non-undefined results of calling transform with each element of the array
  	   */
  	  compactMap(transform, thisArg) {
  	    const results = [];

  	    this.forEach((element) => {
  	      const result = transform.bind(thisArg)(element);

  	      if (result) {
  	        results.push(result);
  	      }
  	    });

  	    return results;
  	  }

  	  /**
  	   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {ArraySlice}
  	   * @memberof ArraySlice.prototype
  	   */
  	  filter(callback, thisArg) {
  	    callback = coerceElementMatchingCallback(callback);
  	    return new ArraySlice(this.elements.filter(callback, thisArg));
  	  }

  	  /**
  	   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {ArraySlice}
  	   * @memberof ArraySlice.prototype
  	   */
  	  reject(callback, thisArg) {
  	    callback = coerceElementMatchingCallback(callback);
  	    return new ArraySlice(this.elements.filter(negate(callback), thisArg));
  	  }

  	  /**
  	   * Returns the first element in the array that satisfies the given value
  	   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {Element}
  	   * @memberof ArraySlice.prototype
  	   */
  	  find(callback, thisArg) {
  	    callback = coerceElementMatchingCallback(callback);
  	    return this.elements.find(callback, thisArg);
  	  }

  	  /**
  	   * @param callback - Function to execute for each element
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @memberof ArraySlice.prototype
  	   */
  	  forEach(callback, thisArg) {
  	    this.elements.forEach(callback, thisArg);
  	  }

  	  /**
  	   * @param callback - Function to execute for each element
  	   * @param initialValue
  	   * @memberof ArraySlice.prototype
  	   */
  	  reduce(callback, initialValue) {
  	    return this.elements.reduce(callback, initialValue);
  	  }

  	  /**
  	   * @param value
  	   * @returns {boolean}
  	   * @memberof ArraySlice.prototype
  	   */
  	  includes(value) {
  	    return this.elements.some(element => element.equals(value));
  	  }

  	  // Mutation

  	  /**
  	   * Removes the first element from the slice
  	   * @returns {Element} The removed element or undefined if the slice is empty
  	   * @memberof ArraySlice.prototype
  	   */
  	  shift() {
  	    return this.elements.shift();
  	  }

  	  /**
  	   * Adds the given element to the begining of the slice
  	   * @parameter {Element} value
  	   * @memberof ArraySlice.prototype
  	   */
  	  unshift(value) {
  	    this.elements.unshift(this.refract(value));
  	  }

  	  /**
  	   * Adds the given element to the end of the slice
  	   * @parameter {Element} value
  	   * @memberof ArraySlice.prototype
  	   */
  	  push(value) {
  	    this.elements.push(this.refract(value));
  	    return this;
  	  }

  	  /**
  	   * @parameter {Element} value
  	   * @memberof ArraySlice.prototype
  	   */
  	  add(value) {
  	    this.push(value);
  	  }

  	  // Accessors

  	  /**
  	   * @parameter {number} index
  	   * @returns {Element}
  	   * @memberof ArraySlice.prototype
  	   */
  	  get(index) {
  	    return this.elements[index];
  	  }

  	  /**
  	   * @parameter {number} index
  	   * @memberof ArraySlice.prototype
  	   */
  	  getValue(index) {
  	    const element = this.elements[index];

  	    if (element) {
  	      return element.toValue();
  	    }

  	    return undefined;
  	  }

  	  /**
  	   * Returns the number of elements in the slice
  	   * @type number
  	   */
  	  get length() {
  	    return this.elements.length;
  	  }

  	  /**
  	   * Returns whether the slice is empty
  	   * @type boolean
  	   */
  	  get isEmpty() {
  	    return this.elements.length === 0;
  	  }

  	  /**
  	   * Returns the first element in the slice or undefined if the slice is empty
  	   * @type Element
  	   */
  	  get first() {
  	    return this.elements[0];
  	  }
  	}

  	if (typeof Symbol !== 'undefined') {
  	  ArraySlice.prototype[Symbol.iterator] = function symbol() {
  	    return this.elements[Symbol.iterator]();
  	  };
  	}

  	ArraySlice_1 = ArraySlice;
  	return ArraySlice_1;
  }

  var Element_1;
  var hasRequiredElement;

  function requireElement () {
  	if (hasRequiredElement) return Element_1;
  	hasRequiredElement = 1;
  	const isEqual = requireIsEqual();
  	const KeyValuePair = requireKeyValuePair();
  	const ArraySlice = requireArraySlice();

  	/**
  	 * @class
  	 *
  	 * @param content
  	 * @param meta
  	 * @param attributes
  	 *
  	 * @property {string} element
  	 */
  	class Element {
  	  constructor(content, meta, attributes) {
  	    // Lazy load this.meta and this.attributes because it's a Minim element
  	    // Otherwise, we get into circuluar calls
  	    if (meta) {
  	      this.meta = meta;
  	    }

  	    if (attributes) {
  	      this.attributes = attributes;
  	    }

  	    this.content = content;
  	  }

  	  /**
  	   * Freezes the element to prevent any mutation.
  	   * A frozen element will add `parent` property to every child element
  	   * to allow traversing up the element tree.
  	   */
  	  freeze() {
  	    if (Object.isFrozen(this)) {
  	      return;
  	    }

  	    if (this._meta) {
  	      this.meta.parent = this;
  	      this.meta.freeze();
  	    }

  	    if (this._attributes) {
  	      this.attributes.parent = this;
  	      this.attributes.freeze();
  	    }

  	    this.children.forEach((element) => {
  	      element.parent = this;
  	      element.freeze();
  	    }, this);

  	    if (this.content && Array.isArray(this.content)) {
  	      Object.freeze(this.content);
  	    }

  	    Object.freeze(this);
  	  }

  	  primitive() {

  	  }

  	  /**
  	   * Creates a deep clone of the instance
  	   */
  	  clone() {
  	    const copy = new this.constructor();

  	    copy.element = this.element;

  	    if (this.meta.length) {
  	      copy._meta = this.meta.clone();
  	    }

  	    if (this.attributes.length) {
  	      copy._attributes = this.attributes.clone();
  	    }

  	    if (this.content) {
  	      if (this.content.clone) {
  	        copy.content = this.content.clone();
  	      } else if (Array.isArray(this.content)) {
  	        copy.content = this.content.map(element => element.clone());
  	      } else {
  	        copy.content = this.content;
  	      }
  	    } else {
  	      copy.content = this.content;
  	    }

  	    return copy;
  	  }

  	  /**
  	   */
  	  toValue() {
  	    if (this.content instanceof Element) {
  	      return this.content.toValue();
  	    }

  	    if (this.content instanceof KeyValuePair) {
  	      return {
  	        key: this.content.key.toValue(),
  	        value: this.content.value ? this.content.value.toValue() : undefined,
  	      };
  	    }

  	    if (this.content && this.content.map) {
  	      return this.content.map(element => element.toValue(), this);
  	    }

  	    return this.content;
  	  }

  	  /**
  	   * Creates a reference pointing at the Element
  	   * @returns {RefElement}
  	   * @memberof Element.prototype
  	   */
  	  toRef(path) {
  	    if (this.id.toValue() === '') {
  	      throw Error('Cannot create reference to an element that does not contain an ID');
  	    }

  	    const ref = new this.RefElement(this.id.toValue());

  	    if (path) {
  	      ref.path = path;
  	    }

  	    return ref;
  	  }

  	  /**
  	   * Finds the given elements in the element tree.
  	   * When providing multiple element names, you must first freeze the element.
  	   *
  	   * @param names {...elementNames}
  	   * @returns {ArraySlice}
  	   */
  	  findRecursive(...elementNames) {
  	    if (arguments.length > 1 && !this.isFrozen) {
  	      throw new Error('Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`');
  	    }

  	    const elementName = elementNames.pop();
  	    let elements = new ArraySlice();

  	    const append = (array, element) => {
  	      array.push(element);
  	      return array;
  	    };

  	    // Checks the given element and appends element/sub-elements
  	    // that match element name to given array
  	    const checkElement = (array, element) => {
  	      if (element.element === elementName) {
  	        array.push(element);
  	      }

  	      const items = element.findRecursive(elementName);
  	      if (items) {
  	        items.reduce(append, array);
  	      }

  	      if (element.content instanceof KeyValuePair) {
  	        if (element.content.key) {
  	          checkElement(array, element.content.key);
  	        }

  	        if (element.content.value) {
  	          checkElement(array, element.content.value);
  	        }
  	      }

  	      return array;
  	    };

  	    if (this.content) {
  	      // Direct Element
  	      if (this.content.element) {
  	        checkElement(elements, this.content);
  	      }

  	      // Element Array
  	      if (Array.isArray(this.content)) {
  	        this.content.reduce(checkElement, elements);
  	      }
  	    }

  	    if (!elementNames.isEmpty) {
  	      elements = elements.filter((element) => {
  	        let parentElements = element.parents.map(e => e.element);

  	        // eslint-disable-next-line no-restricted-syntax
  	        for (const namesIndex in elementNames) {
  	          const name = elementNames[namesIndex];
  	          const index = parentElements.indexOf(name);

  	          if (index !== -1) {
  	            parentElements = parentElements.splice(0, index);
  	          } else {
  	            return false;
  	          }
  	        }

  	        return true;
  	      });
  	    }

  	    return elements;
  	  }

  	  set(content) {
  	    this.content = content;
  	    return this;
  	  }

  	  equals(value) {
  	    return isEqual(this.toValue(), value);
  	  }

  	  getMetaProperty(name, value) {
  	    if (!this.meta.hasKey(name)) {
  	      if (this.isFrozen) {
  	        const element = this.refract(value);
  	        element.freeze();
  	        return element;
  	      }

  	      this.meta.set(name, value);
  	    }

  	    return this.meta.get(name);
  	  }

  	  setMetaProperty(name, value) {
  	    this.meta.set(name, value);
  	  }

  	  /**
  	   * @type String
  	   */
  	  get element() {
  	    // Returns 'element' so we don't have undefined as element
  	    return this._storedElement || 'element';
  	  }

  	  set element(element) {
  	    this._storedElement = element;
  	  }

  	  get content() {
  	    return this._content;
  	  }

  	  set content(value) {
  	    if (value instanceof Element) {
  	      this._content = value;
  	    } else if (value instanceof ArraySlice) {
  	      this.content = value.elements;
  	    } else if (
  	      typeof value == 'string'
  	      || typeof value == 'number'
  	      || typeof value == 'boolean'
  	      || value === 'null'
  	      || value == undefined
  	    ) {
  	      // Primitive Values
  	      this._content = value;
  	    } else if (value instanceof KeyValuePair) {
  	      this._content = value;
  	    } else if (Array.isArray(value)) {
  	      this._content = value.map(this.refract);
  	    } else if (typeof value === 'object') {
  	      this._content = Object.keys(value).map(key => new this.MemberElement(key, value[key]));
  	    } else {
  	      throw new Error('Cannot set content to given value');
  	    }
  	  }

  	  /**
  	   * @type ObjectElement
  	   */
  	  get meta() {
  	    if (!this._meta) {
  	      if (this.isFrozen) {
  	        const meta = new this.ObjectElement();
  	        meta.freeze();
  	        return meta;
  	      }

  	      this._meta = new this.ObjectElement();
  	    }

  	    return this._meta;
  	  }

  	  set meta(value) {
  	    if (value instanceof this.ObjectElement) {
  	      this._meta = value;
  	    } else {
  	      this.meta.set(value || {});
  	    }
  	  }

  	  /**
  	   * The attributes property defines attributes about the given instance
  	   * of the element, as specified by the element property.
  	   *
  	   * @type ObjectElement
  	   */
  	  get attributes() {
  	    if (!this._attributes) {
  	      if (this.isFrozen) {
  	        const meta = new this.ObjectElement();
  	        meta.freeze();
  	        return meta;
  	      }

  	      this._attributes = new this.ObjectElement();
  	    }

  	    return this._attributes;
  	  }

  	  set attributes(value) {
  	    if (value instanceof this.ObjectElement) {
  	      this._attributes = value;
  	    } else {
  	      this.attributes.set(value || {});
  	    }
  	  }

  	  /**
  	   * Unique Identifier, MUST be unique throughout an entire element tree.
  	   * @type StringElement
  	   */
  	  get id() {
  	    return this.getMetaProperty('id', '');
  	  }

  	  set id(element) {
  	    this.setMetaProperty('id', element);
  	  }

  	  /**
  	   * @type ArrayElement
  	   */
  	  get classes() {
  	    return this.getMetaProperty('classes', []);
  	  }

  	  set classes(element) {
  	    this.setMetaProperty('classes', element);
  	  }

  	  /**
  	   * Human-readable title of element
  	   * @type StringElement
  	   */
  	  get title() {
  	    return this.getMetaProperty('title', '');
  	  }

  	  set title(element) {
  	    this.setMetaProperty('title', element);
  	  }

  	  /**
  	   * Human-readable description of element
  	   * @type StringElement
  	   */
  	  get description() {
  	    return this.getMetaProperty('description', '');
  	  }

  	  set description(element) {
  	    this.setMetaProperty('description', element);
  	  }

  	  /**
  	   * @type ArrayElement
  	   */
  	  get links() {
  	    return this.getMetaProperty('links', []);
  	  }

  	  set links(element) {
  	    this.setMetaProperty('links', element);
  	  }

  	  /**
  	   * Returns whether the element is frozen.
  	   * @type boolean
  	   * @see freeze
  	   */
  	  get isFrozen() {
  	    return Object.isFrozen(this);
  	  }

  	  /**
  	   * Returns all of the parent elements.
  	   * @type ArraySlice
  	   */
  	  get parents() {
  	    let { parent } = this;
  	    const parents = new ArraySlice();

  	    while (parent) {
  	      parents.push(parent);

  	      // eslint-disable-next-line prefer-destructuring
  	      parent = parent.parent;
  	    }

  	    return parents;
  	  }

  	  /**
  	   * Returns all of the children elements found within the element.
  	   * @type ArraySlice
  	   * @see recursiveChildren
  	   */
  	  get children() {
  	    if (Array.isArray(this.content)) {
  	      return new ArraySlice(this.content);
  	    }

  	    if (this.content instanceof KeyValuePair) {
  	      const children = new ArraySlice([this.content.key]);

  	      if (this.content.value) {
  	        children.push(this.content.value);
  	      }

  	      return children;
  	    }

  	    if (this.content instanceof Element) {
  	      return new ArraySlice([this.content]);
  	    }

  	    return new ArraySlice();
  	  }

  	  /**
  	  * Returns all of the children elements found within the element recursively.
  	  * @type ArraySlice
  	  * @see children
  	  */
  	  get recursiveChildren() {
  	    const children = new ArraySlice();

  	    this.children.forEach((element) => {
  	      children.push(element);

  	      element.recursiveChildren.forEach((child) => {
  	        children.push(child);
  	      });
  	    });

  	    return children;
  	  }
  	}

  	Element_1 = Element;
  	return Element_1;
  }

  var NullElement_1;
  var hasRequiredNullElement;

  function requireNullElement () {
  	if (hasRequiredNullElement) return NullElement_1;
  	hasRequiredNullElement = 1;
  	const Element = requireElement();

  	/**
  	 */
  	class NullElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content || null, meta, attributes);
  	    this.element = 'null';
  	  }

  	  primitive() {
  	    return 'null';
  	  }

  	  set() {
  	    return new Error('Cannot set the value of null');
  	  }
  	}

  	NullElement_1 = NullElement;
  	return NullElement_1;
  }

  var StringElement_1;
  var hasRequiredStringElement;

  function requireStringElement () {
  	if (hasRequiredStringElement) return StringElement_1;
  	hasRequiredStringElement = 1;
  	const Element = requireElement();

  	/**
  	 * @class StringElement
  	 *
  	 * @param {string} content
  	 * @param meta
  	 * @param attributes
  	 */
  	StringElement_1 = class StringElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content, meta, attributes);
  	    this.element = 'string';
  	  }

  	  primitive() {
  	    return 'string';
  	  }

  	  /**
  	   * The length of the string.
  	   * @type number
  	   */
  	  get length() {
  	    return this.content.length;
  	  }
  	};
  	return StringElement_1;
  }

  var NumberElement_1;
  var hasRequiredNumberElement;

  function requireNumberElement () {
  	if (hasRequiredNumberElement) return NumberElement_1;
  	hasRequiredNumberElement = 1;
  	const Element = requireElement();

  	/**
  	 * @class NumberElement
  	 *
  	 * @param {number} content
  	 * @param meta
  	 * @param attributes
  	 */
  	NumberElement_1 = class NumberElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content, meta, attributes);
  	    this.element = 'number';
  	  }

  	  primitive() {
  	    return 'number';
  	  }
  	};
  	return NumberElement_1;
  }

  var BooleanElement_1;
  var hasRequiredBooleanElement;

  function requireBooleanElement () {
  	if (hasRequiredBooleanElement) return BooleanElement_1;
  	hasRequiredBooleanElement = 1;
  	const Element = requireElement();

  	/**
  	 * @class BooleanElement
  	 *
  	 * @param {boolean} content
  	 * @param meta
  	 * @param attributes
  	 */
  	BooleanElement_1 = class BooleanElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content, meta, attributes);
  	    this.element = 'boolean';
  	  }

  	  primitive() {
  	    return 'boolean';
  	  }
  	};
  	return BooleanElement_1;
  }

  var ArrayElement_1;
  var hasRequiredArrayElement;

  function requireArrayElement () {
  	if (hasRequiredArrayElement) return ArrayElement_1;
  	hasRequiredArrayElement = 1;
  	const negate = requireNegate();
  	const Element = requireElement();
  	const ArraySlice = requireArraySlice();

  	/**
  	 * @class
  	 *
  	 * @param {Element[]} content
  	 * @param meta
  	 * @param attributes
  	 */
  	class ArrayElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content || [], meta, attributes);
  	    this.element = 'array';
  	  }

  	  primitive() {
  	    return 'array';
  	  }

  	  /**
  	   * @returns {Element}
  	   */
  	  get(index) {
  	    return this.content[index];
  	  }

  	  /**
  	   * Helper for returning the value of an item
  	   * This works for both ArrayElement and ObjectElement instances
  	   */
  	  getValue(indexOrKey) {
  	    const item = this.get(indexOrKey);

  	    if (item) {
  	      return item.toValue();
  	    }

  	    return undefined;
  	  }

  	  /**
  	   * @returns {Element}
  	   */
  	  getIndex(index) {
  	    return this.content[index];
  	  }

  	  set(index, value) {
  	    this.content[index] = this.refract(value);
  	    return this;
  	  }

  	  remove(index) {
  	    const removed = this.content.splice(index, 1);

  	    if (removed.length) {
  	      return removed[0];
  	    }

  	    return null;
  	  }

  	  /**
  	   * @param callback - Function to execute for each element
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   */
  	  map(callback, thisArg) {
  	    return this.content.map(callback, thisArg);
  	  }

  	  /**
  	   * Maps and then flattens the results.
  	   * @param callback - Function to execute for each element.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {array}
  	   */
  	  flatMap(callback, thisArg) {
  	    return this
  	      .map(callback, thisArg)
  	      .reduce((a, b) => a.concat(b), []);
  	  }

  	  /**
  	   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
  	   * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @memberof ArrayElement.prototype
  	   * @returns An array of the non-undefined results of calling transform with each element of the array
  	   */
  	  compactMap(transform, thisArg) {
  	    const results = [];

  	    this.forEach((element) => {
  	      const result = transform.bind(thisArg)(element);

  	      if (result) {
  	        results.push(result);
  	      }
  	    });

  	    return results;
  	  }

  	  /**
  	   * @param callback - Function to execute for each element
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {ArraySlice}
  	   */
  	  filter(callback, thisArg) {
  	    return new ArraySlice(this.content.filter(callback, thisArg));
  	  }

  	  /**
  	   * @param callback - Function to execute for each element
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns {ArraySlice}
  	   */
  	  reject(callback, thisArg) {
  	    return this.filter(negate(callback), thisArg);
  	  }

  	  /**
  	   * This is a reduce function specifically for Minim arrays and objects. It
  	   * allows for returning normal values or Minim instances, so it converts any
  	   * primitives on each step.
  	   */
  	  reduce(callback, initialValue) {
  	    let startIndex;
  	    let memo;

  	    // Allows for defining a starting value of the reduce
  	    if (initialValue !== undefined) {
  	      startIndex = 0;
  	      memo = this.refract(initialValue);
  	    } else {
  	      startIndex = 1;
  	      // Object Element content items are member elements. Because of this,
  	      // the memo should start out as the member value rather than the
  	      // actual member itself.
  	      memo = this.primitive() === 'object' ? this.first.value : this.first;
  	    }

  	    // Sending each function call to the registry allows for passing Minim
  	    // instances through the function return. This means you can return
  	    // primitive values or return Minim instances and reduce will still work.
  	    for (let i = startIndex; i < this.length; i += 1) {
  	      const item = this.content[i];

  	      if (this.primitive() === 'object') {
  	        memo = this.refract(callback(memo, item.value, item.key, item, this));
  	      } else {
  	        memo = this.refract(callback(memo, item, i, this));
  	      }
  	    }

  	    return memo;
  	  }

  	  /**
  	   * @callback forEachCallback
  	   * @param {Element} currentValue
  	   * @param {NumberElement} index
  	   */

  	  /**
  	   * @param {forEachCallback} callback - Function to execute for each element
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @memberof ArrayElement.prototype
  	   */
  	  forEach(callback, thisArg) {
  	    this.content.forEach((item, index) => {
  	      callback.bind(thisArg)(item, this.refract(index));
  	    });
  	  }

  	  /**
  	   * @returns {Element}
  	   */
  	  shift() {
  	    return this.content.shift();
  	  }

  	  /**
  	   * @param value
  	   */
  	  unshift(value) {
  	    this.content.unshift(this.refract(value));
  	  }

  	  /**
  	   * @param value
  	   */
  	  push(value) {
  	    this.content.push(this.refract(value));
  	    return this;
  	  }

  	  /**
  	   * @param value
  	   */
  	  add(value) {
  	    this.push(value);
  	  }

  	  /**
  	   * Recusively search all descendents using a condition function.
  	   * @returns {Element[]}
  	   */
  	  findElements(condition, givenOptions) {
  	    const options = givenOptions || {};
  	    const recursive = !!options.recursive;
  	    const results = options.results === undefined ? [] : options.results;

  	    // The forEach method for Object Elements returns value, key, and member.
  	    // This passes those along to the condition function below.
  	    this.forEach((item, keyOrIndex, member) => {
  	      // We use duck-typing here to support any registered class that
  	      // may contain other elements.
  	      if (recursive && (item.findElements !== undefined)) {
  	        item.findElements(condition, {
  	          results,
  	          recursive,
  	        });
  	      }

  	      if (condition(item, keyOrIndex, member)) {
  	        results.push(item);
  	      }
  	    });

  	    return results;
  	  }

  	  /**
  	   * Recusively search all descendents using a condition function.
  	   * @param condition
  	   * @returns {ArraySlice}
  	   */
  	  find(condition) {
  	    return new ArraySlice(this.findElements(condition, { recursive: true }));
  	  }

  	  /**
  	   * @param {string} element
  	   * @returns {ArraySlice}
  	   */
  	  findByElement(element) {
  	    return this.find(item => item.element === element);
  	  }

  	  /**
  	   * @param {string} className
  	   * @returns {ArraySlice}
  	   * @memberof ArrayElement.prototype
  	   */
  	  findByClass(className) {
  	    return this.find(item => item.classes.includes(className));
  	  }

  	  /**
  	   * Search the tree recursively and find the element with the matching ID
  	   * @param {string} id
  	   * @returns {Element}
  	   * @memberof ArrayElement.prototype
  	   */
  	  getById(id) {
  	    return this.find(item => item.id.toValue() === id).first;
  	  }

  	  /**
  	   * Looks for matching children using deep equality
  	   * @param value
  	   * @returns {boolean}
  	   */
  	  includes(value) {
  	    return this.content.some(element => element.equals(value));
  	  }

  	  /**
  	   * Looks for matching children using deep equality
  	   * @param value
  	   * @returns {boolean}
  	   * @see includes
  	   * @deprecated method was replaced by includes
  	   */
  	  contains(value) {
  	    return this.includes(value);
  	  }

  	  // Fantasy Land

  	  /**
  	   * @returns {ArrayElement} An empty array element
  	   */
  	  empty() {
  	    return new this.constructor([]);
  	  }

  	  ['fantasy-land/empty']() {
  	    return this.empty();
  	  }

  	  /**
  	   * @param {ArrayElement} other
  	   * @returns {ArrayElement}
  	   */
  	  concat(other) {
  	    return new this.constructor(this.content.concat(other.content));
  	  }

  	  ['fantasy-land/concat'](other) {
  	    return this.concat(other);
  	  }

  	  ['fantasy-land/map'](transform) {
  	    return new this.constructor(this.map(transform));
  	  }

  	  ['fantasy-land/chain'](transform) {
  	    return this
  	      .map(element => transform(element), this)
  	      .reduce((a, b) => a.concat(b), this.empty());
  	  }

  	  ['fantasy-land/filter'](callback) {
  	    return new this.constructor(this.content.filter(callback));
  	  }

  	  ['fantasy-land/reduce'](transform, initialValue) {
  	    return this.content.reduce(transform, initialValue);
  	  }

  	  /**
  	   * Returns the length of the collection
  	   * @type number
  	   */
  	  get length() {
  	    return this.content.length;
  	  }

  	  /**
  	   * Returns whether the collection is empty
  	   * @type boolean
  	   */
  	  get isEmpty() {
  	    return this.content.length === 0;
  	  }

  	  /**
  	   * Return the first item in the collection
  	   * @type Element
  	   */
  	  get first() {
  	    return this.getIndex(0);
  	  }

  	  /**
  	   * Return the second item in the collection
  	   * @type Element
  	   */
  	  get second() {
  	    return this.getIndex(1);
  	  }

  	  /**
  	   * Return the last item in the collection
  	   * @type Element
  	   */
  	  get last() {
  	    return this.getIndex(this.length - 1);
  	  }
  	}

  	/**
  	 * @returns {ArrayElement} An empty array element
  	 */
  	ArrayElement.empty = function empty() {
  	  return new this();
  	};

  	ArrayElement['fantasy-land/empty'] = ArrayElement.empty;

  	if (typeof Symbol !== 'undefined') {
  	  ArrayElement.prototype[Symbol.iterator] = function symbol() {
  	    return this.content[Symbol.iterator]();
  	  };
  	}

  	ArrayElement_1 = ArrayElement;
  	return ArrayElement_1;
  }

  var MemberElement_1;
  var hasRequiredMemberElement;

  function requireMemberElement () {
  	if (hasRequiredMemberElement) return MemberElement_1;
  	hasRequiredMemberElement = 1;
  	const KeyValuePair = requireKeyValuePair();
  	const Element = requireElement();

  	/**
  	 * @class MemberElement
  	 *
  	 * @param {Element} key
  	 * @param {Element} value
  	 * @param meta
  	 * @param attributes
  	 */
  	MemberElement_1 = class MemberElement extends Element {
  	  constructor(key, value, meta, attributes) {
  	    super(new KeyValuePair(), meta, attributes);

  	    this.element = 'member';
  	    this.key = key;
  	    this.value = value;
  	  }

  	  /**
  	   * @type Element
  	   */
  	  get key() {
  	    return this.content.key;
  	  }

  	  set key(key) {
  	    this.content.key = this.refract(key);
  	  }

  	  /**
  	   * @type Element
  	   */
  	  get value() {
  	    return this.content.value;
  	  }

  	  set value(value) {
  	    this.content.value = this.refract(value);
  	  }
  	};
  	return MemberElement_1;
  }

  var ObjectSlice_1;
  var hasRequiredObjectSlice;

  function requireObjectSlice () {
  	if (hasRequiredObjectSlice) return ObjectSlice_1;
  	hasRequiredObjectSlice = 1;
  	const negate = requireNegate();
  	const ArraySlice = requireArraySlice();

  	/**
  	 */
  	class ObjectSlice extends ArraySlice {
  	  map(callback, thisArg) {
  	    return this.elements.map(member => callback.bind(thisArg)(member.value, member.key, member));
  	  }

  	  filter(callback, thisArg) {
  	    return new ObjectSlice(this.elements.filter(member => callback.bind(thisArg)(member.value, member.key, member)));
  	  }

  	  reject(callback, thisArg) {
  	    return this.filter(negate(callback.bind(thisArg)));
  	  }

  	  forEach(callback, thisArg) {
  	    return this.elements.forEach((member, index) => { callback.bind(thisArg)(member.value, member.key, member, index); });
  	  }

  	  /**
  	   * @returns {array}
  	   */
  	  keys() {
  	    return this.map((value, key) => key.toValue());
  	  }

  	  /**
  	   * @returns {array}
  	   */
  	  values() {
  	    return this.map(value => value.toValue());
  	  }
  	}

  	ObjectSlice_1 = ObjectSlice;
  	return ObjectSlice_1;
  }

  var ObjectElement_1;
  var hasRequiredObjectElement;

  function requireObjectElement () {
  	if (hasRequiredObjectElement) return ObjectElement_1;
  	hasRequiredObjectElement = 1;
  	const negate = requireNegate();
  	const isObject = requireIsObject$1();

  	const ArrayElement = requireArrayElement();
  	const MemberElement = requireMemberElement();
  	const ObjectSlice = requireObjectSlice();

  	/**
  	 * @class
  	 *
  	 * @param content
  	 * @param meta
  	 * @param attributes
  	 */
  	class ObjectElement extends ArrayElement {
  	  constructor(content, meta, attributes) {
  	    super(content || [], meta, attributes);
  	    this.element = 'object';
  	  }

  	  primitive() {
  	    return 'object';
  	  }

  	  toValue() {
  	    return this.content.reduce((results, el) => {
  	      results[el.key.toValue()] = el.value ? el.value.toValue() : undefined;
  	      return results;
  	    }, {});
  	  }

  	  /**
  	   * @param key
  	   * @returns {Element}
  	   */
  	  get(name) {
  	    const member = this.getMember(name);

  	    if (member) {
  	      return member.value;
  	    }

  	    return undefined;
  	  }

  	  /**
  	   * @param key
  	   * @returns {MemberElement}
  	   */
  	  getMember(name) {
  	    if (name === undefined) { return undefined; }

  	    return this.content.find(element => element.key.toValue() === name);
  	  }

  	  /**
  	   * @param key
  	   */
  	  remove(name) {
  	    let removed = null;

  	    this.content = this.content.filter((item) => {
  	      if (item.key.toValue() === name) {
  	        removed = item;
  	        return false;
  	      }

  	      return true;
  	    });

  	    return removed;
  	  }

  	  /**
  	   * @param key
  	   * @returns {Element}
  	   */
  	  getKey(name) {
  	    const member = this.getMember(name);

  	    if (member) {
  	      return member.key;
  	    }

  	    return undefined;
  	  }

  	  /**
  	   * Set allows either a key/value pair to be given or an object
  	   * If an object is given, each key is set to its respective value
  	   */
  	  set(keyOrObject, value) {
  	    if (isObject(keyOrObject)) {
  	      Object.keys(keyOrObject).forEach((objectKey) => {
  	        this.set(objectKey, keyOrObject[objectKey]);
  	      });

  	      return this;
  	    }

  	    // Store as key for clarity
  	    const key = keyOrObject;
  	    const member = this.getMember(key);

  	    if (member) {
  	      member.value = value;
  	    } else {
  	      this.content.push(new MemberElement(key, value));
  	    }

  	    return this;
  	  }

  	  /**
  	   */
  	  keys() {
  	    return this.content.map(item => item.key.toValue());
  	  }

  	  /**
  	   */
  	  values() {
  	    return this.content.map(item => item.value.toValue());
  	  }

  	  /**
  	   * @returns {boolean}
  	   */
  	  hasKey(value) {
  	    return this.content.some(member => member.key.equals(value));
  	  }

  	  /**
  	   * @returns {array}
  	   */
  	  items() {
  	    return this.content.map(item => [item.key.toValue(), item.value.toValue()]);
  	  }

  	  /**
  	   * @param callback
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   */
  	  map(callback, thisArg) {
  	    return this.content.map(item => callback.bind(thisArg)(item.value, item.key, item));
  	  }

  	  /**
  	   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
  	   * @param transform - A closure that accepts the value, key and member element of this object as its argument and returns an optional value.
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   * @returns An array of the non-undefined results of calling transform with each element of the array
  	   */
  	  compactMap(callback, thisArg) {
  	    const results = [];

  	    this.forEach((value, key, member) => {
  	      const result = callback.bind(thisArg)(value, key, member);

  	      if (result) {
  	        results.push(result);
  	      }
  	    });

  	    return results;
  	  }

  	  /**
  	   * @param callback
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   *
  	   * @returns {ObjectSlice}
  	   */
  	  filter(callback, thisArg) {
  	    return new ObjectSlice(this.content).filter(callback, thisArg);
  	  }

  	  /**
  	   * @param callback
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   *
  	   * @returns {ObjectSlice}
  	   *
  	   * @memberof ObjectElement.prototype
  	   */
  	  reject(callback, thisArg) {
  	    return this.filter(negate(callback), thisArg);
  	  }

  	  /**
  	   * @param callback
  	   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
  	   *
  	   * @memberof ObjectElement.prototype
  	   */
  	  forEach(callback, thisArg) {
  	    return this.content.forEach(item => callback.bind(thisArg)(item.value, item.key, item));
  	  }
  	}

  	ObjectElement_1 = ObjectElement;
  	return ObjectElement_1;
  }

  var LinkElement_1;
  var hasRequiredLinkElement;

  function requireLinkElement () {
  	if (hasRequiredLinkElement) return LinkElement_1;
  	hasRequiredLinkElement = 1;
  	const Element = requireElement();

  	/** Hyperlinking MAY be used to link to other resources, provide links to
  	 * instructions on how to process a given element (by way of a profile or
  	 * other means), and may be used to provide meta data about the element in
  	 * which it's found. The meaning and purpose of the hyperlink is defined by
  	 * the link relation according to RFC 5988.
  	 *
  	 * @class LinkElement
  	 *
  	 * @param content
  	 * @param meta
  	 * @param attributes
  	 */
  	LinkElement_1 = class LinkElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content || [], meta, attributes);
  	    this.element = 'link';
  	  }

  	  /**
  	   * The relation identifier for the link, as defined in RFC 5988.
  	   * @type StringElement
  	   */
  	  get relation() {
  	    return this.attributes.get('relation');
  	  }

  	  set relation(relation) {
  	    this.attributes.set('relation', relation);
  	  }

  	  /**
  	   * The URI for the given link.
  	   * @type StringElement
  	   */
  	  get href() {
  	    return this.attributes.get('href');
  	  }

  	  set href(href) {
  	    this.attributes.set('href', href);
  	  }
  	};
  	return LinkElement_1;
  }

  var RefElement_1;
  var hasRequiredRefElement;

  function requireRefElement () {
  	if (hasRequiredRefElement) return RefElement_1;
  	hasRequiredRefElement = 1;
  	const Element = requireElement();

  	/**
  	 * @class RefElement
  	 *
  	 * @param content
  	 * @param meta
  	 * @param attributes
  	 *
  	 * @extends Element
  	 */
  	RefElement_1 = class RefElement extends Element {
  	  constructor(content, meta, attributes) {
  	    super(content || [], meta, attributes);
  	    this.element = 'ref';

  	    if (!this.path) {
  	      this.path = 'element';
  	    }
  	  }

  	  /**
  	   * Path of referenced element to transclude instead of element itself.
  	   * @type StringElement
  	   * @default element
  	   */
  	  get path() {
  	    return this.attributes.get('path');
  	  }

  	  set path(newValue) {
  	    this.attributes.set('path', newValue);
  	  }
  	};
  	return RefElement_1;
  }

  var elements;
  var hasRequiredElements;

  function requireElements () {
  	if (hasRequiredElements) return elements;
  	hasRequiredElements = 1;
  	const Element = requireElement();
  	const NullElement = requireNullElement();
  	const StringElement = requireStringElement();
  	const NumberElement = requireNumberElement();
  	const BooleanElement = requireBooleanElement();
  	const ArrayElement = requireArrayElement();
  	const MemberElement = requireMemberElement();
  	const ObjectElement = requireObjectElement();
  	const LinkElement = requireLinkElement();
  	const RefElement = requireRefElement();

  	const ArraySlice = requireArraySlice();
  	const ObjectSlice = requireObjectSlice();

  	const KeyValuePair = requireKeyValuePair();

  	/**
  	 * Refracts a JSON type to minim elements
  	 * @param value
  	 * @returns {Element}
  	 */
  	function refract(value) {
  	  if (value instanceof Element) {
  	    return value;
  	  }

  	  if (typeof value === 'string') {
  	    return new StringElement(value);
  	  }

  	  if (typeof value === 'number') {
  	    return new NumberElement(value);
  	  }

  	  if (typeof value === 'boolean') {
  	    return new BooleanElement(value);
  	  }

  	  if (value === null) {
  	    return new NullElement();
  	  }

  	  if (Array.isArray(value)) {
  	    return new ArrayElement(value.map(refract));
  	  }

  	  if (typeof value === 'object') {
  	    const element = new ObjectElement(value);
  	    return element;
  	  }

  	  return value;
  	}

  	Element.prototype.ObjectElement = ObjectElement;
  	Element.prototype.RefElement = RefElement;
  	Element.prototype.MemberElement = MemberElement;

  	Element.prototype.refract = refract;
  	ArraySlice.prototype.refract = refract;

  	/**
  	 * Contains all of the element classes, and related structures and methods
  	 * for handling with element instances.
  	 */
  	elements = {
  	  Element,
  	  NullElement,
  	  StringElement,
  	  NumberElement,
  	  BooleanElement,
  	  ArrayElement,
  	  MemberElement,
  	  ObjectElement,
  	  LinkElement,
  	  RefElement,

  	  refract,

  	  ArraySlice,
  	  ObjectSlice,
  	  KeyValuePair,
  	};
  	return elements;
  }

  var Namespace_1;
  var hasRequiredNamespace;

  function requireNamespace () {
  	if (hasRequiredNamespace) return Namespace_1;
  	hasRequiredNamespace = 1;
  	const isNull = requireIsNull();
  	const isString = requireIsString();
  	const isNumber = requireIsNumber();
  	const isBoolean = requireIsBoolean();
  	const isObject = requireIsObject$1();

  	const JSONSerialiser = requireJSONSerialiser();
  	const elements = requireElements();

  	/**
  	 * @class
  	 *
  	 * A refract element implementation with an extensible namespace, able to
  	 * load other namespaces into it.
  	 *
  	 * The namespace allows you to register your own classes to be instantiated
  	 * when a particular refract element is encountered, and allows you to specify
  	 * which elements get instantiated for existing Javascript objects.
  	 */
  	class Namespace {
  	  constructor(options) {
  	    this.elementMap = {};
  	    this.elementDetection = [];
  	    this.Element = elements.Element;
  	    this.KeyValuePair = elements.KeyValuePair;

  	    if (!options || !options.noDefault) {
  	      this.useDefault();
  	    }

  	    // These provide the defaults for new elements.
  	    this._attributeElementKeys = [];
  	    this._attributeElementArrayKeys = [];
  	  }

  	  /**
  	   * Use a namespace plugin or load a generic plugin.
  	   *
  	   * @param plugin
  	   */
  	  use(plugin) {
  	    if (plugin.namespace) {
  	      plugin.namespace({ base: this });
  	    }
  	    if (plugin.load) {
  	      plugin.load({ base: this });
  	    }
  	    return this;
  	  }

  	  /*
  	   * Use the default namespace. This preloads all the default elements
  	   * into this registry instance.
  	   */
  	  useDefault() {
  	    // Set up classes for default elements
  	    this
  	      .register('null', elements.NullElement)
  	      .register('string', elements.StringElement)
  	      .register('number', elements.NumberElement)
  	      .register('boolean', elements.BooleanElement)
  	      .register('array', elements.ArrayElement)
  	      .register('object', elements.ObjectElement)
  	      .register('member', elements.MemberElement)
  	      .register('ref', elements.RefElement)
  	      .register('link', elements.LinkElement);

  	    // Add instance detection functions to convert existing objects into
  	    // the corresponding refract elements.
  	    this
  	      .detect(isNull, elements.NullElement, false)
  	      .detect(isString, elements.StringElement, false)
  	      .detect(isNumber, elements.NumberElement, false)
  	      .detect(isBoolean, elements.BooleanElement, false)
  	      .detect(Array.isArray, elements.ArrayElement, false)
  	      .detect(isObject, elements.ObjectElement, false);

  	    return this;
  	  }

  	  /**
  	   * Register a new element class for an element.
  	   *
  	   * @param {string} name
  	   * @param elementClass
  	   */
  	  register(name, ElementClass) {
  	    this._elements = undefined;
  	    this.elementMap[name] = ElementClass;
  	    return this;
  	  }

  	  /**
  	   * Unregister a previously registered class for an element.
  	   *
  	   * @param {string} name
  	   */
  	  unregister(name) {
  	    this._elements = undefined;
  	    delete this.elementMap[name];
  	    return this;
  	  }

  	  /*
  	   * Add a new detection function to determine which element
  	   * class to use when converting existing js instances into
  	   * refract element.
  	   */
  	  detect(test, ElementClass, givenPrepend) {
  	    const prepend = givenPrepend === undefined ? true : givenPrepend;

  	    if (prepend) {
  	      this.elementDetection.unshift([test, ElementClass]);
  	    } else {
  	      this.elementDetection.push([test, ElementClass]);
  	    }

  	    return this;
  	  }

  	  /*
  	   * Convert an existing Javascript object into refract element instances, which
  	   * can be further processed or serialized into refract.
  	   * If the item passed in is already refracted, then it is returned
  	   * unmodified.
  	   */
  	  toElement(value) {
  	    if (value instanceof this.Element) { return value; }

  	    let element;

  	    for (let i = 0; i < this.elementDetection.length; i += 1) {
  	      const test = this.elementDetection[i][0];
  	      const ElementClass = this.elementDetection[i][1];

  	      if (test(value)) {
  	        element = new ElementClass(value);
  	        break;
  	      }
  	    }

  	    return element;
  	  }

  	  /*
  	   * Get an element class given an element name.
  	   */
  	  getElementClass(element) {
  	    const ElementClass = this.elementMap[element];

  	    if (ElementClass === undefined) {
  	      // Fall back to the base element. We may not know what
  	      // to do with the `content`, but downstream software
  	      // may know.
  	      return this.Element;
  	    }

  	    return ElementClass;
  	  }

  	  /*
  	   * Convert a refract document into refract element instances.
  	   */
  	  fromRefract(doc) {
  	    return this.serialiser.deserialise(doc);
  	  }

  	  /*
  	   * Convert an element to a Refracted JSON object.
  	   */
  	  toRefract(element) {
  	    return this.serialiser.serialise(element);
  	  }

  	  /*
  	   * Get an object that contains all registered element classes, where
  	   * the key is the PascalCased element name and the value is the class.
  	   */
  	  get elements() {
  	    if (this._elements === undefined) {
  	      this._elements = {
  	        Element: this.Element,
  	      };

  	      Object.keys(this.elementMap).forEach((name) => {
  	        // Currently, all registered element types use a camelCaseName.
  	        // Converting to PascalCase is as simple as upper-casing the first
  	        // letter.
  	        const pascal = name[0].toUpperCase() + name.substr(1);
  	        this._elements[pascal] = this.elementMap[name];
  	      });
  	    }

  	    return this._elements;
  	  }

  	  /**
  	   * Convinience method for getting a JSON Serialiser configured with the
  	   * current namespace
  	   *
  	   * @type JSONSerialiser
  	   * @readonly
  	   *
  	   * @memberof Namespace.prototype
  	   */
  	  get serialiser() {
  	    return new JSONSerialiser(this);
  	  }
  	}

  	JSONSerialiser.prototype.Namespace = Namespace;

  	Namespace_1 = Namespace;
  	return Namespace_1;
  }

  var JSON06Serialiser_1;
  var hasRequiredJSON06Serialiser;

  function requireJSON06Serialiser () {
  	if (hasRequiredJSON06Serialiser) return JSON06Serialiser_1;
  	hasRequiredJSON06Serialiser = 1;
  	const JSONSerialiser = requireJSONSerialiser();

  	JSON06Serialiser_1 = class JSON06Serialiser extends JSONSerialiser {
  	  serialise(element) {
  	    if (!(element instanceof this.namespace.elements.Element)) {
  	      throw new TypeError(`Given element \`${element}\` is not an Element instance`);
  	    }

  	    let variable;
  	    if (element._attributes && element.attributes.get('variable')) {
  	      variable = element.attributes.get('variable');
  	    }

  	    const payload = {
  	      element: element.element,
  	    };

  	    if (element._meta && element._meta.length > 0) {
  	      payload.meta = this.serialiseObject(element.meta);
  	    }

  	    const isEnum = (element.element === 'enum' || element.attributes.keys().indexOf('enumerations') !== -1);

  	    if (isEnum) {
  	      const attributes = this.enumSerialiseAttributes(element);

  	      if (attributes) {
  	        payload.attributes = attributes;
  	      }
  	    } else if (element._attributes && element._attributes.length > 0) {
  	      let { attributes } = element;

  	      // Meta attribute was renamed to metadata
  	      if (attributes.get('metadata')) {
  	        attributes = attributes.clone();
  	        attributes.set('meta', attributes.get('metadata'));
  	        attributes.remove('metadata');
  	      }

  	      if (element.element === 'member' && variable) {
  	        attributes = attributes.clone();
  	        attributes.remove('variable');
  	      }

  	      if (attributes.length > 0) {
  	        payload.attributes = this.serialiseObject(attributes);
  	      }
  	    }

  	    if (isEnum) {
  	      payload.content = this.enumSerialiseContent(element, payload);
  	    } else if (this[`${element.element}SerialiseContent`]) {
  	      payload.content = this[`${element.element}SerialiseContent`](element, payload);
  	    } else if (element.content !== undefined) {
  	      let content;

  	      if (variable && element.content.key) {
  	        content = element.content.clone();
  	        content.key.attributes.set('variable', variable);
  	        content = this.serialiseContent(content);
  	      } else {
  	        content = this.serialiseContent(element.content);
  	      }

  	      if (this.shouldSerialiseContent(element, content)) {
  	        payload.content = content;
  	      }
  	    } else if (this.shouldSerialiseContent(element, element.content) && element instanceof this.namespace.elements.Array) {
  	      payload.content = [];
  	    }

  	    return payload;
  	  }

  	  shouldSerialiseContent(element, content) {
  	    if (element.element === 'parseResult' || element.element === 'httpRequest'
  	        || element.element === 'httpResponse' || element.element === 'category'
  	        || element.element === 'link') {
  	      return true;
  	    }

  	    if (content === undefined) {
  	      return false;
  	    }

  	    if (Array.isArray(content) && content.length === 0) {
  	      return false;
  	    }

  	    return true;
  	  }

  	  refSerialiseContent(element, payload) {
  	    delete payload.attributes;

  	    return {
  	      href: element.toValue(),
  	      path: element.path.toValue(),
  	    };
  	  }

  	  sourceMapSerialiseContent(element) {
  	    return element.toValue();
  	  }

  	  dataStructureSerialiseContent(element) {
  	    return [this.serialiseContent(element.content)];
  	  }

  	  enumSerialiseAttributes(element) {
  	    const attributes = element.attributes.clone();

  	    // Enumerations attribute was is placed inside content (see `enumSerialiseContent` below)
  	    const enumerations = attributes.remove('enumerations') || new this.namespace.elements.Array([]);

  	    // Remove fixed type attribute from samples and default
  	    const defaultValue = attributes.get('default');
  	    let samples = attributes.get('samples') || new this.namespace.elements.Array([]);

  	    if (defaultValue && defaultValue.content) {
  	      if (defaultValue.content.attributes) {
  	        defaultValue.content.attributes.remove('typeAttributes');
  	      }
  	      // Wrap default in array (not sure it is really needed because tests pass without this line)
  	      attributes.set('default', new this.namespace.elements.Array([defaultValue.content]));
  	    }

  	    // Strip typeAttributes from samples, 0.6 doesn't usually contain them in samples
  	    samples.forEach((sample) => {
  	      if (sample.content && sample.content.element) {
  	        sample.content.attributes.remove('typeAttributes');
  	      }
  	    });

  	    // Content -> Samples
  	    if (element.content && enumerations.length !== 0) {
  	      // If we don't have enumerations, content should stay in
  	      // content (enumerations) as per Drafter 3 behaviour.
  	      samples.unshift(element.content);
  	    }

  	    samples = samples.map((sample) => {
  	      if (sample instanceof this.namespace.elements.Array) {
  	        return [sample];
  	      }

  	      return new this.namespace.elements.Array([sample.content]);
  	    });

  	    if (samples.length) {
  	      attributes.set('samples', samples);
  	    }

  	    if (attributes.length > 0) {
  	      return this.serialiseObject(attributes);
  	    }

  	    return undefined;
  	  }

  	  enumSerialiseContent(element) {
  	    // In API Elements < 1.0, the content is the enumerations
  	    // If we don't have an enumerations, use the value (Drafter 3 behaviour)

  	    if (element._attributes) {
  	      const enumerations = element.attributes.get('enumerations');

  	      if (enumerations && enumerations.length > 0) {
  	        return enumerations.content.map((enumeration) => {
  	          const e = enumeration.clone();
  	          e.attributes.remove('typeAttributes');
  	          return this.serialise(e);
  	        });
  	      }
  	    }

  	    if (element.content) {
  	      const value = element.content.clone();
  	      value.attributes.remove('typeAttributes');
  	      return [this.serialise(value)];
  	    }

  	    return [];
  	  }

  	  deserialise(value) {
  	    if (typeof value === 'string') {
  	      return new this.namespace.elements.String(value);
  	    }

  	    if (typeof value === 'number') {
  	      return new this.namespace.elements.Number(value);
  	    }

  	    if (typeof value === 'boolean') {
  	      return new this.namespace.elements.Boolean(value);
  	    }

  	    if (value === null) {
  	      return new this.namespace.elements.Null();
  	    }

  	    if (Array.isArray(value)) {
  	      return new this.namespace.elements.Array(value.map(this.deserialise, this));
  	    }

  	    const ElementClass = this.namespace.getElementClass(value.element);
  	    const element = new ElementClass();

  	    if (element.element !== value.element) {
  	      element.element = value.element;
  	    }

  	    if (value.meta) {
  	      this.deserialiseObject(value.meta, element.meta);
  	    }

  	    if (value.attributes) {
  	      this.deserialiseObject(value.attributes, element.attributes);
  	    }

  	    const content = this.deserialiseContent(value.content);
  	    if (content !== undefined || element.content === null) {
  	      element.content = content;
  	    }

  	    if (element.element === 'enum') {
  	      // Grab enumerations from content
  	      if (element.content) {
  	        element.attributes.set('enumerations', element.content);
  	      }

  	      // Unwrap the sample value (inside double array)
  	      let samples = element.attributes.get('samples');
  	      element.attributes.remove('samples');

  	      if (samples) {
  	        // Re-wrap samples from array of array to array of enum's

  	        const existingSamples = samples;

  	        samples = new this.namespace.elements.Array();
  	        existingSamples.forEach((existingSample) => {
  	          existingSample.forEach((sample) => {
  	            const enumElement = new ElementClass(sample);
  	            enumElement.element = element.element;
  	            samples.push(enumElement);
  	          });
  	        });

  	        const sample = samples.shift();

  	        if (sample) {
  	          element.content = sample.content;
  	        } else {
  	          element.content = undefined;
  	        }

  	        element.attributes.set('samples', samples);
  	      } else {
  	        element.content = undefined;
  	      }

  	      // Unwrap the default value
  	      let defaultValue = element.attributes.get('default');
  	      if (defaultValue && defaultValue.length > 0) {
  	        defaultValue = defaultValue.get(0);
  	        const defaultElement = new ElementClass(defaultValue);
  	        defaultElement.element = element.element;
  	        element.attributes.set('default', defaultElement);
  	      }
  	    } else if (element.element === 'dataStructure' && Array.isArray(element.content)) {
  	      [element.content] = element.content;
  	    } else if (element.element === 'category') {
  	      // "meta" attribute has been renamed to metadata
  	      const metadata = element.attributes.get('meta');

  	      if (metadata) {
  	        element.attributes.set('metadata', metadata);
  	        element.attributes.remove('meta');
  	      }
  	    } else if (element.element === 'member' && element.key && element.key._attributes && element.key._attributes.getValue('variable')) {
  	      element.attributes.set('variable', element.key.attributes.get('variable'));
  	      element.key.attributes.remove('variable');
  	    }

  	    return element;
  	  }

  	  // Private API

  	  serialiseContent(content) {
  	    if (content instanceof this.namespace.elements.Element) {
  	      return this.serialise(content);
  	    }

  	    if (content instanceof this.namespace.KeyValuePair) {
  	      const pair = {
  	        key: this.serialise(content.key),
  	      };

  	      if (content.value) {
  	        pair.value = this.serialise(content.value);
  	      }

  	      return pair;
  	    }

  	    if (content && content.map) {
  	      return content.map(this.serialise, this);
  	    }

  	    return content;
  	  }

  	  deserialiseContent(content) {
  	    if (content) {
  	      if (content.element) {
  	        return this.deserialise(content);
  	      }

  	      if (content.key) {
  	        const pair = new this.namespace.KeyValuePair(this.deserialise(content.key));

  	        if (content.value) {
  	          pair.value = this.deserialise(content.value);
  	        }

  	        return pair;
  	      }

  	      if (content.map) {
  	        return content.map(this.deserialise, this);
  	      }
  	    }

  	    return content;
  	  }

  	  shouldRefract(element) {
  	    if ((element._attributes && element.attributes.keys().length) || (element._meta && element.meta.keys().length)) {
  	      return true;
  	    }

  	    if (element.element === 'enum') {
  	      // enum elements are treated like primitives (array)
  	      return false;
  	    }

  	    if (element.element !== element.primitive() || element.element === 'member') {
  	      return true;
  	    }

  	    return false;
  	  }

  	  convertKeyToRefract(key, item) {
  	    if (this.shouldRefract(item)) {
  	      return this.serialise(item);
  	    }

  	    if (item.element === 'enum') {
  	      return this.serialiseEnum(item);
  	    }

  	    if (item.element === 'array') {
  	      return item.map((subItem) => {
  	        if (this.shouldRefract(subItem) || key === 'default') {
  	          return this.serialise(subItem);
  	        }

  	        if (subItem.element === 'array' || subItem.element === 'object' || subItem.element === 'enum') {
  	          // items for array or enum inside array are always serialised
  	          return subItem.children.map(subSubItem => this.serialise(subSubItem));
  	        }

  	        return subItem.toValue();
  	      });
  	    }

  	    if (item.element === 'object') {
  	      return (item.content || []).map(this.serialise, this);
  	    }

  	    return item.toValue();
  	  }

  	  serialiseEnum(element) {
  	    return element.children.map(item => this.serialise(item));
  	  }

  	  serialiseObject(obj) {
  	    const result = {};

  	    obj.forEach((value, key) => {
  	      if (value) {
  	        const keyValue = key.toValue();
  	        result[keyValue] = this.convertKeyToRefract(keyValue, value);
  	      }
  	    });

  	    return result;
  	  }

  	  deserialiseObject(from, to) {
  	    Object.keys(from).forEach((key) => {
  	      to.set(key, this.deserialise(from[key]));
  	    });
  	  }
  	};
  	return JSON06Serialiser_1;
  }

  var hasRequiredMinim;

  function requireMinim () {
  	if (hasRequiredMinim) return minim;
  	hasRequiredMinim = 1;
  	const Namespace = requireNamespace();
  	const elements = requireElements();

  	// Direct access to the Namespace class
  	minim.Namespace = Namespace;

  	// Special constructor for the Namespace class
  	minim.namespace = function namespace(options) {
  	  return new Namespace(options);
  	};

  	minim.KeyValuePair = requireKeyValuePair();

  	minim.ArraySlice = elements.ArraySlice;
  	minim.ObjectSlice = elements.ObjectSlice;

  	minim.Element = elements.Element;
  	minim.StringElement = elements.StringElement;
  	minim.NumberElement = elements.NumberElement;
  	minim.BooleanElement = elements.BooleanElement;
  	minim.NullElement = elements.NullElement;
  	minim.ArrayElement = elements.ArrayElement;
  	minim.ObjectElement = elements.ObjectElement;
  	minim.MemberElement = elements.MemberElement;
  	minim.RefElement = elements.RefElement;
  	minim.LinkElement = elements.LinkElement;

  	minim.refract = elements.refract;

  	minim.JSONSerialiser = requireJSONSerialiser();
  	minim.JSON06Serialiser = requireJSON06Serialiser();
  	return minim;
  }

  var minimExports = requireMinim();

  /**
   * @public
   */
  class Annotation extends minimExports.StringElement {
    // classes: warning | error

    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'annotation';
    }
    get code() {
      return this.attributes.get('code');
    }
    set code(value) {
      this.attributes.set('code', value);
    }
  }

  /**
   * @public
   */
  class Comment extends minimExports.StringElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'comment';
    }
  }

  /**
   * @public
   */
  class ParseResult extends minimExports.ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'parseResult';
    }
    get api() {
      return this.children.filter(item => item.classes.contains('api')).first;
    }
    get results() {
      return this.children.filter(item => item.classes.contains('result'));
    }
    get result() {
      return this.results.first;
    }
    get annotations() {
      return this.children.filter(item => item.element === 'annotation');
    }
    get warnings() {
      return this.children.filter(item => item.element === 'annotation' && item.classes.contains('warning'));
    }
    get errors() {
      return this.children.filter(item => item.element === 'annotation' && item.classes.contains('error'));
    }
    get isEmpty() {
      return this.children.reject(item => item.element === 'annotation').isEmpty;
    }
    replaceResult(replacement) {
      const {
        result
      } = this;
      if (isUndefined(result)) {
        return false;
      }

      // @ts-ignore
      const searchIndex = this.content.findIndex(e => e === result);
      if (searchIndex === -1) {
        return false;
      }
      this.content[searchIndex] = replacement;
      return true;
    }
  }

  /**
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */
  const hasMethod = (name, element) => {
    return typeof element === 'object' && element !== null && name in element && typeof element[name] === 'function';
  };

  /**
   * @public
   */
  const hasBasicElementProps = element => typeof element === 'object' && element != null && '_storedElement' in element && typeof element._storedElement === 'string' &&
  // eslint-disable-line no-underscore-dangle
  '_content' in element;

  /**
   * @public
   */
  const primitiveEq = (val, element) => {
    if (typeof element === 'object' && element !== null && 'primitive' in element) {
      return typeof element.primitive === 'function' && element.primitive() === val;
    }
    return false;
  };

  /**
   * @public
   */
  const hasClass = (cls, element) => {
    return typeof element === 'object' && element !== null && 'classes' in element && (Array.isArray(element.classes) || element.classes instanceof minimExports.ArrayElement) && element.classes.includes(cls);
  };

  /**
   * @public
   */
  const isElementType = (name, element) => typeof element === 'object' && element !== null && 'element' in element && element.element === name;

  /**
   * @public
   */
  const createPredicate = predicateCreator => {
    return predicateCreator({
      hasMethod,
      hasBasicElementProps,
      primitiveEq,
      isElementType,
      hasClass
    });
  };

  /**
   * @public
   */
  const isElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.Element || hasBasicElementProps(element) && primitiveEq(undefined, element);
  });

  /**
   * @public
   */
  const isStringElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.StringElement || hasBasicElementProps(element) && primitiveEq('string', element);
  });

  /**
   * @public
   */
  const isNumberElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.NumberElement || hasBasicElementProps(element) && primitiveEq('number', element);
  });

  /**
   * @public
   */
  const isNullElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.NullElement || hasBasicElementProps(element) && primitiveEq('null', element);
  });

  /**
   * @public
   */
  const isBooleanElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.BooleanElement || hasBasicElementProps(element) && primitiveEq('boolean', element);
  });

  /**
   * @public
   */
  const isObjectElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq,
    hasMethod
  }) => {
    return element => element instanceof minimExports.ObjectElement || hasBasicElementProps(element) && primitiveEq('object', element) && hasMethod('keys', element) && hasMethod('values', element) && hasMethod('items', element);
  });

  /**
   * @public
   */
  const isArrayElement = createPredicate(({
    hasBasicElementProps,
    primitiveEq,
    hasMethod
  }) => {
    return element => element instanceof minimExports.ArrayElement && !(element instanceof minimExports.ObjectElement) || hasBasicElementProps(element) && primitiveEq('array', element) && hasMethod('push', element) && hasMethod('unshift', element) && hasMethod('map', element) && hasMethod('reduce', element);
  });

  /**
   * @public
   */
  const isMemberElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.MemberElement || hasBasicElementProps(element) && isElementType('member', element) && primitiveEq(undefined, element);
  });

  /**
   * @public
   */
  const isLinkElement$2 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.LinkElement || hasBasicElementProps(element) && isElementType('link', element) && primitiveEq(undefined, element);
  });

  /**
   * @public
   */
  const isRefElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof minimExports.RefElement || hasBasicElementProps(element) && isElementType('ref', element) && primitiveEq(undefined, element);
  });

  /**
   * @public
   */
  const isAnnotationElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Annotation || hasBasicElementProps(element) && isElementType('annotation', element) && primitiveEq('array', element);
  });

  /**
   * @public
   */
  const isCommentElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Comment || hasBasicElementProps(element) && isElementType('comment', element) && primitiveEq('string', element);
  });

  /**
   * @public
   */
  const isParseResultElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof ParseResult || hasBasicElementProps(element) && isElementType('parseResult', element) && primitiveEq('array', element);
  });

  /**
   * @public
   */

  /**
   * @public
   */
  const isPrimitiveElement = element => {
    return isElementType('object', element) || isElementType('array', element) || isElementType('boolean', element) || isElementType('number', element) || isElementType('string', element) || isElementType('null', element) || isElementType('member', element);
  };

  /**
   * @public
   */
  const hasElementSourceMap = element => {
    if (!isElement(element)) {
      return false;
    }
    return Number.isInteger(element.startPositionRow) && Number.isInteger(element.startPositionColumn) && Number.isInteger(element.startIndex) && Number.isInteger(element.endPositionRow) && Number.isInteger(element.endPositionColumn) && Number.isInteger(element.endIndex);
  };

  /**
   * @public
   */
  const includesSymbols = (symbols, element) => {
    if (symbols.length === 0) {
      return true;
    }
    const elementSymbols = element.attributes.get('symbols');
    if (!isArrayElement(elementSymbols)) {
      return false;
    }
    return all(included(elementSymbols.toValue()), symbols);
  };

  /**
   * @public
   */
  const includesClasses = (classes, element) => {
    if (classes.length === 0) {
      return true;
    }
    return all(included(element.classes.toValue()), classes);
  };

  const basePredicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    hasElementSourceMap,
    includesClasses,
    includesSymbols,
    isAnnotationElement,
    isArrayElement,
    isBooleanElement,
    isCommentElement,
    isElement,
    isLinkElement: isLinkElement$2,
    isMemberElement,
    isNullElement,
    isNumberElement,
    isObjectElement,
    isParseResultElement,
    isPrimitiveElement,
    isRefElement,
    isStringElement
  }, Symbol.toStringTag, { value: 'Module' }));

  /**
   * @public
   */
  class Namespace extends minimExports.Namespace {
    constructor() {
      super();
      this.register('annotation', Annotation);
      this.register('comment', Comment);
      this.register('parseResult', ParseResult);
    }
  }

  /**
   * @public
   */
  const namespace = new Namespace();

  /**
   * @public
   */
  const createNamespace = namespacePlugin => {
    const namespaceInstance = new Namespace();
    if (isPlainObj(namespacePlugin)) {
      namespaceInstance.use(namespacePlugin);
    }
    return namespaceInstance;
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  const createToolbox$7 = () => {
    const predicates = {
      ...basePredicates
    };
    return {
      predicates,
      namespace: namespace
    };
  };

  var esnext_aggregateError = {};

  var es_aggregateError = {};

  var es_aggregateError_constructor = {};

  var globalThis_1;
  var hasRequiredGlobalThis;

  function requireGlobalThis () {
  	if (hasRequiredGlobalThis) return globalThis_1;
  	hasRequiredGlobalThis = 1;
  	var check = function (it) {
  	  return it && it.Math === Math && it;
  	};

  	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  	globalThis_1 =
  	  // eslint-disable-next-line es/no-global-this -- safe
  	  check(typeof globalThis == 'object' && globalThis) ||
  	  check(typeof window == 'object' && window) ||
  	  // eslint-disable-next-line no-restricted-globals -- safe
  	  check(typeof self == 'object' && self) ||
  	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  	  check(typeof globalThis_1 == 'object' && globalThis_1) ||
  	  // eslint-disable-next-line no-new-func -- fallback
  	  (function () { return this; })() || Function('return this')();
  	return globalThis_1;
  }

  var fails;
  var hasRequiredFails;

  function requireFails () {
  	if (hasRequiredFails) return fails;
  	hasRequiredFails = 1;
  	fails = function (exec) {
  	  try {
  	    return !!exec();
  	  } catch (error) {
  	    return true;
  	  }
  	};
  	return fails;
  }

  var functionBindNative;
  var hasRequiredFunctionBindNative;

  function requireFunctionBindNative () {
  	if (hasRequiredFunctionBindNative) return functionBindNative;
  	hasRequiredFunctionBindNative = 1;
  	var fails = /*@__PURE__*/ requireFails();

  	functionBindNative = !fails(function () {
  	  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  	  var test = (function () { /* empty */ }).bind();
  	  // eslint-disable-next-line no-prototype-builtins -- safe
  	  return typeof test != 'function' || test.hasOwnProperty('prototype');
  	});
  	return functionBindNative;
  }

  var functionApply;
  var hasRequiredFunctionApply;

  function requireFunctionApply () {
  	if (hasRequiredFunctionApply) return functionApply;
  	hasRequiredFunctionApply = 1;
  	var NATIVE_BIND = /*@__PURE__*/ requireFunctionBindNative();

  	var FunctionPrototype = Function.prototype;
  	var apply = FunctionPrototype.apply;
  	var call = FunctionPrototype.call;

  	// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
  	functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  	  return call.apply(apply, arguments);
  	});
  	return functionApply;
  }

  var functionUncurryThis;
  var hasRequiredFunctionUncurryThis;

  function requireFunctionUncurryThis () {
  	if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
  	hasRequiredFunctionUncurryThis = 1;
  	var NATIVE_BIND = /*@__PURE__*/ requireFunctionBindNative();

  	var FunctionPrototype = Function.prototype;
  	var call = FunctionPrototype.call;
  	// eslint-disable-next-line es/no-function-prototype-bind -- safe
  	var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

  	functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  	  return function () {
  	    return call.apply(fn, arguments);
  	  };
  	};
  	return functionUncurryThis;
  }

  var classofRaw;
  var hasRequiredClassofRaw;

  function requireClassofRaw () {
  	if (hasRequiredClassofRaw) return classofRaw;
  	hasRequiredClassofRaw = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();

  	var toString = uncurryThis({}.toString);
  	var stringSlice = uncurryThis(''.slice);

  	classofRaw = function (it) {
  	  return stringSlice(toString(it), 8, -1);
  	};
  	return classofRaw;
  }

  var functionUncurryThisClause;
  var hasRequiredFunctionUncurryThisClause;

  function requireFunctionUncurryThisClause () {
  	if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
  	hasRequiredFunctionUncurryThisClause = 1;
  	var classofRaw = /*@__PURE__*/ requireClassofRaw();
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();

  	functionUncurryThisClause = function (fn) {
  	  // Nashorn bug:
  	  //   https://github.com/zloirock/core-js/issues/1128
  	  //   https://github.com/zloirock/core-js/issues/1130
  	  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
  	};
  	return functionUncurryThisClause;
  }

  var isCallable;
  var hasRequiredIsCallable;

  function requireIsCallable () {
  	if (hasRequiredIsCallable) return isCallable;
  	hasRequiredIsCallable = 1;
  	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
  	var documentAll = typeof document == 'object' && document.all;

  	// `IsCallable` abstract operation
  	// https://tc39.es/ecma262/#sec-iscallable
  	// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
  	isCallable = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  	  return typeof argument == 'function' || argument === documentAll;
  	} : function (argument) {
  	  return typeof argument == 'function';
  	};
  	return isCallable;
  }

  var objectGetOwnPropertyDescriptor = {};

  var descriptors;
  var hasRequiredDescriptors;

  function requireDescriptors () {
  	if (hasRequiredDescriptors) return descriptors;
  	hasRequiredDescriptors = 1;
  	var fails = /*@__PURE__*/ requireFails();

  	// Detect IE8's incomplete defineProperty implementation
  	descriptors = !fails(function () {
  	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
  	});
  	return descriptors;
  }

  var functionCall;
  var hasRequiredFunctionCall;

  function requireFunctionCall () {
  	if (hasRequiredFunctionCall) return functionCall;
  	hasRequiredFunctionCall = 1;
  	var NATIVE_BIND = /*@__PURE__*/ requireFunctionBindNative();

  	var call = Function.prototype.call;
  	// eslint-disable-next-line es/no-function-prototype-bind -- safe
  	functionCall = NATIVE_BIND ? call.bind(call) : function () {
  	  return call.apply(call, arguments);
  	};
  	return functionCall;
  }

  var objectPropertyIsEnumerable = {};

  var hasRequiredObjectPropertyIsEnumerable;

  function requireObjectPropertyIsEnumerable () {
  	if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
  	hasRequiredObjectPropertyIsEnumerable = 1;
  	var $propertyIsEnumerable = {}.propertyIsEnumerable;
  	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  	// Nashorn ~ JDK8 bug
  	var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

  	// `Object.prototype.propertyIsEnumerable` method implementation
  	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  	objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  	  var descriptor = getOwnPropertyDescriptor(this, V);
  	  return !!descriptor && descriptor.enumerable;
  	} : $propertyIsEnumerable;
  	return objectPropertyIsEnumerable;
  }

  var createPropertyDescriptor;
  var hasRequiredCreatePropertyDescriptor;

  function requireCreatePropertyDescriptor () {
  	if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
  	hasRequiredCreatePropertyDescriptor = 1;
  	createPropertyDescriptor = function (bitmap, value) {
  	  return {
  	    enumerable: !(bitmap & 1),
  	    configurable: !(bitmap & 2),
  	    writable: !(bitmap & 4),
  	    value: value
  	  };
  	};
  	return createPropertyDescriptor;
  }

  var indexedObject;
  var hasRequiredIndexedObject;

  function requireIndexedObject () {
  	if (hasRequiredIndexedObject) return indexedObject;
  	hasRequiredIndexedObject = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();
  	var fails = /*@__PURE__*/ requireFails();
  	var classof = /*@__PURE__*/ requireClassofRaw();

  	var $Object = Object;
  	var split = uncurryThis(''.split);

  	// fallback for non-array-like ES3 and non-enumerable old V8 strings
  	indexedObject = fails(function () {
  	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  	  // eslint-disable-next-line no-prototype-builtins -- safe
  	  return !$Object('z').propertyIsEnumerable(0);
  	}) ? function (it) {
  	  return classof(it) === 'String' ? split(it, '') : $Object(it);
  	} : $Object;
  	return indexedObject;
  }

  var isNullOrUndefined;
  var hasRequiredIsNullOrUndefined;

  function requireIsNullOrUndefined () {
  	if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
  	hasRequiredIsNullOrUndefined = 1;
  	// we can't use just `it == null` since of `document.all` special case
  	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
  	isNullOrUndefined = function (it) {
  	  return it === null || it === undefined;
  	};
  	return isNullOrUndefined;
  }

  var requireObjectCoercible;
  var hasRequiredRequireObjectCoercible;

  function requireRequireObjectCoercible () {
  	if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
  	hasRequiredRequireObjectCoercible = 1;
  	var isNullOrUndefined = /*@__PURE__*/ requireIsNullOrUndefined();

  	var $TypeError = TypeError;

  	// `RequireObjectCoercible` abstract operation
  	// https://tc39.es/ecma262/#sec-requireobjectcoercible
  	requireObjectCoercible = function (it) {
  	  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  	  return it;
  	};
  	return requireObjectCoercible;
  }

  var toIndexedObject;
  var hasRequiredToIndexedObject;

  function requireToIndexedObject () {
  	if (hasRequiredToIndexedObject) return toIndexedObject;
  	hasRequiredToIndexedObject = 1;
  	// toObject with fallback for non-array-like ES3 strings
  	var IndexedObject = /*@__PURE__*/ requireIndexedObject();
  	var requireObjectCoercible = /*@__PURE__*/ requireRequireObjectCoercible();

  	toIndexedObject = function (it) {
  	  return IndexedObject(requireObjectCoercible(it));
  	};
  	return toIndexedObject;
  }

  var isObject;
  var hasRequiredIsObject;

  function requireIsObject () {
  	if (hasRequiredIsObject) return isObject;
  	hasRequiredIsObject = 1;
  	var isCallable = /*@__PURE__*/ requireIsCallable();

  	isObject = function (it) {
  	  return typeof it == 'object' ? it !== null : isCallable(it);
  	};
  	return isObject;
  }

  var path;
  var hasRequiredPath;

  function requirePath () {
  	if (hasRequiredPath) return path;
  	hasRequiredPath = 1;
  	path = {};
  	return path;
  }

  var getBuiltIn;
  var hasRequiredGetBuiltIn;

  function requireGetBuiltIn () {
  	if (hasRequiredGetBuiltIn) return getBuiltIn;
  	hasRequiredGetBuiltIn = 1;
  	var path = /*@__PURE__*/ requirePath();
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var isCallable = /*@__PURE__*/ requireIsCallable();

  	var aFunction = function (variable) {
  	  return isCallable(variable) ? variable : undefined;
  	};

  	getBuiltIn = function (namespace, method) {
  	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(globalThis[namespace])
  	    : path[namespace] && path[namespace][method] || globalThis[namespace] && globalThis[namespace][method];
  	};
  	return getBuiltIn;
  }

  var objectIsPrototypeOf;
  var hasRequiredObjectIsPrototypeOf;

  function requireObjectIsPrototypeOf () {
  	if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
  	hasRequiredObjectIsPrototypeOf = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();

  	objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
  	return objectIsPrototypeOf;
  }

  var environmentUserAgent;
  var hasRequiredEnvironmentUserAgent;

  function requireEnvironmentUserAgent () {
  	if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
  	hasRequiredEnvironmentUserAgent = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();

  	var navigator = globalThis.navigator;
  	var userAgent = navigator && navigator.userAgent;

  	environmentUserAgent = userAgent ? String(userAgent) : '';
  	return environmentUserAgent;
  }

  var environmentV8Version;
  var hasRequiredEnvironmentV8Version;

  function requireEnvironmentV8Version () {
  	if (hasRequiredEnvironmentV8Version) return environmentV8Version;
  	hasRequiredEnvironmentV8Version = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var userAgent = /*@__PURE__*/ requireEnvironmentUserAgent();

  	var process = globalThis.process;
  	var Deno = globalThis.Deno;
  	var versions = process && process.versions || Deno && Deno.version;
  	var v8 = versions && versions.v8;
  	var match, version;

  	if (v8) {
  	  match = v8.split('.');
  	  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  	  // but their correct versions are not interesting for us
  	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  	}

  	// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  	// so check `userAgent` even if `.v8` exists, but 0
  	if (!version && userAgent) {
  	  match = userAgent.match(/Edge\/(\d+)/);
  	  if (!match || match[1] >= 74) {
  	    match = userAgent.match(/Chrome\/(\d+)/);
  	    if (match) version = +match[1];
  	  }
  	}

  	environmentV8Version = version;
  	return environmentV8Version;
  }

  var symbolConstructorDetection;
  var hasRequiredSymbolConstructorDetection;

  function requireSymbolConstructorDetection () {
  	if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
  	hasRequiredSymbolConstructorDetection = 1;
  	/* eslint-disable es/no-symbol -- required for testing */
  	var V8_VERSION = /*@__PURE__*/ requireEnvironmentV8Version();
  	var fails = /*@__PURE__*/ requireFails();
  	var globalThis = /*@__PURE__*/ requireGlobalThis();

  	var $String = globalThis.String;

  	// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
  	symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(function () {
  	  var symbol = Symbol('symbol detection');
  	  // Chrome 38 Symbol has incorrect toString conversion
  	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  	  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  	  // of course, fail.
  	  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
  	    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  	    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  	});
  	return symbolConstructorDetection;
  }

  var useSymbolAsUid;
  var hasRequiredUseSymbolAsUid;

  function requireUseSymbolAsUid () {
  	if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
  	hasRequiredUseSymbolAsUid = 1;
  	/* eslint-disable es/no-symbol -- required for testing */
  	var NATIVE_SYMBOL = /*@__PURE__*/ requireSymbolConstructorDetection();

  	useSymbolAsUid = NATIVE_SYMBOL &&
  	  !Symbol.sham &&
  	  typeof Symbol.iterator == 'symbol';
  	return useSymbolAsUid;
  }

  var isSymbol;
  var hasRequiredIsSymbol;

  function requireIsSymbol () {
  	if (hasRequiredIsSymbol) return isSymbol;
  	hasRequiredIsSymbol = 1;
  	var getBuiltIn = /*@__PURE__*/ requireGetBuiltIn();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var isPrototypeOf = /*@__PURE__*/ requireObjectIsPrototypeOf();
  	var USE_SYMBOL_AS_UID = /*@__PURE__*/ requireUseSymbolAsUid();

  	var $Object = Object;

  	isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  	  return typeof it == 'symbol';
  	} : function (it) {
  	  var $Symbol = getBuiltIn('Symbol');
  	  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
  	};
  	return isSymbol;
  }

  var tryToString;
  var hasRequiredTryToString;

  function requireTryToString () {
  	if (hasRequiredTryToString) return tryToString;
  	hasRequiredTryToString = 1;
  	var $String = String;

  	tryToString = function (argument) {
  	  try {
  	    return $String(argument);
  	  } catch (error) {
  	    return 'Object';
  	  }
  	};
  	return tryToString;
  }

  var aCallable;
  var hasRequiredACallable;

  function requireACallable () {
  	if (hasRequiredACallable) return aCallable;
  	hasRequiredACallable = 1;
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var tryToString = /*@__PURE__*/ requireTryToString();

  	var $TypeError = TypeError;

  	// `Assert: IsCallable(argument) is true`
  	aCallable = function (argument) {
  	  if (isCallable(argument)) return argument;
  	  throw new $TypeError(tryToString(argument) + ' is not a function');
  	};
  	return aCallable;
  }

  var getMethod;
  var hasRequiredGetMethod;

  function requireGetMethod () {
  	if (hasRequiredGetMethod) return getMethod;
  	hasRequiredGetMethod = 1;
  	var aCallable = /*@__PURE__*/ requireACallable();
  	var isNullOrUndefined = /*@__PURE__*/ requireIsNullOrUndefined();

  	// `GetMethod` abstract operation
  	// https://tc39.es/ecma262/#sec-getmethod
  	getMethod = function (V, P) {
  	  var func = V[P];
  	  return isNullOrUndefined(func) ? undefined : aCallable(func);
  	};
  	return getMethod;
  }

  var ordinaryToPrimitive;
  var hasRequiredOrdinaryToPrimitive;

  function requireOrdinaryToPrimitive () {
  	if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
  	hasRequiredOrdinaryToPrimitive = 1;
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var isObject = /*@__PURE__*/ requireIsObject();

  	var $TypeError = TypeError;

  	// `OrdinaryToPrimitive` abstract operation
  	// https://tc39.es/ecma262/#sec-ordinarytoprimitive
  	ordinaryToPrimitive = function (input, pref) {
  	  var fn, val;
  	  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  	  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  	  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  	  throw new $TypeError("Can't convert object to primitive value");
  	};
  	return ordinaryToPrimitive;
  }

  var sharedStore = {exports: {}};

  var isPure;
  var hasRequiredIsPure;

  function requireIsPure () {
  	if (hasRequiredIsPure) return isPure;
  	hasRequiredIsPure = 1;
  	isPure = true;
  	return isPure;
  }

  var defineGlobalProperty;
  var hasRequiredDefineGlobalProperty;

  function requireDefineGlobalProperty () {
  	if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
  	hasRequiredDefineGlobalProperty = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();

  	// eslint-disable-next-line es/no-object-defineproperty -- safe
  	var defineProperty = Object.defineProperty;

  	defineGlobalProperty = function (key, value) {
  	  try {
  	    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  	  } catch (error) {
  	    globalThis[key] = value;
  	  } return value;
  	};
  	return defineGlobalProperty;
  }

  var hasRequiredSharedStore;

  function requireSharedStore () {
  	if (hasRequiredSharedStore) return sharedStore.exports;
  	hasRequiredSharedStore = 1;
  	var IS_PURE = /*@__PURE__*/ requireIsPure();
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var defineGlobalProperty = /*@__PURE__*/ requireDefineGlobalProperty();

  	var SHARED = '__core-js_shared__';
  	var store = sharedStore.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

  	(store.versions || (store.versions = [])).push({
  	  version: '3.42.0',
  	  mode: IS_PURE ? 'pure' : 'global',
  	  copyright: '© 2014-2025 Denis Pushkarev (zloirock.ru)',
  	  license: 'https://github.com/zloirock/core-js/blob/v3.42.0/LICENSE',
  	  source: 'https://github.com/zloirock/core-js'
  	});
  	return sharedStore.exports;
  }

  var shared;
  var hasRequiredShared;

  function requireShared () {
  	if (hasRequiredShared) return shared;
  	hasRequiredShared = 1;
  	var store = /*@__PURE__*/ requireSharedStore();

  	shared = function (key, value) {
  	  return store[key] || (store[key] = value || {});
  	};
  	return shared;
  }

  var toObject;
  var hasRequiredToObject;

  function requireToObject () {
  	if (hasRequiredToObject) return toObject;
  	hasRequiredToObject = 1;
  	var requireObjectCoercible = /*@__PURE__*/ requireRequireObjectCoercible();

  	var $Object = Object;

  	// `ToObject` abstract operation
  	// https://tc39.es/ecma262/#sec-toobject
  	toObject = function (argument) {
  	  return $Object(requireObjectCoercible(argument));
  	};
  	return toObject;
  }

  var hasOwnProperty_1;
  var hasRequiredHasOwnProperty;

  function requireHasOwnProperty () {
  	if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
  	hasRequiredHasOwnProperty = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();
  	var toObject = /*@__PURE__*/ requireToObject();

  	var hasOwnProperty = uncurryThis({}.hasOwnProperty);

  	// `HasOwnProperty` abstract operation
  	// https://tc39.es/ecma262/#sec-hasownproperty
  	// eslint-disable-next-line es/no-object-hasown -- safe
  	hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  	  return hasOwnProperty(toObject(it), key);
  	};
  	return hasOwnProperty_1;
  }

  var uid;
  var hasRequiredUid;

  function requireUid () {
  	if (hasRequiredUid) return uid;
  	hasRequiredUid = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();

  	var id = 0;
  	var postfix = Math.random();
  	var toString = uncurryThis(1.0.toString);

  	uid = function (key) {
  	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
  	};
  	return uid;
  }

  var wellKnownSymbol;
  var hasRequiredWellKnownSymbol;

  function requireWellKnownSymbol () {
  	if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
  	hasRequiredWellKnownSymbol = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var shared = /*@__PURE__*/ requireShared();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var uid = /*@__PURE__*/ requireUid();
  	var NATIVE_SYMBOL = /*@__PURE__*/ requireSymbolConstructorDetection();
  	var USE_SYMBOL_AS_UID = /*@__PURE__*/ requireUseSymbolAsUid();

  	var Symbol = globalThis.Symbol;
  	var WellKnownSymbolsStore = shared('wks');
  	var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

  	wellKnownSymbol = function (name) {
  	  if (!hasOwn(WellKnownSymbolsStore, name)) {
  	    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
  	      ? Symbol[name]
  	      : createWellKnownSymbol('Symbol.' + name);
  	  } return WellKnownSymbolsStore[name];
  	};
  	return wellKnownSymbol;
  }

  var toPrimitive;
  var hasRequiredToPrimitive;

  function requireToPrimitive () {
  	if (hasRequiredToPrimitive) return toPrimitive;
  	hasRequiredToPrimitive = 1;
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var isObject = /*@__PURE__*/ requireIsObject();
  	var isSymbol = /*@__PURE__*/ requireIsSymbol();
  	var getMethod = /*@__PURE__*/ requireGetMethod();
  	var ordinaryToPrimitive = /*@__PURE__*/ requireOrdinaryToPrimitive();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();

  	var $TypeError = TypeError;
  	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  	// `ToPrimitive` abstract operation
  	// https://tc39.es/ecma262/#sec-toprimitive
  	toPrimitive = function (input, pref) {
  	  if (!isObject(input) || isSymbol(input)) return input;
  	  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  	  var result;
  	  if (exoticToPrim) {
  	    if (pref === undefined) pref = 'default';
  	    result = call(exoticToPrim, input, pref);
  	    if (!isObject(result) || isSymbol(result)) return result;
  	    throw new $TypeError("Can't convert object to primitive value");
  	  }
  	  if (pref === undefined) pref = 'number';
  	  return ordinaryToPrimitive(input, pref);
  	};
  	return toPrimitive;
  }

  var toPropertyKey;
  var hasRequiredToPropertyKey;

  function requireToPropertyKey () {
  	if (hasRequiredToPropertyKey) return toPropertyKey;
  	hasRequiredToPropertyKey = 1;
  	var toPrimitive = /*@__PURE__*/ requireToPrimitive();
  	var isSymbol = /*@__PURE__*/ requireIsSymbol();

  	// `ToPropertyKey` abstract operation
  	// https://tc39.es/ecma262/#sec-topropertykey
  	toPropertyKey = function (argument) {
  	  var key = toPrimitive(argument, 'string');
  	  return isSymbol(key) ? key : key + '';
  	};
  	return toPropertyKey;
  }

  var documentCreateElement;
  var hasRequiredDocumentCreateElement;

  function requireDocumentCreateElement () {
  	if (hasRequiredDocumentCreateElement) return documentCreateElement;
  	hasRequiredDocumentCreateElement = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var isObject = /*@__PURE__*/ requireIsObject();

  	var document = globalThis.document;
  	// typeof document.createElement is 'object' in old IE
  	var EXISTS = isObject(document) && isObject(document.createElement);

  	documentCreateElement = function (it) {
  	  return EXISTS ? document.createElement(it) : {};
  	};
  	return documentCreateElement;
  }

  var ie8DomDefine;
  var hasRequiredIe8DomDefine;

  function requireIe8DomDefine () {
  	if (hasRequiredIe8DomDefine) return ie8DomDefine;
  	hasRequiredIe8DomDefine = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var fails = /*@__PURE__*/ requireFails();
  	var createElement = /*@__PURE__*/ requireDocumentCreateElement();

  	// Thanks to IE8 for its funny defineProperty
  	ie8DomDefine = !DESCRIPTORS && !fails(function () {
  	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  	  return Object.defineProperty(createElement('div'), 'a', {
  	    get: function () { return 7; }
  	  }).a !== 7;
  	});
  	return ie8DomDefine;
  }

  var hasRequiredObjectGetOwnPropertyDescriptor;

  function requireObjectGetOwnPropertyDescriptor () {
  	if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
  	hasRequiredObjectGetOwnPropertyDescriptor = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var propertyIsEnumerableModule = /*@__PURE__*/ requireObjectPropertyIsEnumerable();
  	var createPropertyDescriptor = /*@__PURE__*/ requireCreatePropertyDescriptor();
  	var toIndexedObject = /*@__PURE__*/ requireToIndexedObject();
  	var toPropertyKey = /*@__PURE__*/ requireToPropertyKey();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var IE8_DOM_DEFINE = /*@__PURE__*/ requireIe8DomDefine();

  	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  	// `Object.getOwnPropertyDescriptor` method
  	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  	objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  	  O = toIndexedObject(O);
  	  P = toPropertyKey(P);
  	  if (IE8_DOM_DEFINE) try {
  	    return $getOwnPropertyDescriptor(O, P);
  	  } catch (error) { /* empty */ }
  	  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
  	};
  	return objectGetOwnPropertyDescriptor;
  }

  var isForced_1;
  var hasRequiredIsForced;

  function requireIsForced () {
  	if (hasRequiredIsForced) return isForced_1;
  	hasRequiredIsForced = 1;
  	var fails = /*@__PURE__*/ requireFails();
  	var isCallable = /*@__PURE__*/ requireIsCallable();

  	var replacement = /#|\.prototype\./;

  	var isForced = function (feature, detection) {
  	  var value = data[normalize(feature)];
  	  return value === POLYFILL ? true
  	    : value === NATIVE ? false
  	    : isCallable(detection) ? fails(detection)
  	    : !!detection;
  	};

  	var normalize = isForced.normalize = function (string) {
  	  return String(string).replace(replacement, '.').toLowerCase();
  	};

  	var data = isForced.data = {};
  	var NATIVE = isForced.NATIVE = 'N';
  	var POLYFILL = isForced.POLYFILL = 'P';

  	isForced_1 = isForced;
  	return isForced_1;
  }

  var functionBindContext;
  var hasRequiredFunctionBindContext;

  function requireFunctionBindContext () {
  	if (hasRequiredFunctionBindContext) return functionBindContext;
  	hasRequiredFunctionBindContext = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThisClause();
  	var aCallable = /*@__PURE__*/ requireACallable();
  	var NATIVE_BIND = /*@__PURE__*/ requireFunctionBindNative();

  	var bind = uncurryThis(uncurryThis.bind);

  	// optional / simple context binding
  	functionBindContext = function (fn, that) {
  	  aCallable(fn);
  	  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
  	    return fn.apply(that, arguments);
  	  };
  	};
  	return functionBindContext;
  }

  var objectDefineProperty = {};

  var v8PrototypeDefineBug;
  var hasRequiredV8PrototypeDefineBug;

  function requireV8PrototypeDefineBug () {
  	if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
  	hasRequiredV8PrototypeDefineBug = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var fails = /*@__PURE__*/ requireFails();

  	// V8 ~ Chrome 36-
  	// https://bugs.chromium.org/p/v8/issues/detail?id=3334
  	v8PrototypeDefineBug = DESCRIPTORS && fails(function () {
  	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  	  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
  	    value: 42,
  	    writable: false
  	  }).prototype !== 42;
  	});
  	return v8PrototypeDefineBug;
  }

  var anObject;
  var hasRequiredAnObject;

  function requireAnObject () {
  	if (hasRequiredAnObject) return anObject;
  	hasRequiredAnObject = 1;
  	var isObject = /*@__PURE__*/ requireIsObject();

  	var $String = String;
  	var $TypeError = TypeError;

  	// `Assert: Type(argument) is Object`
  	anObject = function (argument) {
  	  if (isObject(argument)) return argument;
  	  throw new $TypeError($String(argument) + ' is not an object');
  	};
  	return anObject;
  }

  var hasRequiredObjectDefineProperty;

  function requireObjectDefineProperty () {
  	if (hasRequiredObjectDefineProperty) return objectDefineProperty;
  	hasRequiredObjectDefineProperty = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var IE8_DOM_DEFINE = /*@__PURE__*/ requireIe8DomDefine();
  	var V8_PROTOTYPE_DEFINE_BUG = /*@__PURE__*/ requireV8PrototypeDefineBug();
  	var anObject = /*@__PURE__*/ requireAnObject();
  	var toPropertyKey = /*@__PURE__*/ requireToPropertyKey();

  	var $TypeError = TypeError;
  	// eslint-disable-next-line es/no-object-defineproperty -- safe
  	var $defineProperty = Object.defineProperty;
  	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  	var ENUMERABLE = 'enumerable';
  	var CONFIGURABLE = 'configurable';
  	var WRITABLE = 'writable';

  	// `Object.defineProperty` method
  	// https://tc39.es/ecma262/#sec-object.defineproperty
  	objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  	  anObject(O);
  	  P = toPropertyKey(P);
  	  anObject(Attributes);
  	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
  	    var current = $getOwnPropertyDescriptor(O, P);
  	    if (current && current[WRITABLE]) {
  	      O[P] = Attributes.value;
  	      Attributes = {
  	        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
  	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
  	        writable: false
  	      };
  	    }
  	  } return $defineProperty(O, P, Attributes);
  	} : $defineProperty : function defineProperty(O, P, Attributes) {
  	  anObject(O);
  	  P = toPropertyKey(P);
  	  anObject(Attributes);
  	  if (IE8_DOM_DEFINE) try {
  	    return $defineProperty(O, P, Attributes);
  	  } catch (error) { /* empty */ }
  	  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  	  if ('value' in Attributes) O[P] = Attributes.value;
  	  return O;
  	};
  	return objectDefineProperty;
  }

  var createNonEnumerableProperty;
  var hasRequiredCreateNonEnumerableProperty;

  function requireCreateNonEnumerableProperty () {
  	if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
  	hasRequiredCreateNonEnumerableProperty = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var definePropertyModule = /*@__PURE__*/ requireObjectDefineProperty();
  	var createPropertyDescriptor = /*@__PURE__*/ requireCreatePropertyDescriptor();

  	createNonEnumerableProperty = DESCRIPTORS ? function (object, key, value) {
  	  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
  	} : function (object, key, value) {
  	  object[key] = value;
  	  return object;
  	};
  	return createNonEnumerableProperty;
  }

  var _export;
  var hasRequired_export;

  function require_export () {
  	if (hasRequired_export) return _export;
  	hasRequired_export = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var apply = /*@__PURE__*/ requireFunctionApply();
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThisClause();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var getOwnPropertyDescriptor = /*@__PURE__*/ requireObjectGetOwnPropertyDescriptor().f;
  	var isForced = /*@__PURE__*/ requireIsForced();
  	var path = /*@__PURE__*/ requirePath();
  	var bind = /*@__PURE__*/ requireFunctionBindContext();
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();

  	var wrapConstructor = function (NativeConstructor) {
  	  var Wrapper = function (a, b, c) {
  	    if (this instanceof Wrapper) {
  	      switch (arguments.length) {
  	        case 0: return new NativeConstructor();
  	        case 1: return new NativeConstructor(a);
  	        case 2: return new NativeConstructor(a, b);
  	      } return new NativeConstructor(a, b, c);
  	    } return apply(NativeConstructor, this, arguments);
  	  };
  	  Wrapper.prototype = NativeConstructor.prototype;
  	  return Wrapper;
  	};

  	/*
  	  options.target         - name of the target object
  	  options.global         - target is the global object
  	  options.stat           - export as static methods of target
  	  options.proto          - export as prototype methods of target
  	  options.real           - real prototype method for the `pure` version
  	  options.forced         - export even if the native feature is available
  	  options.bind           - bind methods to the target, required for the `pure` version
  	  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  	  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  	  options.sham           - add a flag to not completely full polyfills
  	  options.enumerable     - export as enumerable property
  	  options.dontCallGetSet - prevent calling a getter on target
  	  options.name           - the .name of the function if it does not match the key
  	*/
  	_export = function (options, source) {
  	  var TARGET = options.target;
  	  var GLOBAL = options.global;
  	  var STATIC = options.stat;
  	  var PROTO = options.proto;

  	  var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;

  	  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  	  var targetPrototype = target.prototype;

  	  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  	  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  	  for (key in source) {
  	    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
  	    // contains in native
  	    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

  	    targetProperty = target[key];

  	    if (USE_NATIVE) if (options.dontCallGetSet) {
  	      descriptor = getOwnPropertyDescriptor(nativeSource, key);
  	      nativeProperty = descriptor && descriptor.value;
  	    } else nativeProperty = nativeSource[key];

  	    // export native or implementation
  	    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

  	    if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;

  	    // bind methods to global for calling from export context
  	    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis);
  	    // wrap global constructors for prevent changes in this version
  	    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
  	    // make static versions for prototype methods
  	    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
  	    // default case
  	    else resultProperty = sourceProperty;

  	    // add a flag to not completely full polyfills
  	    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
  	      createNonEnumerableProperty(resultProperty, 'sham', true);
  	    }

  	    createNonEnumerableProperty(target, key, resultProperty);

  	    if (PROTO) {
  	      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
  	      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
  	        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
  	      }
  	      // export virtual prototype methods
  	      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
  	      // export real prototype methods
  	      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
  	        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
  	      }
  	    }
  	  }
  	};
  	return _export;
  }

  var sharedKey;
  var hasRequiredSharedKey;

  function requireSharedKey () {
  	if (hasRequiredSharedKey) return sharedKey;
  	hasRequiredSharedKey = 1;
  	var shared = /*@__PURE__*/ requireShared();
  	var uid = /*@__PURE__*/ requireUid();

  	var keys = shared('keys');

  	sharedKey = function (key) {
  	  return keys[key] || (keys[key] = uid(key));
  	};
  	return sharedKey;
  }

  var correctPrototypeGetter;
  var hasRequiredCorrectPrototypeGetter;

  function requireCorrectPrototypeGetter () {
  	if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
  	hasRequiredCorrectPrototypeGetter = 1;
  	var fails = /*@__PURE__*/ requireFails();

  	correctPrototypeGetter = !fails(function () {
  	  function F() { /* empty */ }
  	  F.prototype.constructor = null;
  	  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  	  return Object.getPrototypeOf(new F()) !== F.prototype;
  	});
  	return correctPrototypeGetter;
  }

  var objectGetPrototypeOf;
  var hasRequiredObjectGetPrototypeOf;

  function requireObjectGetPrototypeOf () {
  	if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
  	hasRequiredObjectGetPrototypeOf = 1;
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var toObject = /*@__PURE__*/ requireToObject();
  	var sharedKey = /*@__PURE__*/ requireSharedKey();
  	var CORRECT_PROTOTYPE_GETTER = /*@__PURE__*/ requireCorrectPrototypeGetter();

  	var IE_PROTO = sharedKey('IE_PROTO');
  	var $Object = Object;
  	var ObjectPrototype = $Object.prototype;

  	// `Object.getPrototypeOf` method
  	// https://tc39.es/ecma262/#sec-object.getprototypeof
  	// eslint-disable-next-line es/no-object-getprototypeof -- safe
  	objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  	  var object = toObject(O);
  	  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  	  var constructor = object.constructor;
  	  if (isCallable(constructor) && object instanceof constructor) {
  	    return constructor.prototype;
  	  } return object instanceof $Object ? ObjectPrototype : null;
  	};
  	return objectGetPrototypeOf;
  }

  var functionUncurryThisAccessor;
  var hasRequiredFunctionUncurryThisAccessor;

  function requireFunctionUncurryThisAccessor () {
  	if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
  	hasRequiredFunctionUncurryThisAccessor = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();
  	var aCallable = /*@__PURE__*/ requireACallable();

  	functionUncurryThisAccessor = function (object, key, method) {
  	  try {
  	    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  	    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  	  } catch (error) { /* empty */ }
  	};
  	return functionUncurryThisAccessor;
  }

  var isPossiblePrototype;
  var hasRequiredIsPossiblePrototype;

  function requireIsPossiblePrototype () {
  	if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
  	hasRequiredIsPossiblePrototype = 1;
  	var isObject = /*@__PURE__*/ requireIsObject();

  	isPossiblePrototype = function (argument) {
  	  return isObject(argument) || argument === null;
  	};
  	return isPossiblePrototype;
  }

  var aPossiblePrototype;
  var hasRequiredAPossiblePrototype;

  function requireAPossiblePrototype () {
  	if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
  	hasRequiredAPossiblePrototype = 1;
  	var isPossiblePrototype = /*@__PURE__*/ requireIsPossiblePrototype();

  	var $String = String;
  	var $TypeError = TypeError;

  	aPossiblePrototype = function (argument) {
  	  if (isPossiblePrototype(argument)) return argument;
  	  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
  	};
  	return aPossiblePrototype;
  }

  var objectSetPrototypeOf;
  var hasRequiredObjectSetPrototypeOf;

  function requireObjectSetPrototypeOf () {
  	if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
  	hasRequiredObjectSetPrototypeOf = 1;
  	/* eslint-disable no-proto -- safe */
  	var uncurryThisAccessor = /*@__PURE__*/ requireFunctionUncurryThisAccessor();
  	var isObject = /*@__PURE__*/ requireIsObject();
  	var requireObjectCoercible = /*@__PURE__*/ requireRequireObjectCoercible();
  	var aPossiblePrototype = /*@__PURE__*/ requireAPossiblePrototype();

  	// `Object.setPrototypeOf` method
  	// https://tc39.es/ecma262/#sec-object.setprototypeof
  	// Works with __proto__ only. Old v8 can't work with null proto objects.
  	// eslint-disable-next-line es/no-object-setprototypeof -- safe
  	objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  	  var CORRECT_SETTER = false;
  	  var test = {};
  	  var setter;
  	  try {
  	    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
  	    setter(test, []);
  	    CORRECT_SETTER = test instanceof Array;
  	  } catch (error) { /* empty */ }
  	  return function setPrototypeOf(O, proto) {
  	    requireObjectCoercible(O);
  	    aPossiblePrototype(proto);
  	    if (!isObject(O)) return O;
  	    if (CORRECT_SETTER) setter(O, proto);
  	    else O.__proto__ = proto;
  	    return O;
  	  };
  	}() : undefined);
  	return objectSetPrototypeOf;
  }

  var objectGetOwnPropertyNames = {};

  var mathTrunc;
  var hasRequiredMathTrunc;

  function requireMathTrunc () {
  	if (hasRequiredMathTrunc) return mathTrunc;
  	hasRequiredMathTrunc = 1;
  	var ceil = Math.ceil;
  	var floor = Math.floor;

  	// `Math.trunc` method
  	// https://tc39.es/ecma262/#sec-math.trunc
  	// eslint-disable-next-line es/no-math-trunc -- safe
  	mathTrunc = Math.trunc || function trunc(x) {
  	  var n = +x;
  	  return (n > 0 ? floor : ceil)(n);
  	};
  	return mathTrunc;
  }

  var toIntegerOrInfinity;
  var hasRequiredToIntegerOrInfinity;

  function requireToIntegerOrInfinity () {
  	if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
  	hasRequiredToIntegerOrInfinity = 1;
  	var trunc = /*@__PURE__*/ requireMathTrunc();

  	// `ToIntegerOrInfinity` abstract operation
  	// https://tc39.es/ecma262/#sec-tointegerorinfinity
  	toIntegerOrInfinity = function (argument) {
  	  var number = +argument;
  	  // eslint-disable-next-line no-self-compare -- NaN check
  	  return number !== number || number === 0 ? 0 : trunc(number);
  	};
  	return toIntegerOrInfinity;
  }

  var toAbsoluteIndex;
  var hasRequiredToAbsoluteIndex;

  function requireToAbsoluteIndex () {
  	if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
  	hasRequiredToAbsoluteIndex = 1;
  	var toIntegerOrInfinity = /*@__PURE__*/ requireToIntegerOrInfinity();

  	var max = Math.max;
  	var min = Math.min;

  	// Helper for a popular repeating case of the spec:
  	// Let integer be ? ToInteger(index).
  	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  	toAbsoluteIndex = function (index, length) {
  	  var integer = toIntegerOrInfinity(index);
  	  return integer < 0 ? max(integer + length, 0) : min(integer, length);
  	};
  	return toAbsoluteIndex;
  }

  var toLength;
  var hasRequiredToLength;

  function requireToLength () {
  	if (hasRequiredToLength) return toLength;
  	hasRequiredToLength = 1;
  	var toIntegerOrInfinity = /*@__PURE__*/ requireToIntegerOrInfinity();

  	var min = Math.min;

  	// `ToLength` abstract operation
  	// https://tc39.es/ecma262/#sec-tolength
  	toLength = function (argument) {
  	  var len = toIntegerOrInfinity(argument);
  	  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  	};
  	return toLength;
  }

  var lengthOfArrayLike;
  var hasRequiredLengthOfArrayLike;

  function requireLengthOfArrayLike () {
  	if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
  	hasRequiredLengthOfArrayLike = 1;
  	var toLength = /*@__PURE__*/ requireToLength();

  	// `LengthOfArrayLike` abstract operation
  	// https://tc39.es/ecma262/#sec-lengthofarraylike
  	lengthOfArrayLike = function (obj) {
  	  return toLength(obj.length);
  	};
  	return lengthOfArrayLike;
  }

  var arrayIncludes;
  var hasRequiredArrayIncludes;

  function requireArrayIncludes () {
  	if (hasRequiredArrayIncludes) return arrayIncludes;
  	hasRequiredArrayIncludes = 1;
  	var toIndexedObject = /*@__PURE__*/ requireToIndexedObject();
  	var toAbsoluteIndex = /*@__PURE__*/ requireToAbsoluteIndex();
  	var lengthOfArrayLike = /*@__PURE__*/ requireLengthOfArrayLike();

  	// `Array.prototype.{ indexOf, includes }` methods implementation
  	var createMethod = function (IS_INCLUDES) {
  	  return function ($this, el, fromIndex) {
  	    var O = toIndexedObject($this);
  	    var length = lengthOfArrayLike(O);
  	    if (length === 0) return !IS_INCLUDES && -1;
  	    var index = toAbsoluteIndex(fromIndex, length);
  	    var value;
  	    // Array#includes uses SameValueZero equality algorithm
  	    // eslint-disable-next-line no-self-compare -- NaN check
  	    if (IS_INCLUDES && el !== el) while (length > index) {
  	      value = O[index++];
  	      // eslint-disable-next-line no-self-compare -- NaN check
  	      if (value !== value) return true;
  	    // Array#indexOf ignores holes, Array#includes - not
  	    } else for (;length > index; index++) {
  	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
  	    } return !IS_INCLUDES && -1;
  	  };
  	};

  	arrayIncludes = {
  	  // `Array.prototype.includes` method
  	  // https://tc39.es/ecma262/#sec-array.prototype.includes
  	  includes: createMethod(true),
  	  // `Array.prototype.indexOf` method
  	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  	  indexOf: createMethod(false)
  	};
  	return arrayIncludes;
  }

  var hiddenKeys;
  var hasRequiredHiddenKeys;

  function requireHiddenKeys () {
  	if (hasRequiredHiddenKeys) return hiddenKeys;
  	hasRequiredHiddenKeys = 1;
  	hiddenKeys = {};
  	return hiddenKeys;
  }

  var objectKeysInternal;
  var hasRequiredObjectKeysInternal;

  function requireObjectKeysInternal () {
  	if (hasRequiredObjectKeysInternal) return objectKeysInternal;
  	hasRequiredObjectKeysInternal = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var toIndexedObject = /*@__PURE__*/ requireToIndexedObject();
  	var indexOf = /*@__PURE__*/ requireArrayIncludes().indexOf;
  	var hiddenKeys = /*@__PURE__*/ requireHiddenKeys();

  	var push = uncurryThis([].push);

  	objectKeysInternal = function (object, names) {
  	  var O = toIndexedObject(object);
  	  var i = 0;
  	  var result = [];
  	  var key;
  	  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  	  // Don't enum bug & hidden keys
  	  while (names.length > i) if (hasOwn(O, key = names[i++])) {
  	    ~indexOf(result, key) || push(result, key);
  	  }
  	  return result;
  	};
  	return objectKeysInternal;
  }

  var enumBugKeys;
  var hasRequiredEnumBugKeys;

  function requireEnumBugKeys () {
  	if (hasRequiredEnumBugKeys) return enumBugKeys;
  	hasRequiredEnumBugKeys = 1;
  	// IE8- don't enum bug keys
  	enumBugKeys = [
  	  'constructor',
  	  'hasOwnProperty',
  	  'isPrototypeOf',
  	  'propertyIsEnumerable',
  	  'toLocaleString',
  	  'toString',
  	  'valueOf'
  	];
  	return enumBugKeys;
  }

  var hasRequiredObjectGetOwnPropertyNames;

  function requireObjectGetOwnPropertyNames () {
  	if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
  	hasRequiredObjectGetOwnPropertyNames = 1;
  	var internalObjectKeys = /*@__PURE__*/ requireObjectKeysInternal();
  	var enumBugKeys = /*@__PURE__*/ requireEnumBugKeys();

  	var hiddenKeys = enumBugKeys.concat('length', 'prototype');

  	// `Object.getOwnPropertyNames` method
  	// https://tc39.es/ecma262/#sec-object.getownpropertynames
  	// eslint-disable-next-line es/no-object-getownpropertynames -- safe
  	objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  	  return internalObjectKeys(O, hiddenKeys);
  	};
  	return objectGetOwnPropertyNames;
  }

  var objectGetOwnPropertySymbols = {};

  var hasRequiredObjectGetOwnPropertySymbols;

  function requireObjectGetOwnPropertySymbols () {
  	if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
  	hasRequiredObjectGetOwnPropertySymbols = 1;
  	// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
  	objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  	return objectGetOwnPropertySymbols;
  }

  var ownKeys;
  var hasRequiredOwnKeys;

  function requireOwnKeys () {
  	if (hasRequiredOwnKeys) return ownKeys;
  	hasRequiredOwnKeys = 1;
  	var getBuiltIn = /*@__PURE__*/ requireGetBuiltIn();
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();
  	var getOwnPropertyNamesModule = /*@__PURE__*/ requireObjectGetOwnPropertyNames();
  	var getOwnPropertySymbolsModule = /*@__PURE__*/ requireObjectGetOwnPropertySymbols();
  	var anObject = /*@__PURE__*/ requireAnObject();

  	var concat = uncurryThis([].concat);

  	// all object keys, includes non-enumerable and symbols
  	ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  	  var keys = getOwnPropertyNamesModule.f(anObject(it));
  	  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  	  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
  	};
  	return ownKeys;
  }

  var copyConstructorProperties;
  var hasRequiredCopyConstructorProperties;

  function requireCopyConstructorProperties () {
  	if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
  	hasRequiredCopyConstructorProperties = 1;
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var ownKeys = /*@__PURE__*/ requireOwnKeys();
  	var getOwnPropertyDescriptorModule = /*@__PURE__*/ requireObjectGetOwnPropertyDescriptor();
  	var definePropertyModule = /*@__PURE__*/ requireObjectDefineProperty();

  	copyConstructorProperties = function (target, source, exceptions) {
  	  var keys = ownKeys(source);
  	  var defineProperty = definePropertyModule.f;
  	  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  	  for (var i = 0; i < keys.length; i++) {
  	    var key = keys[i];
  	    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
  	      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  	    }
  	  }
  	};
  	return copyConstructorProperties;
  }

  var objectDefineProperties = {};

  var objectKeys;
  var hasRequiredObjectKeys;

  function requireObjectKeys () {
  	if (hasRequiredObjectKeys) return objectKeys;
  	hasRequiredObjectKeys = 1;
  	var internalObjectKeys = /*@__PURE__*/ requireObjectKeysInternal();
  	var enumBugKeys = /*@__PURE__*/ requireEnumBugKeys();

  	// `Object.keys` method
  	// https://tc39.es/ecma262/#sec-object.keys
  	// eslint-disable-next-line es/no-object-keys -- safe
  	objectKeys = Object.keys || function keys(O) {
  	  return internalObjectKeys(O, enumBugKeys);
  	};
  	return objectKeys;
  }

  var hasRequiredObjectDefineProperties;

  function requireObjectDefineProperties () {
  	if (hasRequiredObjectDefineProperties) return objectDefineProperties;
  	hasRequiredObjectDefineProperties = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var V8_PROTOTYPE_DEFINE_BUG = /*@__PURE__*/ requireV8PrototypeDefineBug();
  	var definePropertyModule = /*@__PURE__*/ requireObjectDefineProperty();
  	var anObject = /*@__PURE__*/ requireAnObject();
  	var toIndexedObject = /*@__PURE__*/ requireToIndexedObject();
  	var objectKeys = /*@__PURE__*/ requireObjectKeys();

  	// `Object.defineProperties` method
  	// https://tc39.es/ecma262/#sec-object.defineproperties
  	// eslint-disable-next-line es/no-object-defineproperties -- safe
  	objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  	  anObject(O);
  	  var props = toIndexedObject(Properties);
  	  var keys = objectKeys(Properties);
  	  var length = keys.length;
  	  var index = 0;
  	  var key;
  	  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  	  return O;
  	};
  	return objectDefineProperties;
  }

  var html;
  var hasRequiredHtml;

  function requireHtml () {
  	if (hasRequiredHtml) return html;
  	hasRequiredHtml = 1;
  	var getBuiltIn = /*@__PURE__*/ requireGetBuiltIn();

  	html = getBuiltIn('document', 'documentElement');
  	return html;
  }

  var objectCreate;
  var hasRequiredObjectCreate;

  function requireObjectCreate () {
  	if (hasRequiredObjectCreate) return objectCreate;
  	hasRequiredObjectCreate = 1;
  	/* global ActiveXObject -- old IE, WSH */
  	var anObject = /*@__PURE__*/ requireAnObject();
  	var definePropertiesModule = /*@__PURE__*/ requireObjectDefineProperties();
  	var enumBugKeys = /*@__PURE__*/ requireEnumBugKeys();
  	var hiddenKeys = /*@__PURE__*/ requireHiddenKeys();
  	var html = /*@__PURE__*/ requireHtml();
  	var documentCreateElement = /*@__PURE__*/ requireDocumentCreateElement();
  	var sharedKey = /*@__PURE__*/ requireSharedKey();

  	var GT = '>';
  	var LT = '<';
  	var PROTOTYPE = 'prototype';
  	var SCRIPT = 'script';
  	var IE_PROTO = sharedKey('IE_PROTO');

  	var EmptyConstructor = function () { /* empty */ };

  	var scriptTag = function (content) {
  	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  	};

  	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  	var NullProtoObjectViaActiveX = function (activeXDocument) {
  	  activeXDocument.write(scriptTag(''));
  	  activeXDocument.close();
  	  var temp = activeXDocument.parentWindow.Object;
  	  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  	  activeXDocument = null;
  	  return temp;
  	};

  	// Create object with fake `null` prototype: use iframe Object with cleared prototype
  	var NullProtoObjectViaIFrame = function () {
  	  // Thrash, waste and sodomy: IE GC bug
  	  var iframe = documentCreateElement('iframe');
  	  var JS = 'java' + SCRIPT + ':';
  	  var iframeDocument;
  	  iframe.style.display = 'none';
  	  html.appendChild(iframe);
  	  // https://github.com/zloirock/core-js/issues/475
  	  iframe.src = String(JS);
  	  iframeDocument = iframe.contentWindow.document;
  	  iframeDocument.open();
  	  iframeDocument.write(scriptTag('document.F=Object'));
  	  iframeDocument.close();
  	  return iframeDocument.F;
  	};

  	// Check for document.domain and active x support
  	// No need to use active x approach when document.domain is not set
  	// see https://github.com/es-shims/es5-shim/issues/150
  	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  	// avoid IE GC bug
  	var activeXDocument;
  	var NullProtoObject = function () {
  	  try {
  	    activeXDocument = new ActiveXObject('htmlfile');
  	  } catch (error) { /* ignore */ }
  	  NullProtoObject = typeof document != 'undefined'
  	    ? document.domain && activeXDocument
  	      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
  	      : NullProtoObjectViaIFrame()
  	    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  	  var length = enumBugKeys.length;
  	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  	  return NullProtoObject();
  	};

  	hiddenKeys[IE_PROTO] = true;

  	// `Object.create` method
  	// https://tc39.es/ecma262/#sec-object.create
  	// eslint-disable-next-line es/no-object-create -- safe
  	objectCreate = Object.create || function create(O, Properties) {
  	  var result;
  	  if (O !== null) {
  	    EmptyConstructor[PROTOTYPE] = anObject(O);
  	    result = new EmptyConstructor();
  	    EmptyConstructor[PROTOTYPE] = null;
  	    // add "__proto__" for Object.getPrototypeOf polyfill
  	    result[IE_PROTO] = O;
  	  } else result = NullProtoObject();
  	  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
  	};
  	return objectCreate;
  }

  var installErrorCause;
  var hasRequiredInstallErrorCause;

  function requireInstallErrorCause () {
  	if (hasRequiredInstallErrorCause) return installErrorCause;
  	hasRequiredInstallErrorCause = 1;
  	var isObject = /*@__PURE__*/ requireIsObject();
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();

  	// `InstallErrorCause` abstract operation
  	// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
  	installErrorCause = function (O, options) {
  	  if (isObject(options) && 'cause' in options) {
  	    createNonEnumerableProperty(O, 'cause', options.cause);
  	  }
  	};
  	return installErrorCause;
  }

  var errorStackClear;
  var hasRequiredErrorStackClear;

  function requireErrorStackClear () {
  	if (hasRequiredErrorStackClear) return errorStackClear;
  	hasRequiredErrorStackClear = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();

  	var $Error = Error;
  	var replace = uncurryThis(''.replace);

  	var TEST = (function (arg) { return String(new $Error(arg).stack); })('zxcasd');
  	// eslint-disable-next-line redos/no-vulnerable, sonarjs/slow-regex -- safe
  	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
  	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

  	errorStackClear = function (stack, dropEntries) {
  	  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
  	    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  	  } return stack;
  	};
  	return errorStackClear;
  }

  var errorStackInstallable;
  var hasRequiredErrorStackInstallable;

  function requireErrorStackInstallable () {
  	if (hasRequiredErrorStackInstallable) return errorStackInstallable;
  	hasRequiredErrorStackInstallable = 1;
  	var fails = /*@__PURE__*/ requireFails();
  	var createPropertyDescriptor = /*@__PURE__*/ requireCreatePropertyDescriptor();

  	errorStackInstallable = !fails(function () {
  	  var error = new Error('a');
  	  if (!('stack' in error)) return true;
  	  // eslint-disable-next-line es/no-object-defineproperty -- safe
  	  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  	  return error.stack !== 7;
  	});
  	return errorStackInstallable;
  }

  var errorStackInstall;
  var hasRequiredErrorStackInstall;

  function requireErrorStackInstall () {
  	if (hasRequiredErrorStackInstall) return errorStackInstall;
  	hasRequiredErrorStackInstall = 1;
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var clearErrorStack = /*@__PURE__*/ requireErrorStackClear();
  	var ERROR_STACK_INSTALLABLE = /*@__PURE__*/ requireErrorStackInstallable();

  	// non-standard V8
  	var captureStackTrace = Error.captureStackTrace;

  	errorStackInstall = function (error, C, stack, dropEntries) {
  	  if (ERROR_STACK_INSTALLABLE) {
  	    if (captureStackTrace) captureStackTrace(error, C);
  	    else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
  	  }
  	};
  	return errorStackInstall;
  }

  var iterators;
  var hasRequiredIterators;

  function requireIterators () {
  	if (hasRequiredIterators) return iterators;
  	hasRequiredIterators = 1;
  	iterators = {};
  	return iterators;
  }

  var isArrayIteratorMethod;
  var hasRequiredIsArrayIteratorMethod;

  function requireIsArrayIteratorMethod () {
  	if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
  	hasRequiredIsArrayIteratorMethod = 1;
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();
  	var Iterators = /*@__PURE__*/ requireIterators();

  	var ITERATOR = wellKnownSymbol('iterator');
  	var ArrayPrototype = Array.prototype;

  	// check on default Array iterator
  	isArrayIteratorMethod = function (it) {
  	  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
  	};
  	return isArrayIteratorMethod;
  }

  var toStringTagSupport;
  var hasRequiredToStringTagSupport;

  function requireToStringTagSupport () {
  	if (hasRequiredToStringTagSupport) return toStringTagSupport;
  	hasRequiredToStringTagSupport = 1;
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();

  	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  	var test = {};

  	test[TO_STRING_TAG] = 'z';

  	toStringTagSupport = String(test) === '[object z]';
  	return toStringTagSupport;
  }

  var classof;
  var hasRequiredClassof;

  function requireClassof () {
  	if (hasRequiredClassof) return classof;
  	hasRequiredClassof = 1;
  	var TO_STRING_TAG_SUPPORT = /*@__PURE__*/ requireToStringTagSupport();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var classofRaw = /*@__PURE__*/ requireClassofRaw();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();

  	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  	var $Object = Object;

  	// ES3 wrong here
  	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

  	// fallback for IE11 Script Access Denied error
  	var tryGet = function (it, key) {
  	  try {
  	    return it[key];
  	  } catch (error) { /* empty */ }
  	};

  	// getting tag from ES6+ `Object.prototype.toString`
  	classof = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  	  var O, tag, result;
  	  return it === undefined ? 'Undefined' : it === null ? 'Null'
  	    // @@toStringTag case
  	    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
  	    // builtinTag case
  	    : CORRECT_ARGUMENTS ? classofRaw(O)
  	    // ES3 arguments fallback
  	    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
  	};
  	return classof;
  }

  var getIteratorMethod;
  var hasRequiredGetIteratorMethod;

  function requireGetIteratorMethod () {
  	if (hasRequiredGetIteratorMethod) return getIteratorMethod;
  	hasRequiredGetIteratorMethod = 1;
  	var classof = /*@__PURE__*/ requireClassof();
  	var getMethod = /*@__PURE__*/ requireGetMethod();
  	var isNullOrUndefined = /*@__PURE__*/ requireIsNullOrUndefined();
  	var Iterators = /*@__PURE__*/ requireIterators();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();

  	var ITERATOR = wellKnownSymbol('iterator');

  	getIteratorMethod = function (it) {
  	  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
  	    || getMethod(it, '@@iterator')
  	    || Iterators[classof(it)];
  	};
  	return getIteratorMethod;
  }

  var getIterator;
  var hasRequiredGetIterator;

  function requireGetIterator () {
  	if (hasRequiredGetIterator) return getIterator;
  	hasRequiredGetIterator = 1;
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var aCallable = /*@__PURE__*/ requireACallable();
  	var anObject = /*@__PURE__*/ requireAnObject();
  	var tryToString = /*@__PURE__*/ requireTryToString();
  	var getIteratorMethod = /*@__PURE__*/ requireGetIteratorMethod();

  	var $TypeError = TypeError;

  	getIterator = function (argument, usingIterator) {
  	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  	  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  	  throw new $TypeError(tryToString(argument) + ' is not iterable');
  	};
  	return getIterator;
  }

  var iteratorClose;
  var hasRequiredIteratorClose;

  function requireIteratorClose () {
  	if (hasRequiredIteratorClose) return iteratorClose;
  	hasRequiredIteratorClose = 1;
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var anObject = /*@__PURE__*/ requireAnObject();
  	var getMethod = /*@__PURE__*/ requireGetMethod();

  	iteratorClose = function (iterator, kind, value) {
  	  var innerResult, innerError;
  	  anObject(iterator);
  	  try {
  	    innerResult = getMethod(iterator, 'return');
  	    if (!innerResult) {
  	      if (kind === 'throw') throw value;
  	      return value;
  	    }
  	    innerResult = call(innerResult, iterator);
  	  } catch (error) {
  	    innerError = true;
  	    innerResult = error;
  	  }
  	  if (kind === 'throw') throw value;
  	  if (innerError) throw innerResult;
  	  anObject(innerResult);
  	  return value;
  	};
  	return iteratorClose;
  }

  var iterate;
  var hasRequiredIterate;

  function requireIterate () {
  	if (hasRequiredIterate) return iterate;
  	hasRequiredIterate = 1;
  	var bind = /*@__PURE__*/ requireFunctionBindContext();
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var anObject = /*@__PURE__*/ requireAnObject();
  	var tryToString = /*@__PURE__*/ requireTryToString();
  	var isArrayIteratorMethod = /*@__PURE__*/ requireIsArrayIteratorMethod();
  	var lengthOfArrayLike = /*@__PURE__*/ requireLengthOfArrayLike();
  	var isPrototypeOf = /*@__PURE__*/ requireObjectIsPrototypeOf();
  	var getIterator = /*@__PURE__*/ requireGetIterator();
  	var getIteratorMethod = /*@__PURE__*/ requireGetIteratorMethod();
  	var iteratorClose = /*@__PURE__*/ requireIteratorClose();

  	var $TypeError = TypeError;

  	var Result = function (stopped, result) {
  	  this.stopped = stopped;
  	  this.result = result;
  	};

  	var ResultPrototype = Result.prototype;

  	iterate = function (iterable, unboundFunction, options) {
  	  var that = options && options.that;
  	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  	  var IS_RECORD = !!(options && options.IS_RECORD);
  	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  	  var INTERRUPTED = !!(options && options.INTERRUPTED);
  	  var fn = bind(unboundFunction, that);
  	  var iterator, iterFn, index, length, result, next, step;

  	  var stop = function (condition) {
  	    if (iterator) iteratorClose(iterator, 'normal', condition);
  	    return new Result(true, condition);
  	  };

  	  var callFn = function (value) {
  	    if (AS_ENTRIES) {
  	      anObject(value);
  	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
  	    } return INTERRUPTED ? fn(value, stop) : fn(value);
  	  };

  	  if (IS_RECORD) {
  	    iterator = iterable.iterator;
  	  } else if (IS_ITERATOR) {
  	    iterator = iterable;
  	  } else {
  	    iterFn = getIteratorMethod(iterable);
  	    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
  	    // optimisation for array iterators
  	    if (isArrayIteratorMethod(iterFn)) {
  	      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
  	        result = callFn(iterable[index]);
  	        if (result && isPrototypeOf(ResultPrototype, result)) return result;
  	      } return new Result(false);
  	    }
  	    iterator = getIterator(iterable, iterFn);
  	  }

  	  next = IS_RECORD ? iterable.next : iterator.next;
  	  while (!(step = call(next, iterator)).done) {
  	    try {
  	      result = callFn(step.value);
  	    } catch (error) {
  	      iteratorClose(iterator, 'throw', error);
  	    }
  	    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  	  } return new Result(false);
  	};
  	return iterate;
  }

  var toString;
  var hasRequiredToString;

  function requireToString () {
  	if (hasRequiredToString) return toString;
  	hasRequiredToString = 1;
  	var classof = /*@__PURE__*/ requireClassof();

  	var $String = String;

  	toString = function (argument) {
  	  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  	  return $String(argument);
  	};
  	return toString;
  }

  var normalizeStringArgument;
  var hasRequiredNormalizeStringArgument;

  function requireNormalizeStringArgument () {
  	if (hasRequiredNormalizeStringArgument) return normalizeStringArgument;
  	hasRequiredNormalizeStringArgument = 1;
  	var toString = /*@__PURE__*/ requireToString();

  	normalizeStringArgument = function (argument, $default) {
  	  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
  	};
  	return normalizeStringArgument;
  }

  var hasRequiredEs_aggregateError_constructor;

  function requireEs_aggregateError_constructor () {
  	if (hasRequiredEs_aggregateError_constructor) return es_aggregateError_constructor;
  	hasRequiredEs_aggregateError_constructor = 1;
  	var $ = /*@__PURE__*/ require_export();
  	var isPrototypeOf = /*@__PURE__*/ requireObjectIsPrototypeOf();
  	var getPrototypeOf = /*@__PURE__*/ requireObjectGetPrototypeOf();
  	var setPrototypeOf = /*@__PURE__*/ requireObjectSetPrototypeOf();
  	var copyConstructorProperties = /*@__PURE__*/ requireCopyConstructorProperties();
  	var create = /*@__PURE__*/ requireObjectCreate();
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var createPropertyDescriptor = /*@__PURE__*/ requireCreatePropertyDescriptor();
  	var installErrorCause = /*@__PURE__*/ requireInstallErrorCause();
  	var installErrorStack = /*@__PURE__*/ requireErrorStackInstall();
  	var iterate = /*@__PURE__*/ requireIterate();
  	var normalizeStringArgument = /*@__PURE__*/ requireNormalizeStringArgument();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();

  	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  	var $Error = Error;
  	var push = [].push;

  	var $AggregateError = function AggregateError(errors, message /* , options */) {
  	  var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
  	  var that;
  	  if (setPrototypeOf) {
  	    that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
  	  } else {
  	    that = isInstance ? this : create(AggregateErrorPrototype);
  	    createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
  	  }
  	  if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
  	  installErrorStack(that, $AggregateError, that.stack, 1);
  	  if (arguments.length > 2) installErrorCause(that, arguments[2]);
  	  var errorsArray = [];
  	  iterate(errors, push, { that: errorsArray });
  	  createNonEnumerableProperty(that, 'errors', errorsArray);
  	  return that;
  	};

  	if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
  	else copyConstructorProperties($AggregateError, $Error, { name: true });

  	var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
  	  constructor: createPropertyDescriptor(1, $AggregateError),
  	  message: createPropertyDescriptor(1, ''),
  	  name: createPropertyDescriptor(1, 'AggregateError')
  	});

  	// `AggregateError` constructor
  	// https://tc39.es/ecma262/#sec-aggregate-error-constructor
  	$({ global: true, constructor: true, arity: 2 }, {
  	  AggregateError: $AggregateError
  	});
  	return es_aggregateError_constructor;
  }

  var hasRequiredEs_aggregateError;

  function requireEs_aggregateError () {
  	if (hasRequiredEs_aggregateError) return es_aggregateError;
  	hasRequiredEs_aggregateError = 1;
  	// TODO: Remove this module from `core-js@4` since it's replaced to module below
  	requireEs_aggregateError_constructor();
  	return es_aggregateError;
  }

  var hasRequiredEsnext_aggregateError;

  function requireEsnext_aggregateError () {
  	if (hasRequiredEsnext_aggregateError) return esnext_aggregateError;
  	hasRequiredEsnext_aggregateError = 1;
  	// TODO: Remove from `core-js@4`
  	requireEs_aggregateError();
  	return esnext_aggregateError;
  }

  var es_error_cause = {};

  var proxyAccessor;
  var hasRequiredProxyAccessor;

  function requireProxyAccessor () {
  	if (hasRequiredProxyAccessor) return proxyAccessor;
  	hasRequiredProxyAccessor = 1;
  	var defineProperty = /*@__PURE__*/ requireObjectDefineProperty().f;

  	proxyAccessor = function (Target, Source, key) {
  	  key in Target || defineProperty(Target, key, {
  	    configurable: true,
  	    get: function () { return Source[key]; },
  	    set: function (it) { Source[key] = it; }
  	  });
  	};
  	return proxyAccessor;
  }

  var inheritIfRequired;
  var hasRequiredInheritIfRequired;

  function requireInheritIfRequired () {
  	if (hasRequiredInheritIfRequired) return inheritIfRequired;
  	hasRequiredInheritIfRequired = 1;
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var isObject = /*@__PURE__*/ requireIsObject();
  	var setPrototypeOf = /*@__PURE__*/ requireObjectSetPrototypeOf();

  	// makes subclassing work correct for wrapped built-ins
  	inheritIfRequired = function ($this, dummy, Wrapper) {
  	  var NewTarget, NewTargetPrototype;
  	  if (
  	    // it can work only with native `setPrototypeOf`
  	    setPrototypeOf &&
  	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  	    isCallable(NewTarget = dummy.constructor) &&
  	    NewTarget !== Wrapper &&
  	    isObject(NewTargetPrototype = NewTarget.prototype) &&
  	    NewTargetPrototype !== Wrapper.prototype
  	  ) setPrototypeOf($this, NewTargetPrototype);
  	  return $this;
  	};
  	return inheritIfRequired;
  }

  var wrapErrorConstructorWithCause;
  var hasRequiredWrapErrorConstructorWithCause;

  function requireWrapErrorConstructorWithCause () {
  	if (hasRequiredWrapErrorConstructorWithCause) return wrapErrorConstructorWithCause;
  	hasRequiredWrapErrorConstructorWithCause = 1;
  	var getBuiltIn = /*@__PURE__*/ requireGetBuiltIn();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var isPrototypeOf = /*@__PURE__*/ requireObjectIsPrototypeOf();
  	var setPrototypeOf = /*@__PURE__*/ requireObjectSetPrototypeOf();
  	var copyConstructorProperties = /*@__PURE__*/ requireCopyConstructorProperties();
  	var proxyAccessor = /*@__PURE__*/ requireProxyAccessor();
  	var inheritIfRequired = /*@__PURE__*/ requireInheritIfRequired();
  	var normalizeStringArgument = /*@__PURE__*/ requireNormalizeStringArgument();
  	var installErrorCause = /*@__PURE__*/ requireInstallErrorCause();
  	var installErrorStack = /*@__PURE__*/ requireErrorStackInstall();
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var IS_PURE = /*@__PURE__*/ requireIsPure();

  	wrapErrorConstructorWithCause = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
  	  var STACK_TRACE_LIMIT = 'stackTraceLimit';
  	  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  	  var path = FULL_NAME.split('.');
  	  var ERROR_NAME = path[path.length - 1];
  	  var OriginalError = getBuiltIn.apply(null, path);

  	  if (!OriginalError) return;

  	  var OriginalErrorPrototype = OriginalError.prototype;

  	  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
  	  if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

  	  if (!FORCED) return OriginalError;

  	  var BaseError = getBuiltIn('Error');

  	  var WrappedError = wrapper(function (a, b) {
  	    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
  	    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
  	    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
  	    installErrorStack(result, WrappedError, result.stack, 2);
  	    if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
  	    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
  	    return result;
  	  });

  	  WrappedError.prototype = OriginalErrorPrototype;

  	  if (ERROR_NAME !== 'Error') {
  	    if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
  	    else copyConstructorProperties(WrappedError, BaseError, { name: true });
  	  } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
  	    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
  	    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
  	  }

  	  copyConstructorProperties(WrappedError, OriginalError);

  	  if (!IS_PURE) try {
  	    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
  	    if (OriginalErrorPrototype.name !== ERROR_NAME) {
  	      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
  	    }
  	    OriginalErrorPrototype.constructor = WrappedError;
  	  } catch (error) { /* empty */ }

  	  return WrappedError;
  	};
  	return wrapErrorConstructorWithCause;
  }

  var hasRequiredEs_error_cause;

  function requireEs_error_cause () {
  	if (hasRequiredEs_error_cause) return es_error_cause;
  	hasRequiredEs_error_cause = 1;
  	/* eslint-disable no-unused-vars -- required for functions `.length` */
  	var $ = /*@__PURE__*/ require_export();
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var apply = /*@__PURE__*/ requireFunctionApply();
  	var wrapErrorConstructorWithCause = /*@__PURE__*/ requireWrapErrorConstructorWithCause();

  	var WEB_ASSEMBLY = 'WebAssembly';
  	var WebAssembly = globalThis[WEB_ASSEMBLY];

  	// eslint-disable-next-line es/no-error-cause -- feature detection
  	var FORCED = new Error('e', { cause: 7 }).cause !== 7;

  	var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  	  var O = {};
  	  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
  	  $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
  	};

  	var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  	  if (WebAssembly && WebAssembly[ERROR_NAME]) {
  	    var O = {};
  	    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
  	    $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
  	  }
  	};

  	// https://tc39.es/ecma262/#sec-nativeerror
  	exportGlobalErrorCauseWrapper('Error', function (init) {
  	  return function Error(message) { return apply(init, this, arguments); };
  	});
  	exportGlobalErrorCauseWrapper('EvalError', function (init) {
  	  return function EvalError(message) { return apply(init, this, arguments); };
  	});
  	exportGlobalErrorCauseWrapper('RangeError', function (init) {
  	  return function RangeError(message) { return apply(init, this, arguments); };
  	});
  	exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
  	  return function ReferenceError(message) { return apply(init, this, arguments); };
  	});
  	exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
  	  return function SyntaxError(message) { return apply(init, this, arguments); };
  	});
  	exportGlobalErrorCauseWrapper('TypeError', function (init) {
  	  return function TypeError(message) { return apply(init, this, arguments); };
  	});
  	exportGlobalErrorCauseWrapper('URIError', function (init) {
  	  return function URIError(message) { return apply(init, this, arguments); };
  	});
  	exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
  	  return function CompileError(message) { return apply(init, this, arguments); };
  	});
  	exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
  	  return function LinkError(message) { return apply(init, this, arguments); };
  	});
  	exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
  	  return function RuntimeError(message) { return apply(init, this, arguments); };
  	});
  	return es_error_cause;
  }

  var es_aggregateError_cause = {};

  var hasRequiredEs_aggregateError_cause;

  function requireEs_aggregateError_cause () {
  	if (hasRequiredEs_aggregateError_cause) return es_aggregateError_cause;
  	hasRequiredEs_aggregateError_cause = 1;
  	var $ = /*@__PURE__*/ require_export();
  	var getBuiltIn = /*@__PURE__*/ requireGetBuiltIn();
  	var apply = /*@__PURE__*/ requireFunctionApply();
  	var fails = /*@__PURE__*/ requireFails();
  	var wrapErrorConstructorWithCause = /*@__PURE__*/ requireWrapErrorConstructorWithCause();

  	var AGGREGATE_ERROR = 'AggregateError';
  	var $AggregateError = getBuiltIn(AGGREGATE_ERROR);

  	var FORCED = !fails(function () {
  	  return $AggregateError([1]).errors[0] !== 1;
  	}) && fails(function () {
  	  return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
  	});

  	// https://tc39.es/ecma262/#sec-aggregate-error
  	$({ global: true, constructor: true, arity: 2, forced: FORCED }, {
  	  AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function (init) {
  	    // eslint-disable-next-line no-unused-vars -- required for functions `.length`
  	    return function AggregateError(errors, message) { return apply(init, this, arguments); };
  	  }, FORCED, true)
  	});
  	return es_aggregateError_cause;
  }

  var addToUnscopables;
  var hasRequiredAddToUnscopables;

  function requireAddToUnscopables () {
  	if (hasRequiredAddToUnscopables) return addToUnscopables;
  	hasRequiredAddToUnscopables = 1;
  	addToUnscopables = function () { /* empty */ };
  	return addToUnscopables;
  }

  var weakMapBasicDetection;
  var hasRequiredWeakMapBasicDetection;

  function requireWeakMapBasicDetection () {
  	if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
  	hasRequiredWeakMapBasicDetection = 1;
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var isCallable = /*@__PURE__*/ requireIsCallable();

  	var WeakMap = globalThis.WeakMap;

  	weakMapBasicDetection = isCallable(WeakMap) && /native code/.test(String(WeakMap));
  	return weakMapBasicDetection;
  }

  var internalState;
  var hasRequiredInternalState;

  function requireInternalState () {
  	if (hasRequiredInternalState) return internalState;
  	hasRequiredInternalState = 1;
  	var NATIVE_WEAK_MAP = /*@__PURE__*/ requireWeakMapBasicDetection();
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var isObject = /*@__PURE__*/ requireIsObject();
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var shared = /*@__PURE__*/ requireSharedStore();
  	var sharedKey = /*@__PURE__*/ requireSharedKey();
  	var hiddenKeys = /*@__PURE__*/ requireHiddenKeys();

  	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  	var TypeError = globalThis.TypeError;
  	var WeakMap = globalThis.WeakMap;
  	var set, get, has;

  	var enforce = function (it) {
  	  return has(it) ? get(it) : set(it, {});
  	};

  	var getterFor = function (TYPE) {
  	  return function (it) {
  	    var state;
  	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
  	      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
  	    } return state;
  	  };
  	};

  	if (NATIVE_WEAK_MAP || shared.state) {
  	  var store = shared.state || (shared.state = new WeakMap());
  	  /* eslint-disable no-self-assign -- prototype methods protection */
  	  store.get = store.get;
  	  store.has = store.has;
  	  store.set = store.set;
  	  /* eslint-enable no-self-assign -- prototype methods protection */
  	  set = function (it, metadata) {
  	    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
  	    metadata.facade = it;
  	    store.set(it, metadata);
  	    return metadata;
  	  };
  	  get = function (it) {
  	    return store.get(it) || {};
  	  };
  	  has = function (it) {
  	    return store.has(it);
  	  };
  	} else {
  	  var STATE = sharedKey('state');
  	  hiddenKeys[STATE] = true;
  	  set = function (it, metadata) {
  	    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
  	    metadata.facade = it;
  	    createNonEnumerableProperty(it, STATE, metadata);
  	    return metadata;
  	  };
  	  get = function (it) {
  	    return hasOwn(it, STATE) ? it[STATE] : {};
  	  };
  	  has = function (it) {
  	    return hasOwn(it, STATE);
  	  };
  	}

  	internalState = {
  	  set: set,
  	  get: get,
  	  has: has,
  	  enforce: enforce,
  	  getterFor: getterFor
  	};
  	return internalState;
  }

  var functionName;
  var hasRequiredFunctionName;

  function requireFunctionName () {
  	if (hasRequiredFunctionName) return functionName;
  	hasRequiredFunctionName = 1;
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();

  	var FunctionPrototype = Function.prototype;
  	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  	var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

  	var EXISTS = hasOwn(FunctionPrototype, 'name');
  	// additional protection from minified / mangled / dropped function names
  	var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
  	var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

  	functionName = {
  	  EXISTS: EXISTS,
  	  PROPER: PROPER,
  	  CONFIGURABLE: CONFIGURABLE
  	};
  	return functionName;
  }

  var defineBuiltIn;
  var hasRequiredDefineBuiltIn;

  function requireDefineBuiltIn () {
  	if (hasRequiredDefineBuiltIn) return defineBuiltIn;
  	hasRequiredDefineBuiltIn = 1;
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();

  	defineBuiltIn = function (target, key, value, options) {
  	  if (options && options.enumerable) target[key] = value;
  	  else createNonEnumerableProperty(target, key, value);
  	  return target;
  	};
  	return defineBuiltIn;
  }

  var iteratorsCore;
  var hasRequiredIteratorsCore;

  function requireIteratorsCore () {
  	if (hasRequiredIteratorsCore) return iteratorsCore;
  	hasRequiredIteratorsCore = 1;
  	var fails = /*@__PURE__*/ requireFails();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var isObject = /*@__PURE__*/ requireIsObject();
  	var create = /*@__PURE__*/ requireObjectCreate();
  	var getPrototypeOf = /*@__PURE__*/ requireObjectGetPrototypeOf();
  	var defineBuiltIn = /*@__PURE__*/ requireDefineBuiltIn();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();
  	var IS_PURE = /*@__PURE__*/ requireIsPure();

  	var ITERATOR = wellKnownSymbol('iterator');
  	var BUGGY_SAFARI_ITERATORS = false;

  	// `%IteratorPrototype%` object
  	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
  	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

  	/* eslint-disable es/no-array-prototype-keys -- safe */
  	if ([].keys) {
  	  arrayIterator = [].keys();
  	  // Safari 8 has buggy iterators w/o `next`
  	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  	  else {
  	    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
  	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  	  }
  	}

  	var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  	  var test = {};
  	  // FF44- legacy iterators case
  	  return IteratorPrototype[ITERATOR].call(test) !== test;
  	});

  	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
  	else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

  	// `%IteratorPrototype%[@@iterator]()` method
  	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
  	if (!isCallable(IteratorPrototype[ITERATOR])) {
  	  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
  	    return this;
  	  });
  	}

  	iteratorsCore = {
  	  IteratorPrototype: IteratorPrototype,
  	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
  	};
  	return iteratorsCore;
  }

  var objectToString;
  var hasRequiredObjectToString;

  function requireObjectToString () {
  	if (hasRequiredObjectToString) return objectToString;
  	hasRequiredObjectToString = 1;
  	var TO_STRING_TAG_SUPPORT = /*@__PURE__*/ requireToStringTagSupport();
  	var classof = /*@__PURE__*/ requireClassof();

  	// `Object.prototype.toString` method implementation
  	// https://tc39.es/ecma262/#sec-object.prototype.tostring
  	objectToString = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  	  return '[object ' + classof(this) + ']';
  	};
  	return objectToString;
  }

  var setToStringTag;
  var hasRequiredSetToStringTag;

  function requireSetToStringTag () {
  	if (hasRequiredSetToStringTag) return setToStringTag;
  	hasRequiredSetToStringTag = 1;
  	var TO_STRING_TAG_SUPPORT = /*@__PURE__*/ requireToStringTagSupport();
  	var defineProperty = /*@__PURE__*/ requireObjectDefineProperty().f;
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var hasOwn = /*@__PURE__*/ requireHasOwnProperty();
  	var toString = /*@__PURE__*/ requireObjectToString();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();

  	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

  	setToStringTag = function (it, TAG, STATIC, SET_METHOD) {
  	  var target = STATIC ? it : it && it.prototype;
  	  if (target) {
  	    if (!hasOwn(target, TO_STRING_TAG)) {
  	      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  	    }
  	    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
  	      createNonEnumerableProperty(target, 'toString', toString);
  	    }
  	  }
  	};
  	return setToStringTag;
  }

  var iteratorCreateConstructor;
  var hasRequiredIteratorCreateConstructor;

  function requireIteratorCreateConstructor () {
  	if (hasRequiredIteratorCreateConstructor) return iteratorCreateConstructor;
  	hasRequiredIteratorCreateConstructor = 1;
  	var IteratorPrototype = /*@__PURE__*/ requireIteratorsCore().IteratorPrototype;
  	var create = /*@__PURE__*/ requireObjectCreate();
  	var createPropertyDescriptor = /*@__PURE__*/ requireCreatePropertyDescriptor();
  	var setToStringTag = /*@__PURE__*/ requireSetToStringTag();
  	var Iterators = /*@__PURE__*/ requireIterators();

  	var returnThis = function () { return this; };

  	iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  	  var TO_STRING_TAG = NAME + ' Iterator';
  	  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  	  Iterators[TO_STRING_TAG] = returnThis;
  	  return IteratorConstructor;
  	};
  	return iteratorCreateConstructor;
  }

  var iteratorDefine;
  var hasRequiredIteratorDefine;

  function requireIteratorDefine () {
  	if (hasRequiredIteratorDefine) return iteratorDefine;
  	hasRequiredIteratorDefine = 1;
  	var $ = /*@__PURE__*/ require_export();
  	var call = /*@__PURE__*/ requireFunctionCall();
  	var IS_PURE = /*@__PURE__*/ requireIsPure();
  	var FunctionName = /*@__PURE__*/ requireFunctionName();
  	var isCallable = /*@__PURE__*/ requireIsCallable();
  	var createIteratorConstructor = /*@__PURE__*/ requireIteratorCreateConstructor();
  	var getPrototypeOf = /*@__PURE__*/ requireObjectGetPrototypeOf();
  	var setPrototypeOf = /*@__PURE__*/ requireObjectSetPrototypeOf();
  	var setToStringTag = /*@__PURE__*/ requireSetToStringTag();
  	var createNonEnumerableProperty = /*@__PURE__*/ requireCreateNonEnumerableProperty();
  	var defineBuiltIn = /*@__PURE__*/ requireDefineBuiltIn();
  	var wellKnownSymbol = /*@__PURE__*/ requireWellKnownSymbol();
  	var Iterators = /*@__PURE__*/ requireIterators();
  	var IteratorsCore = /*@__PURE__*/ requireIteratorsCore();

  	var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  	var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  	var IteratorPrototype = IteratorsCore.IteratorPrototype;
  	var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  	var ITERATOR = wellKnownSymbol('iterator');
  	var KEYS = 'keys';
  	var VALUES = 'values';
  	var ENTRIES = 'entries';

  	var returnThis = function () { return this; };

  	iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  	  createIteratorConstructor(IteratorConstructor, NAME, next);

  	  var getIterationMethod = function (KIND) {
  	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
  	    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

  	    switch (KIND) {
  	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
  	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
  	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
  	    }

  	    return function () { return new IteratorConstructor(this); };
  	  };

  	  var TO_STRING_TAG = NAME + ' Iterator';
  	  var INCORRECT_VALUES_NAME = false;
  	  var IterablePrototype = Iterable.prototype;
  	  var nativeIterator = IterablePrototype[ITERATOR]
  	    || IterablePrototype['@@iterator']
  	    || DEFAULT && IterablePrototype[DEFAULT];
  	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  	  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  	  var CurrentIteratorPrototype, methods, KEY;

  	  // fix native
  	  if (anyNativeIterator) {
  	    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
  	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
  	      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
  	        if (setPrototypeOf) {
  	          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
  	        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
  	          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
  	        }
  	      }
  	      // Set @@toStringTag to native iterators
  	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
  	      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
  	    }
  	  }

  	  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  	  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
  	    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
  	      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
  	    } else {
  	      INCORRECT_VALUES_NAME = true;
  	      defaultIterator = function values() { return call(nativeIterator, this); };
  	    }
  	  }

  	  // export additional methods
  	  if (DEFAULT) {
  	    methods = {
  	      values: getIterationMethod(VALUES),
  	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
  	      entries: getIterationMethod(ENTRIES)
  	    };
  	    if (FORCED) for (KEY in methods) {
  	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
  	        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
  	      }
  	    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  	  }

  	  // define iterator
  	  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
  	    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  	  }
  	  Iterators[NAME] = defaultIterator;

  	  return methods;
  	};
  	return iteratorDefine;
  }

  var createIterResultObject;
  var hasRequiredCreateIterResultObject;

  function requireCreateIterResultObject () {
  	if (hasRequiredCreateIterResultObject) return createIterResultObject;
  	hasRequiredCreateIterResultObject = 1;
  	// `CreateIterResultObject` abstract operation
  	// https://tc39.es/ecma262/#sec-createiterresultobject
  	createIterResultObject = function (value, done) {
  	  return { value: value, done: done };
  	};
  	return createIterResultObject;
  }

  var es_array_iterator;
  var hasRequiredEs_array_iterator;

  function requireEs_array_iterator () {
  	if (hasRequiredEs_array_iterator) return es_array_iterator;
  	hasRequiredEs_array_iterator = 1;
  	var toIndexedObject = /*@__PURE__*/ requireToIndexedObject();
  	var addToUnscopables = /*@__PURE__*/ requireAddToUnscopables();
  	var Iterators = /*@__PURE__*/ requireIterators();
  	var InternalStateModule = /*@__PURE__*/ requireInternalState();
  	var defineProperty = /*@__PURE__*/ requireObjectDefineProperty().f;
  	var defineIterator = /*@__PURE__*/ requireIteratorDefine();
  	var createIterResultObject = /*@__PURE__*/ requireCreateIterResultObject();
  	var IS_PURE = /*@__PURE__*/ requireIsPure();
  	var DESCRIPTORS = /*@__PURE__*/ requireDescriptors();

  	var ARRAY_ITERATOR = 'Array Iterator';
  	var setInternalState = InternalStateModule.set;
  	var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

  	// `Array.prototype.entries` method
  	// https://tc39.es/ecma262/#sec-array.prototype.entries
  	// `Array.prototype.keys` method
  	// https://tc39.es/ecma262/#sec-array.prototype.keys
  	// `Array.prototype.values` method
  	// https://tc39.es/ecma262/#sec-array.prototype.values
  	// `Array.prototype[@@iterator]` method
  	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  	// `CreateArrayIterator` internal method
  	// https://tc39.es/ecma262/#sec-createarrayiterator
  	es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  	  setInternalState(this, {
  	    type: ARRAY_ITERATOR,
  	    target: toIndexedObject(iterated), // target
  	    index: 0,                          // next index
  	    kind: kind                         // kind
  	  });
  	// `%ArrayIteratorPrototype%.next` method
  	// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  	}, function () {
  	  var state = getInternalState(this);
  	  var target = state.target;
  	  var index = state.index++;
  	  if (!target || index >= target.length) {
  	    state.target = null;
  	    return createIterResultObject(undefined, true);
  	  }
  	  switch (state.kind) {
  	    case 'keys': return createIterResultObject(index, false);
  	    case 'values': return createIterResultObject(target[index], false);
  	  } return createIterResultObject([index, target[index]], false);
  	}, 'values');

  	// argumentsList[@@iterator] is %ArrayProto_values%
  	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
  	var values = Iterators.Arguments = Iterators.Array;

  	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  	addToUnscopables('keys');
  	addToUnscopables('values');
  	addToUnscopables('entries');

  	// V8 ~ Chrome 45- bug
  	if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  	  defineProperty(values, 'name', { value: 'values' });
  	} catch (error) { /* empty */ }
  	return es_array_iterator;
  }

  var es_string_iterator = {};

  var stringMultibyte;
  var hasRequiredStringMultibyte;

  function requireStringMultibyte () {
  	if (hasRequiredStringMultibyte) return stringMultibyte;
  	hasRequiredStringMultibyte = 1;
  	var uncurryThis = /*@__PURE__*/ requireFunctionUncurryThis();
  	var toIntegerOrInfinity = /*@__PURE__*/ requireToIntegerOrInfinity();
  	var toString = /*@__PURE__*/ requireToString();
  	var requireObjectCoercible = /*@__PURE__*/ requireRequireObjectCoercible();

  	var charAt = uncurryThis(''.charAt);
  	var charCodeAt = uncurryThis(''.charCodeAt);
  	var stringSlice = uncurryThis(''.slice);

  	var createMethod = function (CONVERT_TO_STRING) {
  	  return function ($this, pos) {
  	    var S = toString(requireObjectCoercible($this));
  	    var position = toIntegerOrInfinity(pos);
  	    var size = S.length;
  	    var first, second;
  	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
  	    first = charCodeAt(S, position);
  	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
  	      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
  	        ? CONVERT_TO_STRING
  	          ? charAt(S, position)
  	          : first
  	        : CONVERT_TO_STRING
  	          ? stringSlice(S, position, position + 2)
  	          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  	  };
  	};

  	stringMultibyte = {
  	  // `String.prototype.codePointAt` method
  	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  	  codeAt: createMethod(false),
  	  // `String.prototype.at` method
  	  // https://github.com/mathiasbynens/String.prototype.at
  	  charAt: createMethod(true)
  	};
  	return stringMultibyte;
  }

  var hasRequiredEs_string_iterator;

  function requireEs_string_iterator () {
  	if (hasRequiredEs_string_iterator) return es_string_iterator;
  	hasRequiredEs_string_iterator = 1;
  	var charAt = /*@__PURE__*/ requireStringMultibyte().charAt;
  	var toString = /*@__PURE__*/ requireToString();
  	var InternalStateModule = /*@__PURE__*/ requireInternalState();
  	var defineIterator = /*@__PURE__*/ requireIteratorDefine();
  	var createIterResultObject = /*@__PURE__*/ requireCreateIterResultObject();

  	var STRING_ITERATOR = 'String Iterator';
  	var setInternalState = InternalStateModule.set;
  	var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

  	// `String.prototype[@@iterator]` method
  	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
  	defineIterator(String, 'String', function (iterated) {
  	  setInternalState(this, {
  	    type: STRING_ITERATOR,
  	    string: toString(iterated),
  	    index: 0
  	  });
  	// `%StringIteratorPrototype%.next` method
  	// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  	}, function next() {
  	  var state = getInternalState(this);
  	  var string = state.string;
  	  var index = state.index;
  	  var point;
  	  if (index >= string.length) return createIterResultObject(undefined, true);
  	  point = charAt(string, index);
  	  state.index += point.length;
  	  return createIterResultObject(point, false);
  	});
  	return es_string_iterator;
  }

  var aggregateError$5;
  var hasRequiredAggregateError$5;

  function requireAggregateError$5 () {
  	if (hasRequiredAggregateError$5) return aggregateError$5;
  	hasRequiredAggregateError$5 = 1;
  	requireEs_error_cause();
  	requireEs_aggregateError();
  	requireEs_aggregateError_cause();
  	requireEs_array_iterator();
  	requireEs_string_iterator();
  	var path = /*@__PURE__*/ requirePath();

  	aggregateError$5 = path.AggregateError;
  	return aggregateError$5;
  }

  var web_domCollections_iterator = {};

  var domIterables;
  var hasRequiredDomIterables;

  function requireDomIterables () {
  	if (hasRequiredDomIterables) return domIterables;
  	hasRequiredDomIterables = 1;
  	// iterable DOM collections
  	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  	domIterables = {
  	  CSSRuleList: 0,
  	  CSSStyleDeclaration: 0,
  	  CSSValueList: 0,
  	  ClientRectList: 0,
  	  DOMRectList: 0,
  	  DOMStringList: 0,
  	  DOMTokenList: 1,
  	  DataTransferItemList: 0,
  	  FileList: 0,
  	  HTMLAllCollection: 0,
  	  HTMLCollection: 0,
  	  HTMLFormElement: 0,
  	  HTMLSelectElement: 0,
  	  MediaList: 0,
  	  MimeTypeArray: 0,
  	  NamedNodeMap: 0,
  	  NodeList: 1,
  	  PaintRequestList: 0,
  	  Plugin: 0,
  	  PluginArray: 0,
  	  SVGLengthList: 0,
  	  SVGNumberList: 0,
  	  SVGPathSegList: 0,
  	  SVGPointList: 0,
  	  SVGStringList: 0,
  	  SVGTransformList: 0,
  	  SourceBufferList: 0,
  	  StyleSheetList: 0,
  	  TextTrackCueList: 0,
  	  TextTrackList: 0,
  	  TouchList: 0
  	};
  	return domIterables;
  }

  var hasRequiredWeb_domCollections_iterator;

  function requireWeb_domCollections_iterator () {
  	if (hasRequiredWeb_domCollections_iterator) return web_domCollections_iterator;
  	hasRequiredWeb_domCollections_iterator = 1;
  	requireEs_array_iterator();
  	var DOMIterables = /*@__PURE__*/ requireDomIterables();
  	var globalThis = /*@__PURE__*/ requireGlobalThis();
  	var setToStringTag = /*@__PURE__*/ requireSetToStringTag();
  	var Iterators = /*@__PURE__*/ requireIterators();

  	for (var COLLECTION_NAME in DOMIterables) {
  	  setToStringTag(globalThis[COLLECTION_NAME], COLLECTION_NAME);
  	  Iterators[COLLECTION_NAME] = Iterators.Array;
  	}
  	return web_domCollections_iterator;
  }

  var aggregateError$4;
  var hasRequiredAggregateError$4;

  function requireAggregateError$4 () {
  	if (hasRequiredAggregateError$4) return aggregateError$4;
  	hasRequiredAggregateError$4 = 1;
  	// TODO: remove from `core-js@4`
  	requireEsnext_aggregateError();

  	var parent = /*@__PURE__*/ requireAggregateError$5();
  	requireWeb_domCollections_iterator();

  	aggregateError$4 = parent;
  	return aggregateError$4;
  }

  var aggregateError$3;
  var hasRequiredAggregateError$3;

  function requireAggregateError$3 () {
  	if (hasRequiredAggregateError$3) return aggregateError$3;
  	hasRequiredAggregateError$3 = 1;
  	var parent = /*@__PURE__*/ requireAggregateError$4();

  	aggregateError$3 = parent;
  	return aggregateError$3;
  }

  var aggregateError$2;
  var hasRequiredAggregateError$2;

  function requireAggregateError$2 () {
  	if (hasRequiredAggregateError$2) return aggregateError$2;
  	hasRequiredAggregateError$2 = 1;
  	// TODO: remove from `core-js@4`
  	requireEsnext_aggregateError();

  	var parent = /*@__PURE__*/ requireAggregateError$3();

  	aggregateError$2 = parent;
  	return aggregateError$2;
  }

  var aggregateError$1;
  var hasRequiredAggregateError$1;

  function requireAggregateError$1 () {
  	if (hasRequiredAggregateError$1) return aggregateError$1;
  	hasRequiredAggregateError$1 = 1;
  	aggregateError$1 = /*@__PURE__*/ requireAggregateError$2();
  	return aggregateError$1;
  }

  var aggregateError;
  var hasRequiredAggregateError;

  function requireAggregateError () {
  	if (hasRequiredAggregateError) return aggregateError;
  	hasRequiredAggregateError = 1;
  	aggregateError = /*@__PURE__*/ requireAggregateError$1();
  	return aggregateError;
  }

  var aggregateErrorExports = requireAggregateError();
  const _AggregateError = /*@__PURE__*/getDefaultExportFromCjs(aggregateErrorExports);

  /**
   * @public
   */
  class ApiDOMAggregateError extends _AggregateError {
    constructor(errors, message, options) {
      super(errors, message, options);
      this.name = this.constructor.name;
      if (typeof message === 'string') {
        this.message = message;
      }
      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }

      /**
       * This needs to stay here until our minimum supported version of Node.js is >= 16.9.0.
       * Node.js >= 16.9.0 supports error causes natively.
       */
      if (options != null && typeof options === 'object' && Object.hasOwn(options, 'cause') && !('cause' in this)) {
        const {
          cause
        } = options;
        this.cause = cause;
        if (cause instanceof Error && 'stack' in cause) {
          this.stack = `${this.stack}\nCAUSE: ${cause.stack}`;
        }
      }
    }
  }

  /**
   * @public
   */
  class ApiDOMError extends Error {
    static [Symbol.hasInstance](instance) {
      // we want to ApiDOMAggregateError to act as if ApiDOMError was its superclass
      return super[Symbol.hasInstance](instance) || Function.prototype[Symbol.hasInstance].call(ApiDOMAggregateError, instance);
    }
    constructor(message, options) {
      super(message, options);
      this.name = this.constructor.name;
      if (typeof message === 'string') {
        this.message = message;
      }
      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }

      /**
       * This needs to stay here until our minimum supported version of Node.js is >= 16.9.0.
       * Node.js is >= 16.9.0 supports error causes natively.
       */
      if (options != null && typeof options === 'object' && Object.hasOwn(options, 'cause') && !('cause' in this)) {
        const {
          cause
        } = options;
        this.cause = cause;
        if (cause instanceof Error && 'stack' in cause) {
          this.stack = `${this.stack}\nCAUSE: ${cause.stack}`;
        }
      }
    }
  }

  /**
   * @public
   */
  class ApiDOMStructuredError extends ApiDOMError {
    constructor(message, structuredOptions) {
      super(message, structuredOptions);
      if (structuredOptions != null && typeof structuredOptions === 'object') {
        const {
          cause,
          ...causelessOptions
        } = structuredOptions;
        Object.assign(this, causelessOptions);
      }
    }
  }

  /**
   * @public
   */
  class UnsupportedOperationError extends ApiDOMError {}

  /**
   * @public
   */
  class NotImplementedError extends UnsupportedOperationError {}

  /**
   * SPDX-FileCopyrightText: Copyright (c) GraphQL Contributors
   *
   * SPDX-License-Identifier: MIT
   */

  /**
   * @public
   */
  const getVisitFn = (visitor, type, isLeaving) => {
    // @ts-ignore
    const typeVisitor = visitor[type];
    if (typeVisitor != null) {
      if (!isLeaving && typeof typeVisitor === 'function') {
        // { Type() {} }
        return typeVisitor;
      }
      const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;
      if (typeof typeSpecificVisitor === 'function') {
        // { Type: { enter() {}, leave() {} } }
        return typeSpecificVisitor;
      }
    } else {
      const specificVisitor = isLeaving ? visitor.leave : visitor.enter;
      if (specificVisitor != null) {
        if (typeof specificVisitor === 'function') {
          // { enter() {}, leave() {} }
          return specificVisitor;
        }
        // @ts-ignore
        const specificTypeVisitor = specificVisitor[type];
        if (typeof specificTypeVisitor === 'function') {
          // { enter: { Type() {} }, leave: { Type() {} } }
          return specificTypeVisitor;
        }
      }
    }
    return null;
  };

  /**
   * @public
   */
  const BREAK = {};

  /**
   * @public
   */
  const getNodeType$4 = node => node === null || node === void 0 ? void 0 : node.type;

  /**
   * @public
   */
  const isNode$1 = node => typeof getNodeType$4(node) === 'string';

  /**
   * @public
   */
  const cloneNode$1 = node => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));

  /**
   * Creates a new visitor instance which delegates to many visitors to run in
   * parallel. Each visitor will be visited for each node before moving on.
   *
   * If a prior visitor edits a node, no following visitors will see that node.
   * `exposeEdits=true` can be used to expose the edited node from the previous visitors.
   * @public
   */

  /**
   * @public
   */

  /**
   * @public
   */
  const mergeAll = (visitors, {
    visitFnGetter = getVisitFn,
    nodeTypeGetter = getNodeType$4,
    breakSymbol = BREAK,
    deleteNodeSymbol = null,
    skipVisitingNodeSymbol = false,
    exposeEdits = false
  } = {}) => {
    const skipSymbol = Symbol('skip');
    const skipping = new Array(visitors.length).fill(skipSymbol);
    return {
      enter(node, key, parent, path, ancestors, link) {
        let currentNode = node;
        let hasChanged = false;
        const linkProxy = {
          ...link,
          replaceWith(newNode, replacer) {
            link.replaceWith(newNode, replacer);
            currentNode = newNode;
          }
        };
        for (let i = 0; i < visitors.length; i += 1) {
          if (skipping[i] === skipSymbol) {
            const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);
            if (typeof visitFn === 'function') {
              const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);

              // check if the visitor is async
              if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {
                throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {
                  visitor: visitors[i],
                  visitFn
                });
              }
              if (result === skipVisitingNodeSymbol) {
                skipping[i] = currentNode;
              } else if (result === breakSymbol) {
                skipping[i] = breakSymbol;
              } else if (result === deleteNodeSymbol) {
                return result;
              } else if (result !== undefined) {
                if (exposeEdits) {
                  currentNode = result;
                  hasChanged = true;
                } else {
                  return result;
                }
              }
            }
          }
        }
        return hasChanged ? currentNode : undefined;
      },
      leave(node, key, parent, path, ancestors, link) {
        let currentNode = node;
        const linkProxy = {
          ...link,
          replaceWith(newNode, replacer) {
            link.replaceWith(newNode, replacer);
            currentNode = newNode;
          }
        };
        for (let i = 0; i < visitors.length; i += 1) {
          if (skipping[i] === skipSymbol) {
            const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);
            if (typeof visitFn === 'function') {
              const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);

              // check if the visitor is async
              if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {
                throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {
                  visitor: visitors[i],
                  visitFn
                });
              }
              if (result === breakSymbol) {
                skipping[i] = breakSymbol;
              } else if (result !== undefined && result !== skipVisitingNodeSymbol) {
                return result;
              }
            }
          } else if (skipping[i] === currentNode) {
            skipping[i] = skipSymbol;
          }
        }
        return undefined;
      }
    };
  };
  const mergeAllAsync = (visitors, {
    visitFnGetter = getVisitFn,
    nodeTypeGetter = getNodeType$4,
    breakSymbol = BREAK,
    deleteNodeSymbol = null,
    skipVisitingNodeSymbol = false,
    exposeEdits = false
  } = {}) => {
    const skipSymbol = Symbol('skip');
    const skipping = new Array(visitors.length).fill(skipSymbol);
    return {
      async enter(node, key, parent, path, ancestors, link) {
        let currentNode = node;
        let hasChanged = false;
        const linkProxy = {
          ...link,
          replaceWith(newNode, replacer) {
            link.replaceWith(newNode, replacer);
            currentNode = newNode;
          }
        };
        for (let i = 0; i < visitors.length; i += 1) {
          if (skipping[i] === skipSymbol) {
            const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);
            if (typeof visitFn === 'function') {
              // eslint-disable-next-line no-await-in-loop
              const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);
              if (result === skipVisitingNodeSymbol) {
                skipping[i] = currentNode;
              } else if (result === breakSymbol) {
                skipping[i] = breakSymbol;
              } else if (result === deleteNodeSymbol) {
                return result;
              } else if (result !== undefined) {
                if (exposeEdits) {
                  currentNode = result;
                  hasChanged = true;
                } else {
                  return result;
                }
              }
            }
          }
        }
        return hasChanged ? currentNode : undefined;
      },
      async leave(node, key, parent, path, ancestors, link) {
        let currentNode = node;
        const linkProxy = {
          ...link,
          replaceWith(newNode, replacer) {
            link.replaceWith(newNode, replacer);
            currentNode = newNode;
          }
        };
        for (let i = 0; i < visitors.length; i += 1) {
          if (skipping[i] === skipSymbol) {
            const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);
            if (typeof visitFn === 'function') {
              // eslint-disable-next-line no-await-in-loop
              const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);
              if (result === breakSymbol) {
                skipping[i] = breakSymbol;
              } else if (result !== undefined && result !== skipVisitingNodeSymbol) {
                return result;
              }
            }
          } else if (skipping[i] === currentNode) {
            skipping[i] = skipSymbol;
          }
        }
        return undefined;
      }
    };
  };
  mergeAll[Symbol.for('nodejs.util.promisify.custom')] = mergeAllAsync;

  /* eslint-disable no-continue, no-param-reassign */
  /**
   * visit() will walk through an AST using a preorder depth first traversal, calling
   * the visitor's enter function at each node in the traversal, and calling the
   * leave function after visiting that node and all of its child nodes.
   *
   * By returning different values from the enter and leave functions, the
   * behavior of the visitor can be altered, including skipping over a sub-tree of
   * the AST (by returning false), editing the AST by returning a value or null
   * to remove the value, or to stop the whole traversal by returning BREAK.
   *
   * When using visit() to edit an AST, the original AST will not be modified, and
   * a new version of the AST with the changes applied will be returned from the
   * visit function.
   *
   * @example
   * ```
   *     const editedAST = visit(ast, {
   *       enter(node, key, parent, path, ancestors) {
   *         // return
   *         //   undefined: no action
   *         //   false: skip visiting this node
   *         //   BREAK: stop visiting altogether
   *         //   null: delete this node
   *         //   any value: replace this node with the returned value
   *       },
   *       leave(node, key, parent, path, ancestors) {
   *         // return
   *         //   undefined: no action
   *         //   false: no action
   *         //   BREAK: stop visiting altogether
   *         //   null: delete this node
   *         //   any value: replace this node with the returned value
   *       }
   *     });
   *```
   * Alternatively to providing enter() and leave() functions, a visitor can
   * instead provide functions named the same as the kinds of AST nodes, or
   * enter/leave visitors at a named key, leading to four permutations of
   * visitor API:
   *
   * 1) Named visitors triggered when entering a node a specific kind.
   * ```
   *     visit(ast, {
   *       Kind(node) {
   *         // enter the "Kind" node
   *       }
   *     })
   * ```
   * 2) Named visitors that trigger upon entering and leaving a node of
   *    a specific kind.
   * ```
   *     visit(ast, {
   *       Kind: {
   *         enter(node) {
   *           // enter the "Kind" node
   *         }
   *         leave(node) {
   *           // leave the "Kind" node
   *         }
   *       }
   *     })
   * ```
   * 3) Generic visitors that trigger upon entering and leaving any node.
   * ```
   *     visit(ast, {
   *       enter(node) {
   *         // enter any node
   *       },
   *       leave(node) {
   *         // leave any node
   *       }
   *     })
   * ```
   * 4) Parallel visitors for entering and leaving nodes of a specific kind.
   * ```
   *     visit(ast, {
   *       enter: {
   *         Kind(node) {
   *           // enter the "Kind" node
   *         }
   *       },
   *       leave: {
   *         Kind(node) {
   *           // leave the "Kind" node
   *         }
   *       }
   *     })
   * ```
   *  sig `visit :: (Node, Visitor, Options)`
   *
   *  sig `Options = { keyMap: Object, state: Object }`
   *
   *  @public
   */
  const visit$2 = (
  // @ts-ignore
  root,
  // @ts-ignore
  visitor, {
    keyMap = null,
    state = {},
    breakSymbol = BREAK,
    deleteNodeSymbol = null,
    skipVisitingNodeSymbol = false,
    visitFnGetter = getVisitFn,
    nodeTypeGetter = getNodeType$4,
    nodePredicate = isNode$1,
    nodeCloneFn = cloneNode$1,
    detectCycles = true,
    detectCyclesCallback = null
  } = {}) => {
    const visitorKeys = keyMap || {};
    let stack;
    let inArray = Array.isArray(root);
    let keys = [root];
    let index = -1;
    let parent;
    let edits = [];
    let node = root;
    const path = [];
    // @ts-ignore
    const ancestors = [];
    do {
      index += 1;
      const isLeaving = index === keys.length;
      let key;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? undefined : path.pop();
        node = parent;
        // @ts-ignore
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            // @ts-ignore; creating clone
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === deleteNodeSymbol) {
                node.splice(arrayKey, 1);
                editOffset += 1;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            // creating clone
            node = nodeCloneFn(node);
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys = stack.keys;
        // @ts-ignore
        edits = stack.edits;
        // @ts-ignore
        inArray = stack.inArray;
        // @ts-ignore
        stack = stack.prev;
      } else if (parent !== deleteNodeSymbol && parent !== undefined) {
        key = inArray ? index : keys[index];
        node = parent[key];
        if (node === deleteNodeSymbol || node === undefined) {
          continue;
        }
        path.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        var _result;
        if (!nodePredicate(node)) {
          throw new ApiDOMStructuredError(`Invalid AST Node:  ${String(node)}`, {
            node
          });
        }

        // cycle detected; skipping over a sub-tree to avoid recursion
        if (detectCycles && ancestors.includes(node)) {
          if (typeof detectCyclesCallback === 'function') {
            // @ts-ignore
            detectCyclesCallback(node, key, parent, path, ancestors);
          }
          path.pop();
          continue;
        }
        // call appropriate visitor function if available
        const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);
        if (visitFn) {
          // assign state
          for (const [stateKey, stateValue] of Object.entries(state)) {
            visitor[stateKey] = stateValue;
          }
          const link = {
            // eslint-disable-next-line @typescript-eslint/no-loop-func
            replaceWith(newNode, replacer) {
              if (typeof replacer === 'function') {
                replacer(newNode, node, key, parent, path, ancestors);
              } else if (parent) {
                parent[key] = newNode;
              }
              if (!isLeaving) {
                node = newNode;
              }
            }
          };

          // retrieve result
          result = visitFn.call(visitor, node, key, parent, path, ancestors, link);
        }

        // check if the visitor is async
        if (typeof ((_result = result) === null || _result === void 0 ? void 0 : _result.then) === 'function') {
          throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {
            visitor,
            visitFn
          });
        }
        if (result === breakSymbol) {
          break;
        }
        if (result === skipVisitingNodeSymbol) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (nodePredicate(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result === undefined && isEdited) {
        edits.push([key, node]);
      }
      if (!isLeaving) {
        var _visitorKeys$nodeType;
        stack = {
          inArray,
          index,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        // @ts-ignore
        keys = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];
        index = -1;
        edits = [];
        if (parent !== deleteNodeSymbol && parent !== undefined) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== undefined);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future
    }
    return root;
  };

  /**
   * Asynchronous version of visit.
   */
  // @ts-ignore
  visit$2[Symbol.for('nodejs.util.promisify.custom')] = async (
  // @ts-ignore
  root,
  // @ts-ignore
  visitor, {
    keyMap = null,
    state = {},
    breakSymbol = BREAK,
    deleteNodeSymbol = null,
    skipVisitingNodeSymbol = false,
    visitFnGetter = getVisitFn,
    nodeTypeGetter = getNodeType$4,
    nodePredicate = isNode$1,
    nodeCloneFn = cloneNode$1,
    detectCycles = true,
    detectCyclesCallback = null
  } = {}) => {
    const visitorKeys = keyMap || {};
    let stack;
    let inArray = Array.isArray(root);
    let keys = [root];
    let index = -1;
    let parent;
    let edits = [];
    let node = root;
    const path = [];
    // @ts-ignore
    const ancestors = [];
    do {
      index += 1;
      const isLeaving = index === keys.length;
      let key;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? undefined : path.pop();
        node = parent;
        // @ts-ignore
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            // @ts-ignore; creating clone
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === deleteNodeSymbol) {
                node.splice(arrayKey, 1);
                editOffset += 1;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            // creating clone
            node = nodeCloneFn(node);
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys = stack.keys;
        // @ts-ignore
        edits = stack.edits;
        // @ts-ignore
        inArray = stack.inArray;
        // @ts-ignore
        stack = stack.prev;
      } else if (parent !== deleteNodeSymbol && parent !== undefined) {
        key = inArray ? index : keys[index];
        node = parent[key];
        if (node === deleteNodeSymbol || node === undefined) {
          continue;
        }
        path.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        if (!nodePredicate(node)) {
          throw new ApiDOMStructuredError(`Invalid AST Node: ${String(node)}`, {
            node
          });
        }

        // cycle detected; skipping over a sub-tree to avoid recursion
        if (detectCycles && ancestors.includes(node)) {
          if (typeof detectCyclesCallback === 'function') {
            // @ts-ignore
            detectCyclesCallback(node, key, parent, path, ancestors);
          }
          path.pop();
          continue;
        }
        const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);
        if (visitFn) {
          // assign state
          for (const [stateKey, stateValue] of Object.entries(state)) {
            visitor[stateKey] = stateValue;
          }
          const link = {
            // eslint-disable-next-line @typescript-eslint/no-loop-func
            replaceWith(newNode, replacer) {
              if (typeof replacer === 'function') {
                replacer(newNode, node, key, parent, path, ancestors);
              } else if (parent) {
                parent[key] = newNode;
              }
              if (!isLeaving) {
                node = newNode;
              }
            }
          };

          // retrieve result
          result = await visitFn.call(visitor, node, key, parent, path, ancestors, link); // eslint-disable-line no-await-in-loop
        }
        if (result === breakSymbol) {
          break;
        }
        if (result === skipVisitingNodeSymbol) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (nodePredicate(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result === undefined && isEdited) {
        edits.push([key, node]);
      }
      if (!isLeaving) {
        var _visitorKeys$nodeType2;
        stack = {
          inArray,
          index,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        // @ts-ignore
        keys = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];
        index = -1;
        edits = [];
        if (parent !== deleteNodeSymbol && parent !== undefined) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== undefined);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future
    }
    return root;
  };

  /* eslint-enable */

  /**
   * @public
   */

  /**
   * @public
   */
  class CloneError extends ApiDOMStructuredError {
    value;
    constructor(message, structuredOptions) {
      super(message, structuredOptions);
      if (typeof structuredOptions !== 'undefined') {
        this.value = structuredOptions.value;
      }
    }
  }

  /**
   * @public
   */
  class DeepCloneError extends CloneError {}

  /**
   * @public
   */
  class ShallowCloneError extends CloneError {}

  /**
   * This dereference algorithm is used exclusively for dereferencing specification objects.
   * It doesn't handle circular references of external references and works on objects only (not arrays).
   * @public
   */
  // eslint-disable-next-line import/prefer-default-export
  const dereference = (object, root) => {
    const rootObject = defaultTo(object, root);
    return mapObjIndexed(val => {
      if (isPlainObj(val) && has('$ref', val) && propSatisfies(isString, '$ref', val)) {
        const $ref = path$1(['$ref'], val);
        // @ts-ignore
        const pointer = trimCharsStart('#/', $ref);
        return path$1(pointer.split('/'), rootObject);
      }
      if (isPlainObj(val)) {
        return dereference(val, rootObject);
      }
      return val;
    }, object);
  };
  /**
   * @public
   */
  /* eslint-disable no-param-reassign */
  const assignSourceMap = (to, from) => {
    to.startPositionRow = from === null || from === void 0 ? void 0 : from.startPositionRow;
    to.startPositionColumn = from === null || from === void 0 ? void 0 : from.startPositionColumn;
    to.startIndex = from === null || from === void 0 ? void 0 : from.startIndex;
    to.endPositionRow = from === null || from === void 0 ? void 0 : from.endPositionRow;
    to.endPositionColumn = from === null || from === void 0 ? void 0 : from.endPositionColumn;
    to.endIndex = from === null || from === void 0 ? void 0 : from.endIndex;
    return to;
  };
  /* eslint-enable no-param-reassign */

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  const cloneDeep = (value, options = {}) => {
    const {
      visited = new WeakMap()
    } = options;
    const passThroughOptions = {
      ...options,
      visited
    };

    // detect cycle and return memoized value
    if (visited.has(value)) {
      return visited.get(value);
    }
    if (value instanceof minimExports.KeyValuePair) {
      const {
        key,
        value: val
      } = value;
      const keyCopy = isElement(key) ? cloneDeep(key, passThroughOptions) : key;
      const valueCopy = isElement(val) ? cloneDeep(val, passThroughOptions) : val;
      const copy = new minimExports.KeyValuePair(keyCopy, valueCopy);
      visited.set(value, copy);
      return copy;
    }
    if (value instanceof minimExports.ObjectSlice) {
      const mapper = element => cloneDeep(element, passThroughOptions);
      const items = [...value].map(mapper);
      const copy = new minimExports.ObjectSlice(items);
      visited.set(value, copy);
      return copy;
    }
    if (value instanceof minimExports.ArraySlice) {
      const mapper = element => cloneDeep(element, passThroughOptions);
      const items = [...value].map(mapper);
      const copy = new minimExports.ArraySlice(items);
      visited.set(value, copy);
      return copy;
    }
    if (isElement(value)) {
      const copy = cloneShallow(value); // eslint-disable-line @typescript-eslint/no-use-before-define

      visited.set(value, copy);
      if (value.content) {
        if (isElement(value.content)) {
          copy.content = cloneDeep(value.content, passThroughOptions);
        } else if (value.content instanceof minimExports.KeyValuePair) {
          copy.content = cloneDeep(value.content, passThroughOptions);
        } else if (Array.isArray(value.content)) {
          const mapper = element => cloneDeep(element, passThroughOptions);
          copy.content = value.content.map(mapper);
        } else {
          copy.content = value.content;
        }
      } else {
        copy.content = value.content;
      }
      return copy;
    }
    throw new DeepCloneError("Value provided to cloneDeep function couldn't be cloned", {
      value
    });
  };
  cloneDeep.safe = value => {
    try {
      return cloneDeep(value);
    } catch {
      return value;
    }
  };
  const cloneShallowKeyValuePair = keyValuePair => {
    const {
      key,
      value
    } = keyValuePair;
    return new minimExports.KeyValuePair(key, value);
  };
  const cloneShallowArraySlice = arraySlice => {
    const items = [...arraySlice];
    return new minimExports.ArraySlice(items);
  };
  const cloneShallowObjectSlice = objectSlice => {
    const items = [...objectSlice];
    return new minimExports.ObjectSlice(items);
  };

  /* eslint-disable no-underscore-dangle */
  const cloneShallowElement = element => {
    // @ts-ignore
    const copy = new element.constructor();
    copy.element = element.element;
    if (hasElementSourceMap(element)) {
      assignSourceMap(copy, element);
    }
    if (element.meta.length > 0) {
      copy._meta = cloneDeep(element.meta);
    }
    if (element.attributes.length > 0) {
      copy._attributes = cloneDeep(element.attributes);
    }
    if (isElement(element.content)) {
      const content = element.content;
      copy.content = cloneShallowElement(content);
    } else if (Array.isArray(element.content)) {
      copy.content = [...element.content];
    } else if (element.content instanceof minimExports.KeyValuePair) {
      copy.content = cloneShallowKeyValuePair(element.content);
    } else {
      copy.content = element.content;
    }
    return copy;
  };
  /* eslint-enable */

  /**
   * @public
   */
  const cloneShallow = value => {
    if (value instanceof minimExports.KeyValuePair) {
      return cloneShallowKeyValuePair(value);
    }
    if (value instanceof minimExports.ObjectSlice) {
      return cloneShallowObjectSlice(value);
    }
    if (value instanceof minimExports.ArraySlice) {
      return cloneShallowArraySlice(value);
    }
    if (isElement(value)) {
      return cloneShallowElement(value);
    }
    throw new ShallowCloneError("Value provided to cloneShallow function couldn't be cloned", {
      value
    });
  };
  cloneShallow.safe = value => {
    try {
      return cloneShallow(value);
    } catch {
      return value;
    }
  };

  /**
   * @public
   */
  const getNodeType$3 = element => {
    /*
     * We're translating every possible higher element type to primitive minim type here.
     * We're using polymorphism to recognize any higher element type as ObjectElement or ArrayElement.
     * Using polymorphism allows us to assume any namespace.
     *
     * There is a problem with naming visitor methods described here: https://github.com/babel/babel/discussions/12874
     */
    return isObjectElement(element) ? 'ObjectElement' : isArrayElement(element) ? 'ArrayElement' : isMemberElement(element) ? 'MemberElement' : isStringElement(element) ? 'StringElement' : isBooleanElement(element) ? 'BooleanElement' : isNumberElement(element) ? 'NumberElement' : isNullElement(element) ? 'NullElement' : isLinkElement$2(element) ? 'LinkElement' : isRefElement(element) ? 'RefElement' : undefined;
  };

  /**
   * @public
   */
  const cloneNode = node => {
    if (isElement(node)) {
      return cloneShallow(node);
    }
    return cloneNode$1(node);
  };

  // isNode :: Node -> Boolean
  const isNode = pipe(getNodeType$3, isString);

  /**
   * @public
   */
  const keyMapDefault$1 = {
    ObjectElement: ['content'],
    ArrayElement: ['content'],
    MemberElement: ['key', 'value'],
    StringElement: [],
    BooleanElement: [],
    NumberElement: [],
    NullElement: [],
    RefElement: [],
    LinkElement: [],
    Annotation: [],
    Comment: [],
    ParseResultElement: ['content']
  };

  /**
   * @public
   */
  const visit$1 = (root,
  // @ts-ignore
  visitor, {
    keyMap = keyMapDefault$1,
    ...rest
  } = {}) => {
    // @ts-ignore
    return visit$2(root, visitor, {
      // @ts-ignore
      keyMap,
      // @ts-ignore
      nodeTypeGetter: getNodeType$3,
      nodePredicate: isNode,
      nodeCloneFn: cloneNode,
      ...rest
    });
  };

  // @ts-ignore
  visit$1[Symbol.for('nodejs.util.promisify.custom')] = async (root,
  // @ts-ignore
  visitor, {
    keyMap = keyMapDefault$1,
    ...rest
  } = {}) => {
    // @ts-ignore
    return visit$2[Symbol.for('nodejs.util.promisify.custom')](root, visitor, {
      // @ts-ignore
      keyMap,
      // @ts-ignore
      nodeTypeGetter: getNodeType$3,
      nodePredicate: isNode,
      nodeCloneFn: cloneNode,
      ...rest
    });
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  const defaultDispatchPluginsOptions = {
    toolboxCreator: createToolbox$7,
    visitorOptions: {
      nodeTypeGetter: getNodeType$3,
      exposeEdits: true
    }
  };

  /**
   * @public
   */
  const dispatchPluginsSync = (element, plugins, options = {}) => {
    if (plugins.length === 0) return element;
    const mergedOptions = mergeDeepRight(defaultDispatchPluginsOptions, options);
    const {
      toolboxCreator,
      visitorOptions
    } = mergedOptions;
    const toolbox = toolboxCreator();
    const pluginsSpecs = plugins.map(plugin => plugin(toolbox));
    const mergedPluginsVisitor = mergeAll(pluginsSpecs.map(propOr({}, 'visitor')), {
      ...visitorOptions
    });
    pluginsSpecs.forEach(invokeArgs(['pre'], []));
    const newElement = visit$1(element, mergedPluginsVisitor, visitorOptions);
    pluginsSpecs.forEach(invokeArgs(['post'], []));
    return newElement;
  };
  const dispatchPluginsAsync = async (element, plugins, options = {}) => {
    if (plugins.length === 0) return element;
    const mergedOptions = mergeDeepRight(defaultDispatchPluginsOptions, options);
    const {
      toolboxCreator,
      visitorOptions
    } = mergedOptions;
    const toolbox = toolboxCreator();
    const pluginsSpecs = plugins.map(plugin => plugin(toolbox));
    const mergeAllVisitorsAsync = mergeAll[Symbol.for('nodejs.util.promisify.custom')];
    const visitAsync = visit$1[Symbol.for('nodejs.util.promisify.custom')];
    const mergedPluginsVisitor = mergeAllVisitorsAsync(pluginsSpecs.map(propOr({}, 'visitor')), {
      ...visitorOptions
    });
    await Promise.allSettled(pluginsSpecs.map(invokeArgs(['pre'], [])));
    const newElement = await visitAsync(element, mergedPluginsVisitor, visitorOptions);
    await Promise.allSettled(pluginsSpecs.map(invokeArgs(['post'], [])));
    return newElement;
  };
  dispatchPluginsSync[Symbol.for('nodejs.util.promisify.custom')] = dispatchPluginsAsync;

  /**
   * @public
   */
  class MediaTypes extends Array {
    unknownMediaType = 'application/octet-stream';

    // eslint-disable-next-line class-methods-use-this
    filterByFormat() {
      throw new NotImplementedError('filterByFormat method in MediaTypes class is not yet implemented.');
    }

    // eslint-disable-next-line class-methods-use-this
    findBy() {
      throw new NotImplementedError('findBy method in MediaTypes class is not yet implemented.');
    }

    // eslint-disable-next-line class-methods-use-this
    latest() {
      throw new NotImplementedError('latest method in MediaTypes class is not yet implemented.');
    }
  }

  const refract$6 = (value, {
    Type,
    plugins = []
  }) => {
    /**
     * This is where values gets refracted into generic ApiDOM.
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const element = new Type(value);
    if (isElement(value)) {
      if (value.meta.length > 0) {
        element.meta = cloneDeep(value.meta);
      }
      if (value.attributes.length > 0) {
        element.attributes = cloneDeep(value.attributes);
      }
    }

    /**
     * Run plugins only when necessary.
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(element, plugins, {
      toolboxCreator: createToolbox$7,
      visitorOptions: {
        nodeTypeGetter: getNodeType$3
      }
    });
  };
  const createRefractor$6 = Type => (value, options = {}) => refract$6(value, {
    ...options,
    Type
  });

  minimExports.ObjectElement.refract = createRefractor$6(minimExports.ObjectElement);
  minimExports.ArrayElement.refract = createRefractor$6(minimExports.ArrayElement);
  minimExports.StringElement.refract = createRefractor$6(minimExports.StringElement);
  minimExports.BooleanElement.refract = createRefractor$6(minimExports.BooleanElement);
  minimExports.NullElement.refract = createRefractor$6(minimExports.NullElement);
  minimExports.NumberElement.refract = createRefractor$6(minimExports.NumberElement);
  minimExports.LinkElement.refract = createRefractor$6(minimExports.LinkElement);
  minimExports.RefElement.refract = createRefractor$6(minimExports.RefElement);
  Annotation.refract = createRefractor$6(Annotation);
  Comment.refract = createRefractor$6(Comment);
  ParseResult.refract = createRefractor$6(ParseResult);

  const nodeTypeGetter = node => {
    if (typeof (node === null || node === void 0 ? void 0 : node.type) === 'string') {
      return node.type;
    }
    return getNodeType$3(node);
  };
  const keyMapDefault = {
    EphemeralObject: ['content'],
    EphemeralArray: ['content'],
    ...keyMapDefault$1
  };

  // eslint-disable-next-line import/prefer-default-export
  const visit = (root,
  // @ts-ignore
  visitor, {
    keyMap = keyMapDefault,
    ...rest
  } = {}) => {
    return visit$1(root, visitor, {
      keyMap,
      // @ts-ignore
      nodeTypeGetter,
      nodePredicate: T,
      detectCycles: false,
      deleteNodeSymbol: Symbol.for('delete-node'),
      skipVisitingNodeSymbol: Symbol.for('skip-visiting-node'),
      ...rest
    });
  };

  // @ts-ignore
  visit[Symbol.for('nodejs.util.promisify.custom')] = async (root, {
    keyMap = keyMapDefault,
    ...rest
  } = {}) => {
    // @ts-ignore
    return visit$1[Symbol.for('nodejs.util.promisify.custom')](root, visitor, {
      keyMap,
      nodeTypeGetter,
      nodePredicate: T,
      detectCycles: false,
      deleteNodeSymbol: Symbol.for('delete-node'),
      skipVisitingNodeSymbol: Symbol.for('skip-visiting-node'),
      ...rest
    });
  };

  class EphemeralArray {
    type = 'EphemeralArray';
    content = [];
    reference = undefined;
    constructor(content) {
      this.content = content;
      this.reference = [];
    }
    toReference() {
      return this.reference;
    }
    toArray() {
      this.reference.push(...this.content);
      return this.reference;
    }
  }

  class EphemeralObject {
    type = 'EphemeralObject';
    content = [];
    reference = undefined;
    constructor(content) {
      this.content = content;
      this.reference = {};
    }
    toReference() {
      return this.reference;
    }
    toObject() {
      return Object.assign(this.reference, Object.fromEntries(this.content));
    }
  }

  /* eslint-disable class-methods-use-this */
  let Visitor$2 = class Visitor {
    ObjectElement = {
      enter: element => {
        if (this.references.has(element)) {
          return this.references.get(element).toReference();
        }
        const ephemeral = new EphemeralObject(element.content);
        this.references.set(element, ephemeral);
        return ephemeral;
      }
    };
    EphemeralObject = {
      leave: ephemeral => {
        return ephemeral.toObject();
      }
    };
    MemberElement = {
      enter: element => {
        return [element.key, element.value];
      }
    };
    ArrayElement = {
      enter: element => {
        if (this.references.has(element)) {
          return this.references.get(element).toReference();
        }
        const ephemeral = new EphemeralArray(element.content);
        this.references.set(element, ephemeral);
        return ephemeral;
      }
    };
    EphemeralArray = {
      leave: ephemeral => {
        return ephemeral.toArray();
      }
    };
    references = new WeakMap();
    BooleanElement(element) {
      return element.toValue();
    }
    NumberElement(element) {
      return element.toValue();
    }
    StringElement(element) {
      return element.toValue();
    }
    NullElement() {
      return null;
    }
    RefElement(element, ...rest) {
      var _ancestors;
      const ancestors = rest[3];
      if (((_ancestors = ancestors[ancestors.length - 1]) === null || _ancestors === void 0 ? void 0 : _ancestors.type) === 'EphemeralObject') {
        return Symbol.for('delete-node');
      }
      return String(element.toValue());
    }
    LinkElement(element) {
      if (isStringElement(element.href)) {
        return element.href.toValue();
      }
      return '';
    }
  };
  /**
   * @public
   */
  const serializer = element => {
    if (!isElement(element)) return element;

    // shortcut optimization for certain element types
    if (isStringElement(element) || isNumberElement(element) || isBooleanElement(element) || isNullElement(element)) {
      return element.toValue();
    }
    return visit(element, new Visitor$2());
  };

  /* eslint-disable @typescript-eslint/no-use-before-define */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  const emptyElement = element => {
    const meta = element.meta.length > 0 ? cloneDeep(element.meta) : undefined;
    const attributes = element.attributes.length > 0 ? cloneDeep(element.attributes) : undefined;

    // @ts-ignore
    return new element.constructor(undefined, meta, attributes);
  };
  const cloneUnlessOtherwiseSpecified = (element, options) => options.clone && options.isMergeableElement(element) ? deepmerge(emptyElement(element), element, options) : element;
  const getMergeFunction = (keyElement, options) => {
    if (typeof options.customMerge !== 'function') {
      return deepmerge;
    }
    const customMerge = options.customMerge(keyElement, options);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  };
  const getMetaMergeFunction = options => {
    if (typeof options.customMetaMerge !== 'function') {
      return targetMeta => cloneDeep(targetMeta);
    }
    return options.customMetaMerge;
  };
  const getAttributesMergeFunction = options => {
    if (typeof options.customAttributesMerge !== 'function') {
      return targetAttributes => cloneDeep(targetAttributes);
    }
    return options.customAttributesMerge;
  };
  const mergeArrayElement = (targetElement, sourceElement, options) => targetElement.concat(sourceElement)['fantasy-land/map'](item => cloneUnlessOtherwiseSpecified(item, options));
  const mergeObjectElement = (targetElement, sourceElement, options) => {
    const destination = isObjectElement(targetElement) ? emptyElement(targetElement) : emptyElement(sourceElement);
    if (isObjectElement(targetElement)) {
      targetElement.forEach((value, key, member) => {
        const clonedMember = cloneShallow(member);
        clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);
        destination.content.push(clonedMember);
      });
    }
    sourceElement.forEach((value, key, member) => {
      const keyValue = serializer(key);
      let clonedMember;
      if (isObjectElement(targetElement) && targetElement.hasKey(keyValue) && options.isMergeableElement(value)) {
        const targetValue = targetElement.get(keyValue);
        clonedMember = cloneShallow(member);
        clonedMember.value = getMergeFunction(key, options)(targetValue, value, options);
      } else {
        clonedMember = cloneShallow(member);
        clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);
      }
      destination.remove(keyValue);
      destination.content.push(clonedMember);
    });
    return destination;
  };
  const defaultOptions = {
    clone: true,
    isMergeableElement: element => isObjectElement(element) || isArrayElement(element),
    arrayElementMerge: mergeArrayElement,
    objectElementMerge: mergeObjectElement,
    customMerge: undefined,
    customMetaMerge: undefined,
    customAttributesMerge: undefined
  };

  /**
   * @public
   */
  const deepmerge = (targetElement, sourceElement, options) => {
    var _mergedOptions$isMerg, _mergedOptions$arrayE, _mergedOptions$object;
    const mergedOptions = {
      ...defaultOptions,
      ...options
    };
    mergedOptions.isMergeableElement = (_mergedOptions$isMerg = mergedOptions.isMergeableElement) !== null && _mergedOptions$isMerg !== void 0 ? _mergedOptions$isMerg : defaultOptions.isMergeableElement;
    mergedOptions.arrayElementMerge = (_mergedOptions$arrayE = mergedOptions.arrayElementMerge) !== null && _mergedOptions$arrayE !== void 0 ? _mergedOptions$arrayE : defaultOptions.arrayElementMerge;
    mergedOptions.objectElementMerge = (_mergedOptions$object = mergedOptions.objectElementMerge) !== null && _mergedOptions$object !== void 0 ? _mergedOptions$object : defaultOptions.objectElementMerge;
    const sourceIsArrayElement = isArrayElement(sourceElement);
    const targetIsArrayElement = isArrayElement(targetElement);
    const sourceAndTargetTypesMatch = sourceIsArrayElement === targetIsArrayElement;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(sourceElement, mergedOptions);
    }

    // merging two elements
    const mergedElement = sourceIsArrayElement && typeof mergedOptions.arrayElementMerge === 'function' ? mergedOptions.arrayElementMerge(targetElement, sourceElement, mergedOptions) : mergedOptions.objectElementMerge(targetElement, sourceElement, mergedOptions);

    // merging meta & attributes
    mergedElement.meta = getMetaMergeFunction(mergedOptions)(targetElement.meta, sourceElement.meta);
    mergedElement.attributes = getAttributesMergeFunction(mergedOptions)(targetElement.attributes, sourceElement.attributes);
    return mergedElement;
  };
  deepmerge.all = (list, options) => {
    if (!Array.isArray(list)) {
      throw new TypeError('First argument of deepmerge should be an array.');
    }
    if (list.length === 0) {
      return new minimExports.ObjectElement();
    }
    return list.reduce((target, source) => {
      return deepmerge(target, source, options);
    }, emptyElement(list[0]));
  };
  /* eslint-enable @typescript-eslint/no-use-before-define */

  class OpenAPIMediaTypes extends MediaTypes {
    filterByFormat(format = "generic") {
      const effectiveFormat = format === "generic" ? "openapi;version" : format;
      return this.filter((mediaType) => mediaType.includes(effectiveFormat));
    }
    findBy(version = "3.1.0", format = "generic") {
      const search = format === "generic" ? `vnd.oai.openapi;version=${version}` : `vnd.oai.openapi+${format};version=${version}`;
      const found = this.find((mediaType) => mediaType.includes(search));
      return found || this.unknownMediaType;
    }
    latest(format = "generic") {
      return last(this.filterByFormat(format));
    }
  }
  const mediaTypes = new OpenAPIMediaTypes(
    "application/vnd.oai.openapi;version=3.1.0",
    "application/vnd.oai.openapi+json;version=3.1.0",
    "application/vnd.oai.openapi+yaml;version=3.1.0"
  );

  /**
   * @public
   */
  let Callback$1 = class Callback extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'callback';
    }
  };

  /**
   * @public
   */
  let Components$1 = class Components extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'components';
    }
    get schemas() {
      return this.get('schemas');
    }
    set schemas(schemas) {
      this.set('schemas', schemas);
    }
    get responses() {
      return this.get('responses');
    }
    set responses(responses) {
      this.set('responses', responses);
    }
    get parameters() {
      return this.get('parameters');
    }
    set parameters(parameters) {
      this.set('parameters', parameters);
    }
    get examples() {
      return this.get('examples');
    }
    set examples(examples) {
      this.set('examples', examples);
    }
    get requestBodies() {
      return this.get('requestBodies');
    }
    set requestBodies(requestBodies) {
      this.set('requestBodies', requestBodies);
    }
    get headers() {
      return this.get('headers');
    }
    set headers(headers) {
      this.set('headers', headers);
    }
    get securitySchemes() {
      return this.get('securitySchemes');
    }
    set securitySchemes(securitySchemes) {
      this.set('securitySchemes', securitySchemes);
    }
    get links() {
      return this.get('links');
    }
    set links(links) {
      this.set('links', links);
    }
    get callbacks() {
      return this.get('callbacks');
    }
    set callbacks(callbacks) {
      this.set('callbacks', callbacks);
    }
  };

  /**
   * @public
   */
  let Contact$1 = class Contact extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'contact';
    }
    get name() {
      return this.get('name');
    }
    set name(name) {
      this.set('name', name);
    }
    get url() {
      return this.get('url');
    }
    set url(url) {
      this.set('url', url);
    }
    get email() {
      return this.get('email');
    }
    set email(email) {
      this.set('email', email);
    }
  };

  /**
   * @public
   */
  let Discriminator$1 = class Discriminator extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'discriminator';
    }
    get propertyName() {
      return this.get('propertyName');
    }
    set propertyName(propertyName) {
      this.set('propertyName', propertyName);
    }
    get mapping() {
      return this.get('mapping');
    }
    set mapping(mapping) {
      this.set('mapping', mapping);
    }
  };

  /**
   * @public
   */
  let Encoding$1 = class Encoding extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'encoding';
    }
    get contentType() {
      return this.get('contentType');
    }
    set contentType(contentType) {
      this.set('contentType', contentType);
    }
    get headers() {
      return this.get('headers');
    }
    set headers(headers) {
      this.set('headers', headers);
    }
    get style() {
      return this.get('style');
    }
    set style(style) {
      this.set('style', style);
    }
    get explode() {
      return this.get('explode');
    }
    set explode(explode) {
      this.set('explode', explode);
    }
    get allowedReserved() {
      return this.get('allowedReserved');
    }
    set allowedReserved(allowedReserved) {
      this.set('allowedReserved', allowedReserved);
    }
  };

  /**
   * @public
   */
  let Example$1 = class Example extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'example';
    }
    get summary() {
      return this.get('summary');
    }
    set summary(summary) {
      this.set('summary', summary);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get value() {
      return this.get('value');
    }
    set value(value) {
      this.set('value', value);
    }
    get externalValue() {
      return this.get('externalValue');
    }
    set externalValue(externalValue) {
      this.set('externalValue', externalValue);
    }
  };

  /**
   * @public
   */
  let ExternalDocumentation$1 = class ExternalDocumentation extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'externalDocumentation';
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get url() {
      return this.get('url');
    }
    set url(url) {
      this.set('url', url);
    }
  };

  /**
   * @public
   */
  let Header$1 = class Header extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'header';
    }
    get required() {
      if (this.hasKey('required')) {
        return this.get('required');
      }
      return new minimExports.BooleanElement(false);
    }
    set required(required) {
      this.set('required', required);
    }
    get deprecated() {
      if (this.hasKey('deprecated')) {
        return this.get('deprecated');
      }
      return new minimExports.BooleanElement(false);
    }
    set deprecated(deprecated) {
      this.set('deprecated', deprecated);
    }
    get allowEmptyValue() {
      return this.get('allowEmptyValue');
    }
    set allowEmptyValue(allowEmptyValue) {
      this.set('allowEmptyValue', allowEmptyValue);
    }
    get style() {
      return this.get('style');
    }
    set style(style) {
      this.set('style', style);
    }
    get explode() {
      return this.get('explode');
    }
    set explode(explode) {
      this.set('explode', explode);
    }
    get allowReserved() {
      return this.get('allowReserved');
    }
    set allowReserved(allowReserved) {
      this.set('allowReserved', allowReserved);
    }
    get schema() {
      return this.get('schema');
    }
    set schema(schema) {
      this.set('schema', schema);
    }
    get example() {
      return this.get('example');
    }
    set example(example) {
      this.set('example', example);
    }
    get examples() {
      return this.get('examples');
    }
    set examples(examples) {
      this.set('examples', examples);
    }
    get contentProp() {
      return this.get('content');
    }
    set contentProp(content) {
      this.set('content', content);
    }
  };
  Object.defineProperty(Header$1.prototype, 'description', {
    get() {
      return this.get('description');
    },
    set(description) {
      this.set('description', description);
    },
    enumerable: true
  });

  /**
   * @public
   */
  let Info$1 = class Info extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'info';
      this.classes.push('info');
    }
    get title() {
      return this.get('title');
    }
    set title(title) {
      this.set('title', title);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get termsOfService() {
      return this.get('termsOfService');
    }
    set termsOfService(tos) {
      this.set('termsOfService', tos);
    }
    get contact() {
      return this.get('contact');
    }
    set contact(contactElement) {
      this.set('contact', contactElement);
    }
    get license() {
      return this.get('license');
    }
    set license(licenseElement) {
      this.set('license', licenseElement);
    }
    get version() {
      return this.get('version');
    }
    set version(version) {
      this.set('version', version);
    }
  };

  /**
   * @public
   */
  let License$1 = class License extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'license';
    }
    get name() {
      return this.get('name');
    }
    set name(name) {
      this.set('name', name);
    }
    get url() {
      return this.get('url');
    }
    set url(url) {
      this.set('url', url);
    }
  };

  /**
   * @public
   */
  let Link$1 = class Link extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'link';
    }
    get operationRef() {
      return this.get('operationRef');
    }
    set operationRef(operationRef) {
      this.set('operationRef', operationRef);
    }
    get operationId() {
      return this.get('operationId');
    }
    set operationId(operationId) {
      this.set('operationId', operationId);
    }
    get operation() {
      if (isStringElement(this.operationRef)) {
        var _this$operationRef;
        return (_this$operationRef = this.operationRef) === null || _this$operationRef === void 0 ? void 0 : _this$operationRef.meta.get('operation');
      }
      if (isStringElement(this.operationId)) {
        var _this$operationId;
        return (_this$operationId = this.operationId) === null || _this$operationId === void 0 ? void 0 : _this$operationId.meta.get('operation');
      }
      return undefined;
    }
    set operation(operation) {
      this.set('operation', operation);
    }
    get parameters() {
      return this.get('parameters');
    }
    set parameters(parameters) {
      this.set('parameters', parameters);
    }
    get requestBody() {
      return this.get('requestBody');
    }
    set requestBody(requestBody) {
      this.set('requestBody', requestBody);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get server() {
      return this.get('server');
    }
    set server(server) {
      this.set('server', server);
    }
  };

  /**
   * @public
   */
  let MediaType$1 = class MediaType extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'mediaType';
    }
    get schema() {
      return this.get('schema');
    }
    set schema(schema) {
      this.set('schema', schema);
    }
    get example() {
      return this.get('example');
    }
    set example(example) {
      this.set('example', example);
    }
    get examples() {
      return this.get('examples');
    }
    set examples(examples) {
      this.set('examples', examples);
    }
    get encoding() {
      return this.get('encoding');
    }
    set encoding(encoding) {
      this.set('encoding', encoding);
    }
  };

  /**
   * @public
   */
  let OAuthFlow$1 = class OAuthFlow extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'oAuthFlow';
    }
    get authorizationUrl() {
      return this.get('authorizationUrl');
    }
    set authorizationUrl(authorizationUrl) {
      this.set('authorizationUrl', authorizationUrl);
    }
    get tokenUrl() {
      return this.get('tokenUrl');
    }
    set tokenUrl(tokenUrl) {
      this.set('tokenUrl', tokenUrl);
    }
    get refreshUrl() {
      return this.get('refreshUrl');
    }
    set refreshUrl(refreshUrl) {
      this.set('refreshUrl', refreshUrl);
    }
    get scopes() {
      return this.get('scopes');
    }
    set scopes(scopes) {
      this.set('scopes', scopes);
    }
  };

  /**
   * @public
   */
  let OAuthFlows$1 = class OAuthFlows extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'oAuthFlows';
    }
    get implicit() {
      return this.get('implicit');
    }
    set implicit(implicit) {
      this.set('implicit', implicit);
    }
    get password() {
      return this.get('password');
    }
    set password(password) {
      this.set('password', password);
    }
    get clientCredentials() {
      return this.get('clientCredentials');
    }
    set clientCredentials(clientCredentials) {
      this.set('clientCredentials', clientCredentials);
    }
    get authorizationCode() {
      return this.get('authorizationCode');
    }
    set authorizationCode(authorizationCode) {
      this.set('authorizationCode', authorizationCode);
    }
  };

  /**
   * @public
   */
  let Openapi$1 = class Openapi extends minimExports.StringElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'openapi';
      this.classes.push('spec-version');
      this.classes.push('version');
    }
  };

  /**
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  class OpenApi3_0 extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'openApi3_0';
      this.classes.push('api');
    }
    get openapi() {
      return this.get('openapi');
    }
    set openapi(openapi) {
      this.set('openapi', openapi);
    }
    get info() {
      return this.get('info');
    }
    set info(info) {
      this.set('info', info);
    }
    get servers() {
      return this.get('servers');
    }
    set servers(servers) {
      this.set('servers', servers);
    }
    get paths() {
      return this.get('paths');
    }
    set paths(paths) {
      this.set('paths', paths);
    }
    get components() {
      return this.get('components');
    }
    set components(components) {
      this.set('components', components);
    }
    get security() {
      return this.get('security');
    }
    set security(security) {
      this.set('security', security);
    }
    get tags() {
      return this.get('tags');
    }
    set tags(tags) {
      this.set('tags', tags);
    }
    get externalDocs() {
      return this.get('externalDocs');
    }
    set externalDocs(externalDocs) {
      this.set('externalDocs', externalDocs);
    }
  }

  /**
   * @public
   */
  let Operation$1 = class Operation extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'operation';
    }
    get tags() {
      return this.get('tags');
    }
    set tags(tags) {
      this.set('tags', tags);
    }
    get summary() {
      return this.get('summary');
    }
    set summary(description) {
      this.set('summary', description);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    set externalDocs(externalDocs) {
      this.set('externalDocs', externalDocs);
    }
    get externalDocs() {
      return this.get('externalDocs');
    }
    get operationId() {
      return this.get('operationId');
    }
    set operationId(operationId) {
      this.set('operationId', operationId);
    }
    get parameters() {
      return this.get('parameters');
    }
    set parameters(parameters) {
      this.set('parameters', parameters);
    }
    get requestBody() {
      return this.get('requestBody');
    }
    set requestBody(requestBody) {
      this.set('requestBody', requestBody);
    }
    get responses() {
      return this.get('responses');
    }
    set responses(responses) {
      this.set('responses', responses);
    }
    get callbacks() {
      return this.get('callbacks');
    }
    set callbacks(callbacks) {
      this.set('callbacks', callbacks);
    }
    get deprecated() {
      if (this.hasKey('deprecated')) {
        return this.get('deprecated');
      }
      return new minimExports.BooleanElement(false);
    }
    set deprecated(deprecated) {
      this.set('deprecated', deprecated);
    }
    get security() {
      return this.get('security');
    }
    set security(security) {
      this.set('security', security);
    }
    get servers() {
      return this.get('severs');
    }
    set servers(servers) {
      this.set('servers', servers);
    }
  };

  /**
   * @public
   */
  let Parameter$1 = class Parameter extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'parameter';
    }
    get name() {
      return this.get('name');
    }
    set name(name) {
      this.set('name', name);
    }
    get in() {
      return this.get('in');
    }
    set in(val) {
      this.set('in', val);
    }
    get required() {
      if (this.hasKey('required')) {
        return this.get('required');
      }
      return new minimExports.BooleanElement(false);
    }
    set required(required) {
      this.set('required', required);
    }
    get deprecated() {
      if (this.hasKey('deprecated')) {
        return this.get('deprecated');
      }
      return new minimExports.BooleanElement(false);
    }
    set deprecated(deprecated) {
      this.set('deprecated', deprecated);
    }
    get allowEmptyValue() {
      return this.get('allowEmptyValue');
    }
    set allowEmptyValue(allowEmptyValue) {
      this.set('allowEmptyValue', allowEmptyValue);
    }
    get style() {
      return this.get('style');
    }
    set style(style) {
      this.set('style', style);
    }
    get explode() {
      return this.get('explode');
    }
    set explode(explode) {
      this.set('explode', explode);
    }
    get allowReserved() {
      return this.get('allowReserved');
    }
    set allowReserved(allowReserved) {
      this.set('allowReserved', allowReserved);
    }
    get schema() {
      return this.get('schema');
    }
    set schema(schema) {
      this.set('schema', schema);
    }
    get example() {
      return this.get('example');
    }
    set example(example) {
      this.set('example', example);
    }
    get examples() {
      return this.get('examples');
    }
    set examples(examples) {
      this.set('examples', examples);
    }
    get contentProp() {
      return this.get('content');
    }
    set contentProp(content) {
      this.set('content', content);
    }
  };
  Object.defineProperty(Parameter$1.prototype, 'description', {
    get() {
      return this.get('description');
    },
    set(description) {
      this.set('description', description);
    },
    enumerable: true
  });

  /**
   * @public
   */
  let PathItem$1 = class PathItem extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'pathItem';
    }
    get $ref() {
      return this.get('$ref');
    }
    set $ref($ref) {
      this.set('$ref', $ref);
    }
    get summary() {
      return this.get('summary');
    }
    set summary(summary) {
      this.set('summary', summary);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get GET() {
      return this.get('get');
    }
    set GET(operation) {
      this.set('GET', operation);
    }
    get PUT() {
      return this.get('put');
    }
    set PUT(operation) {
      this.set('PUT', operation);
    }
    get POST() {
      return this.get('post');
    }
    set POST(operation) {
      this.set('POST', operation);
    }
    get DELETE() {
      return this.get('delete');
    }
    set DELETE(operation) {
      this.set('DELETE', operation);
    }
    get OPTIONS() {
      return this.get('options');
    }
    set OPTIONS(operation) {
      this.set('OPTIONS', operation);
    }
    get HEAD() {
      return this.get('head');
    }
    set HEAD(operation) {
      this.set('HEAD', operation);
    }
    get PATCH() {
      return this.get('patch');
    }
    set PATCH(operation) {
      this.set('PATCH', operation);
    }
    get TRACE() {
      return this.get('trace');
    }
    set TRACE(operation) {
      this.set('TRACE', operation);
    }
    get servers() {
      return this.get('servers');
    }
    set servers(servers) {
      this.set('servers', servers);
    }
    get parameters() {
      return this.get('parameters');
    }
    set parameters(parameters) {
      this.set('parameters', parameters);
    }
  };

  /**
   * @public
   */
  let Paths$1 = class Paths extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'paths';
    }
  };

  /**
   * @public
   */
  let Reference$1 = class Reference extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'reference';
      this.classes.push('openapi-reference');
    }
    get $ref() {
      return this.get('$ref');
    }
    set $ref($ref) {
      this.set('$ref', $ref);
    }
  };

  /**
   * @public
   */
  let RequestBody$1 = class RequestBody extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'requestBody';
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get contentProp() {
      return this.get('content');
    }
    set contentProp(content) {
      this.set('content', content);
    }
    get required() {
      if (this.hasKey('required')) {
        return this.get('required');
      }
      return new minimExports.BooleanElement(false);
    }
    set required(required) {
      this.set('required', required);
    }
  };

  /**
   * @public
   */
  let Response$1 = class Response extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'response';
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get headers() {
      return this.get('headers');
    }
    set headers(headers) {
      this.set('headers', headers);
    }
    get contentProp() {
      return this.get('content');
    }
    set contentProp(contentProp) {
      this.set('content', contentProp);
    }
    get links() {
      return this.get('links');
    }
    set links(links) {
      this.set('links', links);
    }
  };

  /**
   * @public
   */
  let Responses$1 = class Responses extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'responses';
    }
    get default() {
      return this.get('default');
    }
    set default(defaultValue) {
      this.set('default', defaultValue);
    }
  };

  /**
   * @public
   */
  let JSONSchema$4 = class JSONSchema extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'JSONSchemaDraft4';
    }

    /**
     * Core vocabulary
     *
     * URI: https://tools.ietf.org/html/draft-wright-json-schema-00
     */

    get idProp() {
      return this.get('id');
    }
    set idProp(idProp) {
      this.set('id', idProp);
    }
    get $schema() {
      return this.get('$schema');
    }
    set $schema($schema) {
      this.set('$schema', $schema);
    }

    /**
     * Validation vocabulary
     *
     * URI: https://tools.ietf.org/html/draft-wright-json-schema-validation-00
     */

    /**
     *  Validation keywords for numeric instances (number and integer)
     */

    get multipleOf() {
      return this.get('multipleOf');
    }
    set multipleOf(multipleOf) {
      this.set('multipleOf', multipleOf);
    }
    get maximum() {
      return this.get('maximum');
    }
    set maximum(maximum) {
      this.set('maximum', maximum);
    }
    get exclusiveMaximum() {
      return this.get('exclusiveMaximum');
    }
    set exclusiveMaximum(exclusiveMaximum) {
      this.set('exclusiveMaximum', exclusiveMaximum);
    }
    get minimum() {
      return this.get('minimum');
    }
    set minimum(minimum) {
      this.set('minimum', minimum);
    }
    get exclusiveMinimum() {
      return this.get('exclusiveMinimum');
    }
    set exclusiveMinimum(exclusiveMinimum) {
      this.set('exclusiveMinimum', exclusiveMinimum);
    }

    /**
     * Validation keywords for strings
     */

    get maxLength() {
      return this.get('maxLength');
    }
    set maxLength(maxLength) {
      this.set('maxLength', maxLength);
    }
    get minLength() {
      return this.get('minLength');
    }
    set minLength(minLength) {
      this.set('minLength', minLength);
    }
    get pattern() {
      return this.get('pattern');
    }
    set pattern(pattern) {
      this.set('pattern', pattern);
    }

    /**
     * Validation keywords for arrays
     */

    get additionalItems() {
      return this.get('additionalItems');
    }
    set additionalItems(additionalItems) {
      this.set('additionalItems', additionalItems);
    }
    get items() {
      return this.get('items');
    }
    set items(items) {
      this.set('items', items);
    }
    get maxItems() {
      return this.get('maxItems');
    }
    set maxItems(maxItems) {
      this.set('maxItems', maxItems);
    }
    get minItems() {
      return this.get('minItems');
    }
    set minItems(minItems) {
      this.set('minItems', minItems);
    }
    get uniqueItems() {
      return this.get('uniqueItems');
    }
    set uniqueItems(uniqueItems) {
      this.set('uniqueItems', uniqueItems);
    }

    /**
     * Validation keywords for objects
     */

    get maxProperties() {
      return this.get('maxProperties');
    }
    set maxProperties(maxProperties) {
      this.set('maxProperties', maxProperties);
    }
    get minProperties() {
      return this.get('minProperties');
    }
    set minProperties(minProperties) {
      this.set('minProperties', minProperties);
    }
    get required() {
      return this.get('required');
    }
    set required(required) {
      this.set('required', required);
    }
    get properties() {
      return this.get('properties');
    }
    set properties(properties) {
      this.set('properties', properties);
    }
    get additionalProperties() {
      return this.get('additionalProperties');
    }
    set additionalProperties(additionalProperties) {
      this.set('additionalProperties', additionalProperties);
    }
    get patternProperties() {
      return this.get('patternProperties');
    }
    set patternProperties(patternProperties) {
      this.set('patternProperties', patternProperties);
    }
    get dependencies() {
      return this.get('dependencies');
    }
    set dependencies(dependencies) {
      this.set('dependencies', dependencies);
    }

    /**
     *  Validation keywords for any instance type
     */

    get enum() {
      return this.get('enum');
    }
    set enum(enumValue) {
      this.set('enum', enumValue);
    }
    get type() {
      return this.get('type');
    }
    set type(type) {
      this.set('type', type);
    }
    get allOf() {
      return this.get('allOf');
    }
    set allOf(allOf) {
      this.set('allOf', allOf);
    }
    get anyOf() {
      return this.get('anyOf');
    }
    set anyOf(anyOf) {
      this.set('anyOf', anyOf);
    }
    get oneOf() {
      return this.get('oneOf');
    }
    set oneOf(oneOf) {
      this.set('oneOf', oneOf);
    }
    get not() {
      return this.get('not');
    }
    set not(not) {
      this.set('not', not);
    }
    get definitions() {
      return this.get('definitions');
    }
    set definitions(definitions) {
      this.set('definitions', definitions);
    }

    /**
     * Metadata keywords
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-00#section-6
     */

    get title() {
      return this.get('title');
    }
    set title(title) {
      this.set('title', title);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get default() {
      return this.get('default');
    }
    set default(defaultValue) {
      this.set('default', defaultValue);
    }

    /**
     * Semantic validation with "format"
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-00#section-7
     */

    get format() {
      return this.get('format');
    }
    set format(format) {
      this.set('format', format);
    }

    /**
     * JSON Hyper-Schema
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00
     */

    get base() {
      return this.get('base');
    }
    set base(base) {
      this.set('base', base);
    }
    get links() {
      return this.get('links');
    }
    set links(links) {
      this.set('links', links);
    }
    get media() {
      return this.get('media');
    }
    set media(media) {
      this.set('media', media);
    }
    get readOnly() {
      return this.get('readOnly');
    }
    set readOnly(readOnly) {
      this.set('readOnly', readOnly);
    }
  };

  /**
   * In Draft 4, $ref behaves a little differently. When an object contains a $ref property,
   * the object is considered a reference, not a schema. Therefore, any other properties you put in that object will
   * not be treated as JSON Schema keywords and will be ignored by the validator.
   * $ref can only be used where a schema is expected.
   *
   * URI: https://json-schema.org/understanding-json-schema/structuring.html?highlight=ref#id18
   * @public
   */

  class JSONReference extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'JSONReference';
      this.classes.push('json-reference');
    }
    get $ref() {
      return this.get('$ref');
    }
    set $ref($ref) {
      this.set('$ref', $ref);
    }
  }

  /**
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00#section-4.3
   * @public
   */

  class Media extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'media';
    }
    get binaryEncoding() {
      return this.get('binaryEncoding');
    }
    set binaryEncoding(binaryEncoding) {
      this.set('binaryEncoding', binaryEncoding);
    }
    get type() {
      return this.get('type');
    }
    set type(type) {
      this.set('type', type);
    }
  }

  /**
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00#section-5
   * @public
   */

  let LinkDescription$4 = class LinkDescription extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'linkDescription';
    }
    get href() {
      return this.get('href');
    }
    set href(href) {
      this.set('href', href);
    }
    get rel() {
      return this.get('rel');
    }
    set rel(rel) {
      this.set('rel', rel);
    }
    get title() {
      return this.get('title');
    }
    set title(title) {
      this.set('title', title);
    }
    get targetSchema() {
      return this.get('targetSchema');
    }
    set targetSchema(targetSchema) {
      this.set('targetSchema', targetSchema);
    }
    get mediaType() {
      return this.get('mediaType');
    }
    set mediaType(mediaType) {
      this.set('mediaType', mediaType);
    }
    get method() {
      return this.get('method');
    }
    set method(method) {
      this.set('method', method);
    }
    get encType() {
      return this.get('encType');
    }
    set encType(encType) {
      this.set('encType', encType);
    }
    get schema() {
      return this.get('schema');
    }
    set schema(schema) {
      this.set('schema', schema);
    }
  };

  /**
   * @public
   */
  const jsonSchemaDraft4 = {
    namespace: options => {
      const {
        base
      } = options;
      base.register('jSONSchemaDraft4', JSONSchema$4);
      base.register('jSONReference', JSONReference);
      base.register('media', Media);
      base.register('linkDescription', LinkDescription$4);
      return base;
    }
  };

  /**
   * @public
   */
  const getNodeType$2 = element => {
    if (!isElement(element)) {
      return undefined;
    }
    return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
  };

  /**
   * @public
   */
  const keyMap$6 = {
    JSONSchemaDraft4Element: ['content'],
    JSONReferenceElement: ['content'],
    MediaElement: ['content'],
    LinkDescriptionElement: ['content'],
    ...keyMapDefault$1
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let Visitor$1 = class Visitor {
    element;
    constructor(options) {
      Object.assign(this, options);
    }

    /* eslint-disable class-methods-use-this, no-param-reassign */
    copyMetaAndAttributes(from, to) {
      if (from.meta.length > 0 || to.meta.length > 0) {
        to.meta = deepmerge(to.meta, from.meta);
      }
      if (hasElementSourceMap(from)) {
        assignSourceMap(to, from);
      }
      if (from.attributes.length > 0 || from.meta.length > 0) {
        to.attributes = deepmerge(to.attributes, from.attributes);
      }
    }
    /* eslint-enable class-methods-use-this, no-param-reassign */
  };

  /**
   * This visitor is responsible for falling back to current traversed element
   * Given JSONSchemaVisitor expects ObjectElement to be traversed. If
   * different Element is provided FallBackVisitor is responsible to assigning
   * this Element as current element.
   * @public
   */
  /**
   * @public
   */
  let FallbackVisitor$1 = class FallbackVisitor extends Visitor$1 {
    enter(element) {
      this.element = cloneDeep(element);
      return BREAK;
    }
  };

  /**
   * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives
   * the option to exclude properties by name.
   */
  const copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
          delete props[prop];
      Object.defineProperties(dest, props);
  };
  /**
   * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will
   * be closest to farthest in the chain.
   */
  const protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
          return currentChain;
      return protoChain(proto, [...currentChain, proto]);
  };
  /**
   * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated
   * objects, this function should return Object.prototype.
   */
  const nearestCommonProto = (...objs) => {
      if (objs.length === 0)
          return undefined;
      let commonProto = undefined;
      const protoChains = objs.map(obj => protoChain(obj));
      while (protoChains.every(protoChain => protoChain.length > 0)) {
          const protos = protoChains.map(protoChain => protoChain.pop());
          const potentialCommonProto = protos[0];
          if (protos.every(proto => proto === potentialCommonProto))
              commonProto = potentialCommonProto;
          else
              break;
      }
      return commonProto;
  };
  /**
   * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first
   * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods
   * downstream of this prototype (ONLY downstream) are copied into the new object.
   *
   * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as
   * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may
   * want to use that instead.
   */
  const hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a;
      const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
      const mixedProto = Object.create(base);
      // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the
      // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in
      // when they will already be accessible via prototype access.
      const visitedProtos = protoChain(base);
      for (let prototype of ingredients) {
          let protos = protoChain(prototype);
          // Apply the prototype chain in reverse order so that old methods don't override newer ones.
          for (let i = protos.length - 1; i >= 0; i--) {
              let newProto = protos[i];
              if (visitedProtos.indexOf(newProto) === -1) {
                  copyProps(mixedProto, newProto, ['constructor', ...exclude]);
                  visitedProtos.push(newProto);
              }
          }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
  };
  const unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);

  // Keeps track of constituent classes for every mixin class created by ts-mixer.
  const mixins = new WeakMap();
  const getMixinsForClass = (clazz) => mixins.get(clazz);
  const registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);

  const mergeObjectsOfDecorators = (o1, o2) => {
      var _a, _b;
      const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
          mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);
      return mergedObject;
  };
  const mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a, _b, _c, _d;
      return ({
          property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
          method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),
      });
  };
  const mergeDecorators = (d1, d2) => {
      var _a, _b, _c, _d, _e, _f;
      return ({
          class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
          static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
          instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),
      });
  };
  const decorators = new Map();
  const findAllConstituentClasses = (...classes) => {
      var _a;
      const allClasses = new Set();
      const frontier = new Set([...classes]);
      while (frontier.size > 0) {
          for (let clazz of frontier) {
              const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);
              const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
              const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
              const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));
              for (let newClass of newClasses)
                  frontier.add(newClass);
              allClasses.add(clazz);
              frontier.delete(clazz);
          }
      }
      return [...allClasses];
  };
  const deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes)
          .map(clazz => decorators.get(clazz))
          .filter(decorators => !!decorators);
      if (decoratorsForClassChain.length == 0)
          return {};
      if (decoratorsForClassChain.length == 1)
          return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
  };

  function Mixin(...constructors) {
      var _a, _b, _c;
      const prototypes = constructors.map(constructor => constructor.prototype);
      function MixedClass(...args) {
          for (const constructor of constructors)
              // @ts-ignore: potentially abstract class
              copyProps(this, new constructor(...args));
      }
      MixedClass.prototype = hardMixProtos(prototypes, MixedClass)
          ;
      Object.setPrototypeOf(MixedClass, hardMixProtos(constructors, null, ['prototype'])
          );
      let DecoratedMixedClass = MixedClass;
      {
          const classDecorators = deepDecoratorSearch(...constructors)
              ;
          for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
              const result = decorator(DecoratedMixedClass);
              if (result) {
                  DecoratedMixedClass = result;
              }
          }
          applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
          applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
      }
      registerMixins(DecoratedMixedClass, constructors);
      return DecoratedMixedClass;
  }
  const applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
          for (let key in propDecorators)
              for (let decorator of propDecorators[key])
                  decorator(target, key);
      if (methodDecorators)
          for (let key in methodDecorators)
              for (let decorator of methodDecorators[key])
                  decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
  };

  /**
   * This is a base Type for every visitor that does
   * internal look-ups to retrieve other child visitors.
   * @public
   */
  /**
   * @public
   */
  let SpecificationVisitor$1 = class SpecificationVisitor extends Visitor$1 {
    specObj;
    passingOptionsNames = ['specObj', 'parent'];
    constructor({
      specObj,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specObj = specObj;
    }
    retrievePassingOptions() {
      return pick(this.passingOptionsNames, this);
    }
    retrieveFixedFields(specPath) {
      const fixedFields = path$1(['visitors', ...specPath, 'fixedFields'], this.specObj);
      if (typeof fixedFields === 'object' && fixedFields !== null) {
        return Object.keys(fixedFields);
      }
      return [];
    }
    retrieveVisitor(specPath) {
      if (pathSatisfies(isFunction, ['visitors', ...specPath], this.specObj)) {
        return path$1(['visitors', ...specPath], this.specObj);
      }
      return path$1(['visitors', ...specPath, '$visitor'], this.specObj);
    }
    retrieveVisitorInstance(specPath, options = {}) {
      const passingOpts = this.retrievePassingOptions();
      const VisitorClz = this.retrieveVisitor(specPath);
      const visitorOpts = {
        ...passingOpts,
        ...options
      };
      return new VisitorClz(visitorOpts);
    }
    toRefractedElement(specPath, element, options = {}) {
      /**
       * This is `Visitor shortcut`: mechanism for short-circuiting the traversal and replacing
       * it by basic node cloning.
       *
       * Visiting the element is equivalent to cloning it  if the prototype of a visitor
       * is the same as the prototype of FallbackVisitor. If that's the case, we can avoid
       * bootstrapping the traversal cycle for fields that don't require any special visiting.
       */
      const visitor = this.retrieveVisitorInstance(specPath, options);
      if (visitor instanceof FallbackVisitor$1 && (visitor === null || visitor === void 0 ? void 0 : visitor.constructor) === FallbackVisitor$1) {
        return cloneDeep(element);
      }
      visit$1(element, visitor, options);
      return visitor.element;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  let FixedFieldsVisitor$1 = class FixedFieldsVisitor extends SpecificationVisitor$1 {
    specPath;
    ignoredFields;
    constructor({
      specPath,
      ignoredFields,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specPath = specPath;
      this.ignoredFields = ignoredFields || [];
    }
    ObjectElement(objectElement) {
      const specPath = this.specPath(objectElement);
      const fields = this.retrieveFixedFields(specPath);

      // @ts-ignore
      objectElement.forEach((value, key, memberElement) => {
        if (isStringElement(key) && fields.includes(serializer(key)) && !this.ignoredFields.includes(serializer(key))) {
          const fixedFieldElement = this.toRefractedElement([...specPath, 'fixedFields', serializer(key)], value);
          const newMemberElement = new minimExports.MemberElement(cloneDeep(key), fixedFieldElement);
          this.copyMetaAndAttributes(memberElement, newMemberElement);
          newMemberElement.classes.push('fixed-field');
          this.element.content.push(newMemberElement);
        } else if (!this.ignoredFields.includes(serializer(key))) {
          this.element.content.push(cloneDeep(memberElement));
        }
      });
      this.copyMetaAndAttributes(objectElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  class ParentSchemaAwareVisitor {
    parent;
    constructor({
      parent
    }) {
      this.parent = parent;
    }
  }

  /**
   * @public
   */
  const isJSONSchemaElement$4 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof JSONSchema$4 || hasBasicElementProps(element) && isElementType('JSONSchemaDraft4', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isJSONReferenceElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof JSONReference || hasBasicElementProps(element) && isElementType('JSONReference', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isMediaElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Media || hasBasicElementProps(element) && isElementType('media', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLinkDescriptionElement$4 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof LinkDescription$4 || hasBasicElementProps(element) && isElementType('linkDescription', element) && primitiveEq('object', element);
  });

  const jsonSchemaDraft4Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isJSONReferenceElement,
    isJSONSchemaElement: isJSONSchemaElement$4,
    isLinkDescriptionElement: isLinkDescriptionElement$4,
    isMediaElement
  }, Symbol.toStringTag, { value: 'Module' }));

  /**
   * @public
   */
  /**
   * @public
   */
  let JSONSchemaVisitor$5 = class JSONSchemaVisitor extends Mixin(FixedFieldsVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new JSONSchema$4();
      this.specPath = always(['document', 'objects', 'JSONSchema']);
    }

    // eslint-disable-next-line class-methods-use-this
    get defaultDialectIdentifier() {
      return 'http://json-schema.org/draft-04/schema#';
    }
    ObjectElement(objectElement) {
      this.handleDialectIdentifier(objectElement);
      this.handleSchemaIdentifier(objectElement);

      // for further processing consider this JSONSchema Element as parent for all sub-schemas
      this.parent = this.element;
      return FixedFieldsVisitor$1.prototype.ObjectElement.call(this, objectElement);
    }
    handleDialectIdentifier(objectElement) {
      // handle $schema keyword in embedded resources
      if (isUndefined(this.parent) && !isStringElement(objectElement.get('$schema'))) {
        // no parent available and no $schema is defined, set default $schema
        this.element.setMetaProperty('inheritedDialectIdentifier', this.defaultDialectIdentifier);
      } else if (isJSONSchemaElement$4(this.parent) && !isStringElement(objectElement.get('$schema'))) {
        // parent is available and no $schema is defined, set parent $schema
        const inheritedDialectIdentifier = defaultTo(serializer(this.parent.meta.get('inheritedDialectIdentifier')), serializer(this.parent.$schema));
        this.element.setMetaProperty('inheritedDialectIdentifier', inheritedDialectIdentifier);
      }
    }
    handleSchemaIdentifier(objectElement, identifierKeyword = 'id') {
      // handle schema identifier in embedded resources
      // fetch parent's ancestorsSchemaIdentifiers
      const ancestorsSchemaIdentifiers = this.parent !== undefined ? cloneDeep(this.parent.getMetaProperty('ancestorsSchemaIdentifiers', [])) : new minimExports.ArrayElement();
      // get current schema identifier
      const schemaIdentifier = serializer(objectElement.get(identifierKeyword));

      // remember schema identifier if it's a non-empty strings
      if (isNonEmptyString(schemaIdentifier)) {
        ancestorsSchemaIdentifiers.push(schemaIdentifier);
      }
      this.element.setMetaProperty('ancestorsSchemaIdentifiers', ancestorsSchemaIdentifiers);
    }
  };

  /**
   * @public
   */

  // eslint-disable-next-line import/prefer-default-export
  /**
   * @public
   */
  const isJSONReferenceLikeElement = element => {
    return isObjectElement(element) && element.hasKey('$ref');
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ItemsVisitor$3 = class ItemsVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    ObjectElement(objectElement) {
      const specPath = isJSONReferenceLikeElement(objectElement) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
      this.element = this.toRefractedElement(specPath, objectElement);
      return BREAK;
    }
    ArrayElement(arrayElement) {
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-items');
      arrayElement.forEach(item => {
        const specPath = isJSONReferenceLikeElement(item) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  class RequiredVisitor extends FallbackVisitor$1 {
    ArrayElement(arrayElement) {
      const result = this.enter(arrayElement);
      this.element.classes.push('json-schema-required');
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let PatternedFieldsVisitor$1 = class PatternedFieldsVisitor extends SpecificationVisitor$1 {
    specPath;
    ignoredFields;
    fieldPatternPredicate = F;
    constructor({
      specPath,
      ignoredFields,
      fieldPatternPredicate,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specPath = specPath;
      this.ignoredFields = ignoredFields || [];
      if (typeof fieldPatternPredicate === 'function') {
        this.fieldPatternPredicate = fieldPatternPredicate;
      }
    }
    ObjectElement(objectElement) {
      // @ts-ignore
      objectElement.forEach((value, key, memberElement) => {
        if (!this.ignoredFields.includes(serializer(key)) && this.fieldPatternPredicate(serializer(key))) {
          const specPath = this.specPath(value);
          const patternedFieldElement = this.toRefractedElement(specPath, value);
          const newMemberElement = new minimExports.MemberElement(cloneDeep(key), patternedFieldElement);
          this.copyMetaAndAttributes(memberElement, newMemberElement);
          newMemberElement.classes.push('patterned-field');
          this.element.content.push(newMemberElement);
        } else if (!this.ignoredFields.includes(serializer(key))) {
          this.element.content.push(cloneDeep(memberElement));
        }
      });
      this.copyMetaAndAttributes(objectElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let MapVisitor$1 = class MapVisitor extends PatternedFieldsVisitor$1 {
    constructor(options) {
      super(options);
      this.fieldPatternPredicate = isNonEmptyString;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let PropertiesVisitor$3 = class PropertiesVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-properties');
      this.specPath = element => isJSONReferenceLikeElement(element) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let PatternPropertiesVisitor$2 = class PatternPropertiesVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-patternProperties');
      this.specPath = element => isJSONReferenceLikeElement(element) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class DependenciesVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-dependencies');
      this.specPath = element => isJSONReferenceLikeElement(element) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
    }
  }

  /**
   * @public
   */
  class EnumVisitor extends FallbackVisitor$1 {
    ArrayElement(arrayElement) {
      const result = this.enter(arrayElement);
      this.element.classes.push('json-schema-enum');
      return result;
    }
  }

  /**
   * @public
   */
  let TypeVisitor$1 = class TypeVisitor extends FallbackVisitor$1 {
    StringElement(stringElement) {
      const result = this.enter(stringElement);
      this.element.classes.push('json-schema-type');
      return result;
    }
    ArrayElement(arrayElement) {
      const result = this.enter(arrayElement);
      this.element.classes.push('json-schema-type');
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let AllOfVisitor$3 = class AllOfVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-allOf');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isJSONReferenceLikeElement(item) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let AnyOfVisitor$3 = class AnyOfVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-anyOf');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isJSONReferenceLikeElement(item) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let OneOfVisitor$3 = class OneOfVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-oneOf');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isJSONReferenceLikeElement(item) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class DefinitionsVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-definitions');
      this.specPath = element => isJSONReferenceLikeElement(element) ? ['document', 'objects', 'JSONReference'] : ['document', 'objects', 'JSONSchema'];
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let LinksVisitor$2 = class LinksVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-links');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const linkDescriptionElement = this.toRefractedElement(['document', 'objects', 'LinkDescription'], item);
        this.element.push(linkDescriptionElement);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class JSONReferenceVisitor extends Mixin(FixedFieldsVisitor$1, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new JSONReference();
      this.specPath = always(['document', 'objects', 'JSONReference']);
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor$1.prototype.ObjectElement.call(this, objectElement);

      // mark this JSONReferenceElement with reference metadata
      if (isStringElement(this.element.$ref)) {
        this.element.classes.push('reference-element');
      }
      return result;
    }
  }

  /**
   * @public
   */
  let $RefVisitor$2 = class $RefVisitor extends FallbackVisitor$1 {
    StringElement(stringElement) {
      const result = this.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  let AlternatingVisitor$1 = class AlternatingVisitor extends SpecificationVisitor$1 {
    alternator;
    constructor({
      alternator,
      ...rest
    }) {
      super({
        ...rest
      });
      this.alternator = alternator;
    }
    enter(element) {
      const functions = this.alternator.map(({
        predicate,
        specPath
      }) => ifElse(predicate, always(specPath), stubUndefined));
      const specPath = dispatch(functions)(element);
      this.element = this.toRefractedElement(specPath, element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  let SchemaOrReferenceVisitor$1 = class SchemaOrReferenceVisitor extends AlternatingVisitor$1 {
    constructor(options) {
      super(options);
      this.alternator = [{
        predicate: isJSONReferenceLikeElement,
        specPath: ['document', 'objects', 'JSONReference']
      }, {
        predicate: T,
        specPath: ['document', 'objects', 'JSONSchema']
      }];
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class MediaVisitor extends Mixin(FixedFieldsVisitor$1, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new Media();
      this.specPath = always(['document', 'objects', 'Media']);
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let LinkDescriptionVisitor$5 = class LinkDescriptionVisitor extends Mixin(FixedFieldsVisitor$1, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new LinkDescription$4();
      this.specPath = always(['document', 'objects', 'LinkDescription']);
    }
  };

  /**
   * Specification object allows us to have complete control over visitors
   * when traversing the ApiDOM.
   * Specification also allows us to create amended refractors from
   * existing ones by manipulating it.
   *
   * Note: Specification object allows to use absolute internal JSON pointers.
   * @public
   */
  const specification$6 = {
    visitors: {
      value: FallbackVisitor$1,
      JSONSchemaOrJSONReferenceVisitor: SchemaOrReferenceVisitor$1,
      document: {
        objects: {
          JSONSchema: {
            $visitor: JSONSchemaVisitor$5,
            fixedFields: {
              // core vocabulary
              id: {
                $ref: '#/visitors/value'
              },
              $schema: {
                $ref: '#/visitors/value'
              },
              // validation vocabulary
              // validation keywords for numeric instances (number and integer)
              multipleOf: {
                $ref: '#/visitors/value'
              },
              maximum: {
                $ref: '#/visitors/value'
              },
              exclusiveMaximum: {
                $ref: '#/visitors/value'
              },
              minimum: {
                $ref: '#/visitors/value'
              },
              exclusiveMinimum: {
                $ref: '#/visitors/value'
              },
              // validation keywords for strings
              maxLength: {
                $ref: '#/visitors/value'
              },
              minLength: {
                $ref: '#/visitors/value'
              },
              pattern: {
                $ref: '#/visitors/value'
              },
              // validation keywords for arrays
              additionalItems: SchemaOrReferenceVisitor$1,
              items: ItemsVisitor$3,
              maxItems: {
                $ref: '#/visitors/value'
              },
              minItems: {
                $ref: '#/visitors/value'
              },
              uniqueItems: {
                $ref: '#/visitors/value'
              },
              // validation keywords for objects
              maxProperties: {
                $ref: '#/visitors/value'
              },
              minProperties: {
                $ref: '#/visitors/value'
              },
              required: RequiredVisitor,
              properties: PropertiesVisitor$3,
              additionalProperties: SchemaOrReferenceVisitor$1,
              patternProperties: PatternPropertiesVisitor$2,
              dependencies: DependenciesVisitor,
              // validation keywords for any instance type
              enum: EnumVisitor,
              type: TypeVisitor$1,
              allOf: AllOfVisitor$3,
              anyOf: AnyOfVisitor$3,
              oneOf: OneOfVisitor$3,
              not: SchemaOrReferenceVisitor$1,
              definitions: DefinitionsVisitor,
              // metadata keywords
              title: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              default: {
                $ref: '#/visitors/value'
              },
              // semantic validation with "format"
              format: {
                $ref: '#/visitors/value'
              },
              // JSON Hyper-Schema
              base: {
                $ref: '#/visitors/value'
              },
              links: LinksVisitor$2,
              media: {
                $ref: '#/visitors/document/objects/Media'
              },
              readOnly: {
                $ref: '#/visitors/value'
              }
            }
          },
          JSONReference: {
            $visitor: JSONReferenceVisitor,
            fixedFields: {
              $ref: $RefVisitor$2
            }
          },
          Media: {
            $visitor: MediaVisitor,
            fixedFields: {
              binaryEncoding: {
                $ref: '#/visitors/value'
              },
              type: {
                $ref: '#/visitors/value'
              }
            }
          },
          LinkDescription: {
            $visitor: LinkDescriptionVisitor$5,
            fixedFields: {
              href: {
                $ref: '#/visitors/value'
              },
              rel: {
                $ref: '#/visitors/value'
              },
              title: {
                $ref: '#/visitors/value'
              },
              targetSchema: SchemaOrReferenceVisitor$1,
              mediaType: {
                $ref: '#/visitors/value'
              },
              method: {
                $ref: '#/visitors/value'
              },
              encType: {
                $ref: '#/visitors/value'
              },
              schema: SchemaOrReferenceVisitor$1
            }
          }
        }
      }
    }
  };

  const createToolbox$6 = () => {
    const namespace = createNamespace(jsonSchemaDraft4);
    const predicates = {
      ...jsonSchemaDraft4Predicates,
      isStringElement
    };
    return {
      predicates,
      namespace
    };
  };

  /**
   * @public
   */
  const refract$5 = (value, {
    specPath = ['visitors', 'document', 'objects', 'JSONSchema', '$visitor'],
    plugins = [],
    specificationObj = specification$6
  } = {}) => {
    const element = minimExports.refract(value);
    const resolvedSpec = dereference(specificationObj);

    /**
     * This is where generic ApiDOM becomes semantic (namespace applied).
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const RootVisitorClass = path$1(specPath, resolvedSpec);
    const rootVisitor = new RootVisitorClass({
      specObj: resolvedSpec
    });
    visit$1(element, rootVisitor);

    /**
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(rootVisitor.element, plugins, {
      toolboxCreator: createToolbox$6,
      visitorOptions: {
        keyMap: keyMap$6,
        nodeTypeGetter: getNodeType$2
      }
    });
  };

  /**
   * @public
   */
  const createRefractor$5 = specPath => (value, options = {}) => refract$5(value, {
    specPath,
    ...options
  });

  JSONSchema$4.refract = createRefractor$5(['visitors', 'document', 'objects', 'JSONSchema', '$visitor']);
  JSONReference.refract = createRefractor$5(['visitors', 'document', 'objects', 'JSONReference', '$visitor']);
  Media.refract = createRefractor$5(['visitors', 'document', 'objects', 'Media', '$visitor']);
  LinkDescription$4.refract = createRefractor$5(['visitors', 'document', 'objects', 'LinkDescription', '$visitor']);

  /* eslint-disable class-methods-use-this */
  /**
   * @public
   */
  let Schema$1 = class Schema extends JSONSchema$4 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'schema';
      this.classes.push('json-schema-draft-4');
    }

    /**
     * Core vocabulary
     *
     * URI: https://tools.ietf.org/html/draft-wright-json-schema-00
     */
    get idProp() {
      throw new UnsupportedOperationError('idProp getter in Schema class is not not supported.');
    }
    set idProp(idProps) {
      throw new UnsupportedOperationError('idProp setter in Schema class is not not supported.');
    }
    get $schema() {
      throw new UnsupportedOperationError('$schema getter in Schema class is not not supported.');
    }
    set $schema($schema) {
      throw new UnsupportedOperationError('$schema setter in Schema class is not not supported.');
    }

    /**
     * Validation keywords for arrays
     */

    get additionalItems() {
      return this.get('additionalItems');
    }
    set additionalItems(additionalItems) {
      this.set('additionalItems', additionalItems);
    }
    get items() {
      return this.get('items');
    }
    set items(items) {
      this.set('items', items);
    }

    /**
     * Validation keywords for objects
     */

    get additionalProperties() {
      return this.get('additionalProperties');
    }
    set additionalProperties(additionalProperties) {
      this.set('additionalProperties', additionalProperties);
    }
    get patternProperties() {
      throw new UnsupportedOperationError('patternProperties getter in Schema class is not not supported.');
    }
    set patternProperties(patternProperties) {
      throw new UnsupportedOperationError('patternProperties setter in Schema class is not not supported.');
    }
    get dependencies() {
      throw new UnsupportedOperationError('dependencies getter in Schema class is not not supported.');
    }
    set dependencies(dependencies) {
      throw new UnsupportedOperationError('dependencies setter in Schema class is not not supported.');
    }

    /**
     *  Validation keywords for any instance type
     */

    get type() {
      return this.get('type');
    }
    set type(type) {
      this.set('type', type);
    }
    get not() {
      return this.get('not');
    }
    set not(not) {
      this.set('not', not);
    }
    get definitions() {
      throw new UnsupportedOperationError('definitions getter in Schema class is not not supported.');
    }
    set definitions(definitions) {
      throw new UnsupportedOperationError('definitions setter in Schema class is not not supported.');
    }

    /**
     * JSON Hyper-Schema
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00
     */

    get base() {
      throw new UnsupportedOperationError('base getter in Schema class is not not supported.');
    }
    set base(base) {
      throw new UnsupportedOperationError('base setter in Schema class is not not supported.');
    }
    get links() {
      throw new UnsupportedOperationError('links getter in Schema class is not not supported.');
    }
    set links(links) {
      throw new UnsupportedOperationError('links setter in Schema class is not not supported.');
    }
    get media() {
      throw new UnsupportedOperationError('media getter in Schema class is not not supported.');
    }
    set media(media) {
      throw new UnsupportedOperationError('media setter in Schema class is not not supported.');
    }

    /**
     * OpenAPI vocabulary
     */

    get nullable() {
      return this.get('nullable');
    }
    set nullable(nullable) {
      this.set('nullable', nullable);
    }
    get discriminator() {
      return this.get('discriminator');
    }
    set discriminator(discriminator) {
      this.set('discriminator', discriminator);
    }
    get writeOnly() {
      return this.get('writeOnly');
    }
    set writeOnly(writeOnly) {
      this.set('writeOnly', writeOnly);
    }
    get xml() {
      return this.get('xml');
    }
    set xml(xml) {
      this.set('xml', xml);
    }
    get externalDocs() {
      return this.get('externalDocs');
    }
    set externalDocs(externalDocs) {
      this.set('externalDocs', externalDocs);
    }
    get example() {
      return this.get('example');
    }
    set example(example) {
      this.set('example', example);
    }
    get deprecated() {
      return this.get('deprecated');
    }
    set deprecated(deprecated) {
      this.set('deprecated', deprecated);
    }
  };

  /**
   * @public
   */
  let SecurityRequirement$1 = class SecurityRequirement extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'securityRequirement';
    }
  };

  /**
   * @public
   */
  let SecurityScheme$1 = class SecurityScheme extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'securityScheme';
    }
    get type() {
      return this.get('type');
    }
    set type(type) {
      this.set('type', type);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get name() {
      return this.get('name');
    }
    set name(name) {
      this.set('name', name);
    }
    get in() {
      return this.get('in');
    }
    set in(inVal) {
      this.set('in', inVal);
    }
    get scheme() {
      return this.get('scheme');
    }
    set scheme(scheme) {
      this.set('scheme', scheme);
    }
    get bearerFormat() {
      return this.get('bearerFormat');
    }
    set bearerFormat(bearerFormat) {
      this.set('bearerFormat', bearerFormat);
    }
    get flows() {
      return this.get('flows');
    }
    set flows(flows) {
      this.set('flows', flows);
    }
    get openIdConnectUrl() {
      return this.get('openIdConnectUrl');
    }
    set openIdConnectUrl(openIdConnectUrl) {
      this.set('openIdConnectUrl', openIdConnectUrl);
    }
  };

  /**
   * @public
   */
  let Server$1 = class Server extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'server';
    }
    get url() {
      return this.get('url');
    }
    set url(url) {
      this.set('url', url);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get variables() {
      return this.get('variables');
    }
    set variables(variables) {
      this.set('variables', variables);
    }
  };

  /**
   * @public
   */
  let ServerVariable$1 = class ServerVariable extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'serverVariable';
    }
    get enum() {
      return this.get('enum');
    }
    set enum(value) {
      this.set('enum', value);
    }
    get default() {
      return this.get('default');
    }
    set default(value) {
      this.set('default', value);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
  };

  /**
   * @public
   */
  let Tag$1 = class Tag extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'tag';
    }
    get name() {
      return this.get('name');
    }
    set name(name) {
      this.set('name', name);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get externalDocs() {
      return this.get('externalDocs');
    }
    set externalDocs(externalDocs) {
      this.set('externalDocs', externalDocs);
    }
  };

  /**
   * @public
   */
  let Xml$1 = class Xml extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'xml';
    }
    get name() {
      return this.get('name');
    }
    set name(name) {
      this.set('name', name);
    }
    get namespace() {
      return this.get('namespace');
    }
    set namespace(namespace) {
      this.set('namespace', namespace);
    }
    get prefix() {
      return this.get('prefix');
    }
    set prefix(prefix) {
      this.set('prefix', prefix);
    }
    get attribute() {
      return this.get('attribute');
    }
    set attribute(attribute) {
      this.set('attribute', attribute);
    }
    get wrapped() {
      return this.get('wrapped');
    }
    set wrapped(wrapped) {
      this.set('wrapped', wrapped);
    }
  };

  /**
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const openApi3_0 = {
    namespace: options => {
      const {
        base
      } = options;
      base.register('callback', Callback$1);
      base.register('components', Components$1);
      base.register('contact', Contact$1);
      base.register('discriminator', Discriminator$1);
      base.register('encoding', Encoding$1);
      base.register('example', Example$1);
      base.register('externalDocumentation', ExternalDocumentation$1);
      base.register('header', Header$1);
      base.register('info', Info$1);
      base.register('license', License$1);
      base.register('link', Link$1);
      base.register('mediaType', MediaType$1);
      base.register('oAuthFlow', OAuthFlow$1);
      base.register('oAuthFlows', OAuthFlows$1);
      base.register('openapi', Openapi$1);
      base.register('openApi3_0', OpenApi3_0);
      base.register('operation', Operation$1);
      base.register('parameter', Parameter$1);
      base.register('pathItem', PathItem$1);
      base.register('paths', Paths$1);
      base.register('reference', Reference$1);
      base.register('requestBody', RequestBody$1);
      base.register('response', Response$1);
      base.register('responses', Responses$1);
      base.register('schema', Schema$1);
      base.register('securityRequirement', SecurityRequirement$1);
      base.register('securityScheme', SecurityScheme$1);
      base.register('server', Server$1);
      base.register('serverVariable', ServerVariable$1);
      base.register('tag', Tag$1);
      base.register('xml', Xml$1);
      return base;
    }
  };

  /**
   * @public
   */
  class Servers extends minimExports.ArrayElement {
    static primaryClass = 'servers';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(Servers.primaryClass);
    }
  }

  /**
   * @public
   */
  class Security extends minimExports.ArrayElement {
    static primaryClass = 'security';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(Security.primaryClass);
    }
  }

  /**
   * @public
   */
  class Tags extends minimExports.ArrayElement {
    static primaryClass = 'tags';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(Tags.primaryClass);
    }
  }

  /**
   * @public
   */
  class ServerVariables extends minimExports.ObjectElement {
    static primaryClass = 'server-variables';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ServerVariables.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsSchemas extends minimExports.ObjectElement {
    static primaryClass = 'components-schemas';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsSchemas.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsResponses extends minimExports.ObjectElement {
    static primaryClass = 'components-responses';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsResponses.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsParameters extends minimExports.ObjectElement {
    static primaryClass = 'components-parameters';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsParameters.primaryClass);
      this.classes.push('parameters');
    }
  }

  /**
   * @public
   */
  class ComponentsExamples extends minimExports.ObjectElement {
    static primaryClass = 'components-examples';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsExamples.primaryClass);
      this.classes.push('examples');
    }
  }

  /**
   * @public
   */
  class ComponentsRequestBodies extends minimExports.ObjectElement {
    static primaryClass = 'components-request-bodies';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsRequestBodies.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsHeaders extends minimExports.ObjectElement {
    static primaryClass = 'components-headers';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsHeaders.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsSecuritySchemes extends minimExports.ObjectElement {
    static primaryClass = 'components-security-schemes';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsSecuritySchemes.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsLinks extends minimExports.ObjectElement {
    static primaryClass = 'components-links';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsLinks.primaryClass);
    }
  }

  /**
   * @public
   */
  class ComponentsCallbacks extends minimExports.ObjectElement {
    static primaryClass = 'components-callbacks';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ComponentsCallbacks.primaryClass);
    }
  }

  /**
   * @public
   */
  class PathItemServers extends minimExports.ArrayElement {
    static primaryClass = 'path-item-servers';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(PathItemServers.primaryClass);
      this.classes.push('servers');
    }
  }

  /**
   * @public
   */
  class PathItemParameters extends minimExports.ArrayElement {
    static primaryClass = 'path-item-parameters';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(PathItemParameters.primaryClass);
      this.classes.push('parameters');
    }
  }

  /**
   * @public
   */
  class OperationParameters extends minimExports.ArrayElement {
    static primaryClass = 'operation-parameters';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(OperationParameters.primaryClass);
      this.classes.push('parameters');
    }
  }

  /**
   * @public
   */
  class ParameterExamples extends minimExports.ObjectElement {
    static primaryClass = 'parameter-examples';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ParameterExamples.primaryClass);
      this.classes.push('examples');
    }
  }

  /**
   * @public
   */
  class ParameterContent extends minimExports.ObjectElement {
    static primaryClass = 'parameter-content';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ParameterContent.primaryClass);
      this.classes.push('content');
    }
  }

  /**
   * @public
   */
  class OperationTags extends minimExports.ArrayElement {
    static primaryClass = 'operation-tags';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(OperationTags.primaryClass);
    }
  }

  /**
   * @public
   */
  class OperationCallbacks extends minimExports.ObjectElement {
    static primaryClass = 'operation-callbacks';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(OperationCallbacks.primaryClass);
    }
  }

  /**
   * @public
   */
  class OperationSecurity extends minimExports.ArrayElement {
    static primaryClass = 'operation-security';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(OperationSecurity.primaryClass);
      this.classes.push('security');
    }
  }

  /**
   * @public
   */
  class OperationServers extends minimExports.ArrayElement {
    static primaryClass = 'operation-servers';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(OperationServers.primaryClass);
      this.classes.push('servers');
    }
  }

  /**
   * @public
   */
  class RequestBodyContent extends minimExports.ObjectElement {
    static primaryClass = 'request-body-content';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(RequestBodyContent.primaryClass);
      this.classes.push('content');
    }
  }

  /**
   * @public
   */
  class MediaTypeExamples extends minimExports.ObjectElement {
    static primaryClass = 'media-type-examples';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(MediaTypeExamples.primaryClass);
      this.classes.push('examples');
    }
  }

  /**
   * @public
   */
  class MediaTypeEncoding extends minimExports.ObjectElement {
    static primaryClass = 'media-type-encoding';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(MediaTypeEncoding.primaryClass);
    }
  }

  /**
   * @public
   */
  class EncodingHeaders extends minimExports.ObjectElement {
    static primaryClass = 'encoding-headers';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(EncodingHeaders.primaryClass);
    }
  }

  /**
   * @public
   */
  class ResponseHeaders extends minimExports.ObjectElement {
    static primaryClass = 'response-headers';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ResponseHeaders.primaryClass);
    }
  }

  /**
   * @public
   */
  class ResponseContent extends minimExports.ObjectElement {
    static primaryClass = 'response-content';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ResponseContent.primaryClass);
      this.classes.push('content');
    }
  }

  /**
   * @public
   */
  class ResponseLinks extends minimExports.ObjectElement {
    static primaryClass = 'response-links';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(ResponseLinks.primaryClass);
    }
  }

  /**
   * @public
   */
  class DiscriminatorMapping extends minimExports.ObjectElement {
    static primaryClass = 'discriminator-mapping';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(DiscriminatorMapping.primaryClass);
    }
  }

  /**
   * @public
   */
  class OAuthFlowScopes extends minimExports.ObjectElement {
    static primaryClass = 'oauth-flow-scopes';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(OAuthFlowScopes.primaryClass);
    }
  }

  /**
   * @public
   */
  class LinkParameters extends minimExports.ObjectElement {
    static primaryClass = 'link-parameters';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(LinkParameters.primaryClass);
    }
  }

  /**
   * @public
   */
  class HeaderExamples extends minimExports.ObjectElement {
    static primaryClass = 'header-examples';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(HeaderExamples.primaryClass);
      this.classes.push('examples');
    }
  }

  /**
   * @public
   */
  class HeaderContent extends minimExports.ObjectElement {
    static primaryClass = 'header-content';
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(HeaderContent.primaryClass);
      this.classes.push('content');
    }
  }

  /**
   * @public
   */
  const getNodeType$1 = element => {
    if (!isElement(element)) {
      return undefined;
    }
    return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
  };

  /**
   * There are unfortunately two `LinkElement` types. One is from base namespace
   * and the other one if from this namespace. `LinkElement` from base namespace
   * is used extremely rarely, so it's almost always safe during traversing
   * to assume that `LinkElement` is element from this namespace.
   *
   * To be 100% sure that currently visiting `LinkElement` is from this namespace
   * use `isLinkElement` predicate from this namespace to assert for it.
   * @public
   */

  const keyMap$5 = {
    CallbackElement: ['content'],
    ComponentsElement: ['content'],
    ContactElement: ['content'],
    DiscriminatorElement: ['content'],
    Encoding: ['content'],
    Example: ['content'],
    ExternalDocumentationElement: ['content'],
    HeaderElement: ['content'],
    InfoElement: ['content'],
    LicenseElement: ['content'],
    MediaTypeElement: ['content'],
    OAuthFlowElement: ['content'],
    OAuthFlowsElement: ['content'],
    OpenApi3_0Element: ['content'],
    OperationElement: ['content'],
    ParameterElement: ['content'],
    PathItemElement: ['content'],
    PathsElement: ['content'],
    ReferenceElement: ['content'],
    RequestBodyElement: ['content'],
    ResponseElement: ['content'],
    ResponsesElement: ['content'],
    SchemaElement: ['content'],
    SecurityRequirementElement: ['content'],
    SecuritySchemeElement: ['content'],
    ServerElement: ['content'],
    ServerVariableElement: ['content'],
    TagElement: ['content'],
    ...keyMapDefault$1
  };

  /**
   * @public
   */

  /**
   * @public
   */
  class Visitor {
    element;
    constructor(options = {}) {
      Object.assign(this, options);
    }

    /* eslint-disable class-methods-use-this, no-param-reassign */
    copyMetaAndAttributes(from, to) {
      if (from.meta.length > 0 || to.meta.length > 0) {
        to.meta = deepmerge(to.meta, from.meta);
      }
      if (hasElementSourceMap(from)) {
        assignSourceMap(to, from);
      }
      if (from.attributes.length > 0 || from.meta.length > 0) {
        to.attributes = deepmerge(to.attributes, from.attributes); // eslint-disable-line no-param-reassign
      }
    }
    /* eslint-enable class-methods-use-this, no-param-reassign */
  }

  /**
   * This visitor is responsible for falling back to current traversed element
   * Given OpenApi3_0Visitor expects ObjectElement to be traversed. If
   * different Element is provided FallBackVisitor is responsible to assigning
   * this Element as current element.
   */
  /**
   * @public
   */
  class FallbackVisitor extends Visitor {
    enter(element) {
      this.element = cloneDeep(element);
      return BREAK;
    }
  }

  /**
   * This is a base Type for every visitor that does
   * internal look-ups to retrieve other child visitors.
   * @public
   */
  /**
   * @public
   */
  class SpecificationVisitor extends Visitor {
    specObj;
    passingOptionsNames = ['specObj', 'openApiGenericElement', 'openApiSemanticElement'];
    openApiGenericElement;
    openApiSemanticElement;
    constructor({
      specObj,
      passingOptionsNames,
      openApiGenericElement,
      openApiSemanticElement,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specObj = specObj;
      this.openApiGenericElement = openApiGenericElement;
      this.openApiSemanticElement = openApiSemanticElement;
      if (Array.isArray(passingOptionsNames)) {
        this.passingOptionsNames = passingOptionsNames;
      }
    }
    retrievePassingOptions() {
      return pick(this.passingOptionsNames, this);
    }
    retrieveFixedFields(specPath) {
      const fixedFields = path$1(['visitors', ...specPath, 'fixedFields'], this.specObj);
      if (typeof fixedFields === 'object' && fixedFields !== null) {
        return Object.keys(fixedFields);
      }
      return [];
    }
    retrieveVisitor(specPath) {
      if (pathSatisfies(isFunction, ['visitors', ...specPath], this.specObj)) {
        return path$1(['visitors', ...specPath], this.specObj);
      }
      return path$1(['visitors', ...specPath, '$visitor'], this.specObj);
    }
    retrieveVisitorInstance(specPath, options = {}) {
      const passingOpts = this.retrievePassingOptions();
      const VisitorClz = this.retrieveVisitor(specPath);
      const visitorOpts = {
        ...passingOpts,
        ...options
      };
      return new VisitorClz(visitorOpts);
    }
    toRefractedElement(specPath, element, options = {}) {
      /**
       * This is `Visitor shortcut`: mechanism for short-circuiting the traversal and replacing
       * it by basic node cloning.
       *
       * Visiting the element is equivalent to cloning it  if the prototype of a visitor
       * is the same as the prototype of FallbackVisitor. If that's the case, we can avoid
       * bootstrapping the traversal cycle for fields that don't require any special visiting.
       */
      const visitor = this.retrieveVisitorInstance(specPath, options);
      if (visitor instanceof FallbackVisitor && (visitor === null || visitor === void 0 ? void 0 : visitor.constructor) === FallbackVisitor) {
        return cloneDeep(element);
      }
      visit$1(element, visitor, options);
      return visitor.element;
    }
  }

  /**
   * @public
   */

  /**
   * @public
   */
  const isReferenceLikeElement = element => {
    return isObjectElement(element) && element.hasKey('$ref');
  };

  /**
   * @public
   */
  const isServerLikeElement = isObjectElement;

  /**
   * @public
   */
  const isTagLikeElement = isObjectElement;

  /**
   * @public
   */
  const isOpenApiExtension = element => {
    // @ts-ignore
    return isStringElement(element.key) && startsWith('x-', serializer(element.key));
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  class FixedFieldsVisitor extends SpecificationVisitor {
    specPath;
    ignoredFields;
    canSupportSpecificationExtensions = true;
    specificationExtensionPredicate = isOpenApiExtension;
    constructor({
      specPath,
      ignoredFields,
      canSupportSpecificationExtensions,
      specificationExtensionPredicate,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specPath = specPath;
      this.ignoredFields = ignoredFields || [];
      if (typeof canSupportSpecificationExtensions === 'boolean') {
        this.canSupportSpecificationExtensions = canSupportSpecificationExtensions;
      }
      if (typeof specificationExtensionPredicate === 'function') {
        this.specificationExtensionPredicate = specificationExtensionPredicate;
      }
    }
    ObjectElement(objectElement) {
      const specPath = this.specPath(objectElement);
      const fields = this.retrieveFixedFields(specPath);

      // @ts-ignore
      objectElement.forEach((value, key, memberElement) => {
        if (isStringElement(key) && fields.includes(serializer(key)) && !this.ignoredFields.includes(serializer(key))) {
          const fixedFieldElement = this.toRefractedElement([...specPath, 'fixedFields', serializer(key)], value);
          const newMemberElement = new minimExports.MemberElement(cloneDeep(key), fixedFieldElement);
          this.copyMetaAndAttributes(memberElement, newMemberElement);
          newMemberElement.classes.push('fixed-field');
          this.element.content.push(newMemberElement);
        } else if (this.canSupportSpecificationExtensions && this.specificationExtensionPredicate(memberElement)) {
          const extensionElement = this.toRefractedElement(['document', 'extension'], memberElement);
          this.element.content.push(extensionElement);
        } else if (!this.ignoredFields.includes(serializer(key))) {
          this.element.content.push(cloneDeep(memberElement));
        }
      });
      this.copyMetaAndAttributes(objectElement, this.element);
      return BREAK;
    }
  }

  /**
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  /**
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  class OpenApi3_0Visitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new OpenApi3_0();
      this.specPath = always(['document', 'objects', 'OpenApi']);
      this.canSupportSpecificationExtensions = true;
    }
    ObjectElement(objectElement) {
      return FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class OpenapiVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    StringElement(stringElement) {
      const openapiElement = new Openapi$1(serializer(stringElement));
      this.copyMetaAndAttributes(stringElement, openapiElement);
      this.element = openapiElement;
      return BREAK;
    }
  }

  /**
   * @public
   */
  class SpecificationExtensionVisitor extends SpecificationVisitor {
    MemberElement(memberElement) {
      this.element = cloneDeep(memberElement);
      this.element.classes.push('specification-extension');
      return BREAK;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let InfoVisitor$1 = class InfoVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Info$1();
      this.specPath = always(['document', 'objects', 'Info']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  class VersionVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('api-version');
      this.element.classes.push('version');
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let ContactVisitor$1 = class ContactVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Contact$1();
      this.specPath = always(['document', 'objects', 'Contact']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let LicenseVisitor$1 = class LicenseVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new License$1();
      this.specPath = always(['document', 'objects', 'License']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let LinkVisitor$1 = class LinkVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Link$1();
      this.specPath = always(['document', 'objects', 'Link']);
      this.canSupportSpecificationExtensions = true;
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // mark this LinkElement with reference metadata
      if (isStringElement(this.element.operationId) || isStringElement(this.element.operationRef)) {
        this.element.classes.push('reference-element');
      }
      return result;
    }
  };

  /**
   * @public
   */
  class OperationRefVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  }

  /**
   * @public
   */
  class OperationIdVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class PatternedFieldsVisitor extends SpecificationVisitor {
    specPath;
    ignoredFields;
    fieldPatternPredicate = F;
    canSupportSpecificationExtensions = false;
    specificationExtensionPredicate = isOpenApiExtension;
    constructor({
      specPath,
      ignoredFields,
      fieldPatternPredicate,
      canSupportSpecificationExtensions,
      specificationExtensionPredicate,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specPath = specPath;
      this.ignoredFields = ignoredFields || [];
      if (typeof fieldPatternPredicate === 'function') {
        this.fieldPatternPredicate = fieldPatternPredicate;
      }
      if (typeof canSupportSpecificationExtensions === 'boolean') {
        this.canSupportSpecificationExtensions = canSupportSpecificationExtensions;
      }
      if (typeof specificationExtensionPredicate === 'function') {
        this.specificationExtensionPredicate = specificationExtensionPredicate;
      }
    }
    ObjectElement(objectElement) {
      // @ts-ignore
      objectElement.forEach((value, key, memberElement) => {
        if (this.canSupportSpecificationExtensions && this.specificationExtensionPredicate(memberElement)) {
          const extensionElement = this.toRefractedElement(['document', 'extension'], memberElement);
          this.element.content.push(extensionElement);
        } else if (!this.ignoredFields.includes(serializer(key)) && this.fieldPatternPredicate(serializer(key))) {
          const specPath = this.specPath(value);
          const patternedFieldElement = this.toRefractedElement(specPath, value);
          const newMemberElement = new minimExports.MemberElement(cloneDeep(key), patternedFieldElement);
          this.copyMetaAndAttributes(memberElement, newMemberElement);
          newMemberElement.classes.push('patterned-field');
          this.element.content.push(newMemberElement);
        } else if (!this.ignoredFields.includes(serializer(key))) {
          this.element.content.push(cloneDeep(memberElement));
        }
      });
      this.copyMetaAndAttributes(objectElement, this.element);
      return BREAK;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class MapVisitor extends PatternedFieldsVisitor {
    constructor(options) {
      super(options);
      this.fieldPatternPredicate = isNonEmptyString;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let ParametersVisitor$4 = class ParametersVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new LinkParameters();
      this.specPath = always(['value']);
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ServerVisitor$1 = class ServerVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Server$1();
      this.specPath = always(['document', 'objects', 'Server']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  class UrlVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('server-url');
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let ServersVisitor$2 = class ServersVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Servers();
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isServerLikeElement(item) ? ['document', 'objects', 'Server'] : ['value'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ServerVariableVisitor$1 = class ServerVariableVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ServerVariable$1();
      this.specPath = always(['document', 'objects', 'ServerVariable']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class VariablesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ServerVariables();
      this.specPath = always(['document', 'objects', 'ServerVariable']);
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let MediaTypeVisitor$1 = class MediaTypeVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new MediaType$1();
      this.specPath = always(['document', 'objects', 'MediaType']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  class AlternatingVisitor extends SpecificationVisitor {
    alternator;
    constructor({
      alternator,
      ...rest
    }) {
      super({
        ...rest
      });
      this.alternator = alternator || [];
    }
    enter(element) {
      const functions = this.alternator.map(({
        predicate,
        specPath
      }) => ifElse(predicate, always(specPath), stubUndefined));
      const specPath = dispatch(functions)(element);
      this.element = this.toRefractedElement(specPath, element);
      return BREAK;
    }
  }

  /**
   * @public
   */
  const isCallbackElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Callback$1 || hasBasicElementProps(element) && isElementType('callback', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isComponentsElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Components$1 || hasBasicElementProps(element) && isElementType('components', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isContactElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Contact$1 || hasBasicElementProps(element) && isElementType('contact', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isExampleElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Example$1 || hasBasicElementProps(element) && isElementType('example', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isExternalDocumentationElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof ExternalDocumentation$1 || hasBasicElementProps(element) && isElementType('externalDocumentation', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isHeaderElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Header$1 || hasBasicElementProps(element) && isElementType('header', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isInfoElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Info$1 || hasBasicElementProps(element) && isElementType('info', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLicenseElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof License$1 || hasBasicElementProps(element) && isElementType('license', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLinkElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Link$1 || hasBasicElementProps(element) && isElementType('link', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isOpenapiElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Openapi$1 || hasBasicElementProps(element) && isElementType('openapi', element) && primitiveEq('string', element);
  });

  /**
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const isOpenApi3_0Element = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq,
    hasClass
  }) => {
    return element => element instanceof OpenApi3_0 || hasBasicElementProps(element) && isElementType('openApi3_0', element) && primitiveEq('object', element) && hasClass('api', element);
  });

  /**
   * @public
   */
  const isOperationElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Operation$1 || hasBasicElementProps(element) && isElementType('operation', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isParameterElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Parameter$1 || hasBasicElementProps(element) && isElementType('parameter', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isPathItemElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof PathItem$1 || hasBasicElementProps(element) && isElementType('pathItem', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isPathsElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Paths$1 || hasBasicElementProps(element) && isElementType('paths', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isReferenceElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Reference$1 || hasBasicElementProps(element) && isElementType('reference', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isRequestBodyElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof RequestBody$1 || hasBasicElementProps(element) && isElementType('requestBody', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isResponseElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Response$1 || hasBasicElementProps(element) && isElementType('response', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isResponsesElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Responses$1 || hasBasicElementProps(element) && isElementType('responses', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isSchemaElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Schema$1 || hasBasicElementProps(element) && isElementType('schema', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isBooleanJsonSchemaElement$1 = element => {
    return isBooleanElement(element) && element.classes.includes('boolean-json-schema');
  };

  /**
   * @public
   */
  const isSecurityRequirementElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof SecurityRequirement$1 || hasBasicElementProps(element) && isElementType('securityRequirement', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isSecuritySchemeElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof SecurityScheme$1 || hasBasicElementProps(element) && isElementType('securityScheme', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isServerElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Server$1 || hasBasicElementProps(element) && isElementType('server', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isServerVariableElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof ServerVariable$1 || hasBasicElementProps(element) && isElementType('serverVariable', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isMediaTypeElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof MediaType$1 || hasBasicElementProps(element) && isElementType('mediaType', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isServersElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq,
    hasClass
  }) => {
    return element => element instanceof Servers || hasBasicElementProps(element) && isElementType('array', element) && primitiveEq('array', element) && hasClass('servers', element);
  });

  /**
   * @public
   */
  const isDiscriminatorElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof Discriminator$1 || hasBasicElementProps(element) && isElementType('discriminator', element) && primitiveEq('object', element);
  });

  const openApi3_0Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isBooleanJsonSchemaElement: isBooleanJsonSchemaElement$1,
    isCallbackElement: isCallbackElement$1,
    isComponentsElement: isComponentsElement$1,
    isContactElement: isContactElement$1,
    isDiscriminatorElement,
    isExampleElement: isExampleElement$1,
    isExternalDocumentationElement: isExternalDocumentationElement$1,
    isHeaderElement: isHeaderElement$1,
    isInfoElement: isInfoElement$1,
    isLicenseElement: isLicenseElement$1,
    isLinkElement: isLinkElement$1,
    isMediaTypeElement: isMediaTypeElement$1,
    isOpenApi3_0Element,
    isOpenapiElement: isOpenapiElement$1,
    isOperationElement: isOperationElement$1,
    isParameterElement: isParameterElement$1,
    isPathItemElement: isPathItemElement$1,
    isPathsElement: isPathsElement$1,
    isReferenceElement: isReferenceElement$1,
    isRequestBodyElement: isRequestBodyElement$1,
    isResponseElement: isResponseElement$1,
    isResponsesElement: isResponsesElement$1,
    isSchemaElement: isSchemaElement$1,
    isSecurityRequirementElement: isSecurityRequirementElement$1,
    isSecuritySchemeElement: isSecuritySchemeElement$1,
    isServerElement: isServerElement$1,
    isServerVariableElement: isServerVariableElement$1,
    isServersElement
  }, Symbol.toStringTag, { value: 'Module' }));

  /**
   * @public
   */
  /**
   * @public
   */
  let SchemaVisitor$4 = class SchemaVisitor extends Mixin(AlternatingVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.alternator = [{
        predicate: isReferenceLikeElement,
        specPath: ['document', 'objects', 'Reference']
      }, {
        predicate: T,
        specPath: ['document', 'objects', 'Schema']
      }];
    }
    ObjectElement(objectElement) {
      const result = AlternatingVisitor.prototype.enter.call(this, objectElement);
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'schema');
      }
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ExamplesVisitor$5 = class ExamplesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('examples');
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Example'];
      this.canSupportSpecificationExtensions = true;
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'example');
      });
      return result;
    }
  };

  /**
   * @public
   */
  let ExamplesVisitor$4 = class ExamplesVisitor extends ExamplesVisitor$5 {
    constructor(options) {
      super(options);
      this.element = new MediaTypeExamples();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let EncodingVisitor$2 = class EncodingVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new MediaTypeEncoding();
      this.specPath = always(['document', 'objects', 'Encoding']);
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let SecurityRequirementVisitor$1 = class SecurityRequirementVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new SecurityRequirement$1();
      this.specPath = always(['value']);
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let SecurityVisitor$1 = class SecurityVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Security();
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        if (isObjectElement(item)) {
          const element = this.toRefractedElement(['document', 'objects', 'SecurityRequirement'], item);
          this.element.push(element);
        } else {
          this.element.push(cloneDeep(item));
        }
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ComponentsVisitor$1 = class ComponentsVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Components$1();
      this.specPath = always(['document', 'objects', 'Components']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let TagVisitor$1 = class TagVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Tag$1();
      this.specPath = always(['document', 'objects', 'Tag']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ReferenceVisitor$1 = class ReferenceVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Reference$1();
      this.specPath = always(['document', 'objects', 'Reference']);
      this.canSupportSpecificationExtensions = false;
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // mark this ReferenceElement with reference metadata
      if (isStringElement(this.element.$ref)) {
        this.element.classes.push('reference-element');
      }
      return result;
    }
  };

  /**
   * @public
   */
  let $RefVisitor$1 = class $RefVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ParameterVisitor$1 = class ParameterVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Parameter$1();
      this.specPath = always(['document', 'objects', 'Parameter']);
      this.canSupportSpecificationExtensions = true;
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every MediaTypeElement with media type metadata
      if (isObjectElement(this.element.contentProp)) {
        this.element.contentProp.filter(isMediaTypeElement$1)
        // @ts-ignore
        .forEach((mediaTypeElement, key) => {
          mediaTypeElement.setMetaProperty('media-type', serializer(key));
        });
      }
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let SchemaVisitor$3 = class SchemaVisitor extends Mixin(AlternatingVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.alternator = [{
        predicate: isReferenceLikeElement,
        specPath: ['document', 'objects', 'Reference']
      }, {
        predicate: T,
        specPath: ['document', 'objects', 'Schema']
      }];
    }
    ObjectElement(objectElement) {
      const result = AlternatingVisitor.prototype.enter.call(this, objectElement);
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'schema');
      }
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let HeaderVisitor$1 = class HeaderVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Header$1();
      this.specPath = always(['document', 'objects', 'Header']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let SchemaVisitor$2 = class SchemaVisitor extends Mixin(AlternatingVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.alternator = [{
        predicate: isReferenceLikeElement,
        specPath: ['document', 'objects', 'Reference']
      }, {
        predicate: T,
        specPath: ['document', 'objects', 'Schema']
      }];
    }
    ObjectElement(objectElement) {
      const result = AlternatingVisitor.prototype.enter.call(this, objectElement);
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'schema');
      }
      return result;
    }
  };

  /**
   * @public
   */
  let ExamplesVisitor$3 = class ExamplesVisitor extends ExamplesVisitor$5 {
    constructor(options) {
      super(options);
      this.element = new HeaderExamples();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ContentVisitor$4 = class ContentVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('content');
      this.specPath = always(['document', 'objects', 'MediaType']);
    }
  };

  /**
   * @public
   */
  let ContentVisitor$3 = class ContentVisitor extends ContentVisitor$4 {
    constructor(options) {
      super(options);
      this.element = new HeaderContent();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let SchemaVisitor$1 = class SchemaVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Schema$1();
      this.specPath = always(['document', 'objects', 'Schema']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  const JSONSchemaAllOfVisitor = specification$6.visitors.document.objects.JSONSchema.fixedFields.allOf;

  /**
   * @public
   */
  let AllOfVisitor$2 = class AllOfVisitor extends JSONSchemaAllOfVisitor {
    ArrayElement(arrayElement) {
      const result = JSONSchemaAllOfVisitor.prototype.ArrayElement.call(this, arrayElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'schema');
      });
      return result;
    }
  };

  /**
   * @public
   */
  const JSONSchemaAnyOfVisitor = specification$6.visitors.document.objects.JSONSchema.fixedFields.anyOf;

  /**
   * @public
   */
  let AnyOfVisitor$2 = class AnyOfVisitor extends JSONSchemaAnyOfVisitor {
    ArrayElement(arrayElement) {
      const result = JSONSchemaAnyOfVisitor.prototype.ArrayElement.call(this, arrayElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'schema');
      });
      return result;
    }
  };

  /**
   * @public
   */
  const JSONSchemaOneOfVisitor = specification$6.visitors.document.objects.JSONSchema.fixedFields.oneOf;

  /**
   * @public
   */
  let OneOfVisitor$2 = class OneOfVisitor extends JSONSchemaOneOfVisitor {
    ArrayElement(arrayElement) {
      const result = JSONSchemaOneOfVisitor.prototype.ArrayElement.call(this, arrayElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'schema');
      });
      return result;
    }
  };

  /**
   * @public
   */
  const JSONSchemaItemsVisitor = specification$6.visitors.document.objects.JSONSchema.fixedFields.items;

  /**
   * @public
   */
  let ItemsVisitor$2 = class ItemsVisitor extends JSONSchemaItemsVisitor {
    ObjectElement(objectElement) {
      const result = JSONSchemaItemsVisitor.prototype.ObjectElement.call(this, objectElement);
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'schema');
      }
      return result;
    }
    ArrayElement(arrayElement) {
      const result = this.enter(arrayElement);
      return result;
    }
  };

  /**
   * @public
   */
  const JSONSchemaPropertiesVisitor = specification$6.visitors.document.objects.JSONSchema.fixedFields.properties;

  /**
   * @public
   */
  let PropertiesVisitor$2 = class PropertiesVisitor extends JSONSchemaPropertiesVisitor {
    ObjectElement(objectElement) {
      const result = JSONSchemaPropertiesVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'schema');
      });
      return result;
    }
  };

  /**
   * @public
   */
  const JSONSchemaTypeVisitor = specification$6.visitors.document.objects.JSONSchema.fixedFields.type;

  /**
   * @public
   */
  class TypeVisitor extends JSONSchemaTypeVisitor {
    ArrayElement(arrayElement) {
      const result = this.enter(arrayElement);
      return result;
    }
  }

  /**
   * @public
   */
  // eslint-disable-next-line prefer-destructuring
  const JSONSchemaOrJSONReferenceVisitor = specification$6.visitors.JSONSchemaOrJSONReferenceVisitor;

  /**
   * @public
   */
  class SchemaOrReferenceVisitor extends JSONSchemaOrJSONReferenceVisitor {
    ObjectElement(objectElement) {
      const result = JSONSchemaOrJSONReferenceVisitor.prototype.enter.call(this, objectElement);
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'schema');
      }
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let DiscriminatorVisitor$1 = class DiscriminatorVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Discriminator$1();
      this.specPath = always(['document', 'objects', 'Discriminator']);
      this.canSupportSpecificationExtensions = false;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class MappingVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new DiscriminatorMapping();
      this.specPath = always(['value']);
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let XmlVisitor$1 = class XmlVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Xml$1();
      this.specPath = always(['document', 'objects', 'XML']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  let ExamplesVisitor$2 = class ExamplesVisitor extends ExamplesVisitor$5 {
    constructor(options) {
      super(options);
      this.element = new ParameterExamples();
    }
  };

  /**
   * @public
   */
  let ContentVisitor$2 = class ContentVisitor extends ContentVisitor$4 {
    constructor(options) {
      super(options);
      this.element = new ParameterContent();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let SchemasVisitor$1 = class SchemasVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsSchemas();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Schema'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'schema');
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ResponsesVisitor$2 = class ResponsesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsResponses();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Response'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'response');
      });

      // decorate every ResponseElement with metadata about their status code
      // @ts-ignore
      this.element.filter(isResponseElement$1).forEach((value, key) => {
        value.setMetaProperty('http-status-code', serializer(key));
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ParametersVisitor$3 = class ParametersVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsParameters();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Parameter'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'parameter');
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ExamplesVisitor$1 = class ExamplesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsExamples();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Example'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'example');
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class RequestBodiesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsRequestBodies();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'RequestBody'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'requestBody');
      });
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let HeadersVisitor$2 = class HeadersVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsHeaders();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Header'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'header');
      });

      // decorate every HeaderElement with metadata about their name
      // @ts-ignore
      this.element.filter(isHeaderElement$1).forEach((value, key) => {
        value.setMetaProperty('header-name', serializer(key));
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class SecuritySchemesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsSecuritySchemes();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'SecurityScheme'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'securityScheme');
      });
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let LinksVisitor$1 = class LinksVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsLinks();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Link'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'link');
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let CallbacksVisitor$1 = class CallbacksVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsCallbacks();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Callback'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'callback');
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ExampleVisitor$1 = class ExampleVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Example$1();
      this.specPath = always(['document', 'objects', 'Example']);
      this.canSupportSpecificationExtensions = true;
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // mark this ExampleElement with reference metadata
      if (isStringElement(this.element.externalValue)) {
        this.element.classes.push('reference-element');
      }
      return result;
    }
  };

  /**
   * @public
   */
  class ExternalValueVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let ExternalDocumentationVisitor$1 = class ExternalDocumentationVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ExternalDocumentation$1();
      this.specPath = always(['document', 'objects', 'ExternalDocumentation']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let EncodingVisitor$1 = class EncodingVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Encoding$1();
      this.specPath = always(['document', 'objects', 'Encoding']);
      this.canSupportSpecificationExtensions = true;
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every Header with media type metadata
      if (isObjectElement(this.element.headers)) {
        this.element.headers.filter(isHeaderElement$1)
        // @ts-ignore
        .forEach((headerElement, key) => {
          headerElement.setMetaProperty('header-name', serializer(key));
        });
      }
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let HeadersVisitor$1 = class HeadersVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new EncodingHeaders();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Header'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'header');
      });

      // decorate every HeaderElement with metadata about their name
      this.element.forEach((value, key) => {
        if (!isHeaderElement$1(value)) return;
        const headerName = serializer(key);
        value.setMetaProperty('headerName', headerName);
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let PathsVisitor$1 = class PathsVisitor extends Mixin(PatternedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Paths$1();
      this.specPath = always(['document', 'objects', 'PathItem']);
      this.canSupportSpecificationExtensions = true;
      this.fieldPatternPredicate = T;
    }
    ObjectElement(objectElement) {
      const result = PatternedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every PathItemElement with path metadata
      this.element.filter(isPathItemElement$1)
      // @ts-ignore
      .forEach((pathItemElement, key) => {
        key.classes.push('openapi-path-template');
        key.classes.push('path-template');
        pathItemElement.setMetaProperty('path', cloneDeep(key));
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let RequestBodyVisitor$2 = class RequestBodyVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new RequestBody$1();
      this.specPath = always(['document', 'objects', 'RequestBody']);
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every MediaTypeElement with media type metadata
      if (isObjectElement(this.element.contentProp)) {
        this.element.contentProp.filter(isMediaTypeElement$1)
        // @ts-ignore
        .forEach((mediaTypeElement, key) => {
          mediaTypeElement.setMetaProperty('media-type', serializer(key));
        });
      }
      return result;
    }
  };

  /**
   * @public
   */
  let ContentVisitor$1 = class ContentVisitor extends ContentVisitor$4 {
    constructor(options) {
      super(options);
      this.element = new RequestBodyContent();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let CallbackVisitor$1 = class CallbackVisitor extends Mixin(PatternedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Callback$1();
      this.specPath = always(['document', 'objects', 'PathItem']);
      this.canSupportSpecificationExtensions = true;
      this.fieldPatternPredicate = value => /{(?<expression>[^}]{1,2083})}/.test(String(value)); // 2,083 characters is the maximum length of a URL in Chrome
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every PathItemElement with Callback Object expression metadata
      this.element.filter(isPathItemElement$1)
      // @ts-ignore
      .forEach((pathItemElement, key) => {
        pathItemElement.setMetaProperty('runtime-expression', serializer(key));
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ResponseVisitor$1 = class ResponseVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Response$1();
      this.specPath = always(['document', 'objects', 'Response']);
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every MediaTypeElement with media type metadata
      if (isObjectElement(this.element.contentProp)) {
        this.element.contentProp.filter(isMediaTypeElement$1)
        // @ts-ignore
        .forEach((mediaTypeElement, key) => {
          mediaTypeElement.setMetaProperty('media-type', serializer(key));
        });
      }

      // decorate every MediaTypeElement with media type metadata
      if (isObjectElement(this.element.headers)) {
        this.element.headers.filter(isHeaderElement$1)
        // @ts-ignore
        .forEach((headerElement, key) => {
          headerElement.setMetaProperty('header-name', serializer(key));
        });
      }
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class HeadersVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ResponseHeaders();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Header'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'header');
      });

      // decorate every HeaderElement with metadata about their name
      this.element.forEach((value, key) => {
        if (!isHeaderElement$1(value)) return;
        const headerName = serializer(key);
        value.setMetaProperty('header-name', headerName);
      });
      return result;
    }
  }

  /**
   * @public
   */
  class ContentVisitor extends ContentVisitor$4 {
    constructor(options) {
      super(options);
      this.element = new ResponseContent();
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class LinksVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ResponseLinks();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Link'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'link');
      });
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class MixedFieldsVisitor extends Mixin(FixedFieldsVisitor, PatternedFieldsVisitor) {
    specPathFixedFields;
    specPathPatternedFields;
    constructor({
      specPathFixedFields,
      specPathPatternedFields,
      ...rest
    }) {
      super({
        ...rest
      });
      this.specPathFixedFields = specPathFixedFields;
      this.specPathPatternedFields = specPathPatternedFields;
    }
    ObjectElement(objectElement) {
      const {
        specPath,
        ignoredFields
      } = this;
      try {
        this.specPath = this.specPathFixedFields;
        const fixedFields = this.retrieveFixedFields(this.specPath(objectElement));
        // let FixedFieldsVisitor only process fixed fields and leave rest to PatternedFieldsVisitor
        // @ts-ignore
        this.ignoredFields = [...ignoredFields, ...difference(objectElement.keys(), fixedFields)];
        FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);
        this.specPath = this.specPathPatternedFields;
        this.ignoredFields = fixedFields;
        PatternedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);
      } catch (e) {
        this.specPath = specPath;
        throw e;
      }
      return BREAK;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let ResponsesVisitor$1 = class ResponsesVisitor extends Mixin(MixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Responses$1();
      this.specPathFixedFields = always(['document', 'objects', 'Responses']);
      this.canSupportSpecificationExtensions = true;
      this.specPathPatternedFields = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Response'];
      this.fieldPatternPredicate = value => new RegExp(`^(1XX|2XX|3XX|4XX|5XX|${range(100, 600).join('|')})$`).test(String(value));
    }
    ObjectElement(objectElement) {
      const result = MixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate every ReferenceElement with metadata about their referencing type
      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'response');
      });

      // decorate every ResponseElement with metadata about their status code
      // @ts-ignore
      this.element.filter(isResponseElement$1).forEach((value, key) => {
        const httpStatusCode = cloneDeep(key);
        if (!this.fieldPatternPredicate(serializer(httpStatusCode))) return;
        value.setMetaProperty('http-status-code', httpStatusCode);
      });
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class DefaultVisitor extends Mixin(AlternatingVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.alternator = [{
        predicate: isReferenceLikeElement,
        specPath: ['document', 'objects', 'Reference']
      }, {
        predicate: T,
        specPath: ['document', 'objects', 'Response']
      }];
    }
    ObjectElement(objectElement) {
      const result = AlternatingVisitor.prototype.enter.call(this, objectElement);

      // decorate ReferenceElement with type of referencing element
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'response');
      } else if (isResponseElement$1(this.element)) {
        this.element.setMetaProperty('http-status-code', 'default');
      }
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let OperationVisitor$1 = class OperationVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Operation$1();
      this.specPath = always(['document', 'objects', 'Operation']);
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let TagsVisitor$1 = class TagsVisitor extends FallbackVisitor {
    constructor(options) {
      super(options);
      this.element = new OperationTags();
    }
    ArrayElement(arrayElement) {
      this.element = this.element.concat(cloneDeep(arrayElement));
      return BREAK;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let ParametersVisitor$2 = class ParametersVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('parameters');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isReferenceLikeElement(item) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Parameter'];
        const element = this.toRefractedElement(specPath, item);
        if (isReferenceElement$1(element)) {
          element.setMetaProperty('referenced-element', 'parameter');
        }
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  let ParametersVisitor$1 = class ParametersVisitor extends ParametersVisitor$2 {
    constructor(options) {
      super(options);
      this.element = new OperationParameters();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let RequestBodyVisitor$1 = class RequestBodyVisitor extends AlternatingVisitor {
    constructor(options) {
      super(options);
      this.alternator = [{
        predicate: isReferenceLikeElement,
        specPath: ['document', 'objects', 'Reference']
      }, {
        predicate: T,
        specPath: ['document', 'objects', 'RequestBody']
      }];
    }
    ObjectElement(objectElement) {
      const result = AlternatingVisitor.prototype.enter.call(this, objectElement);
      if (isReferenceElement$1(this.element)) {
        this.element.setMetaProperty('referenced-element', 'requestBody');
      }
      return result;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class CallbacksVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    specPath;
    constructor(options) {
      super(options);
      this.element = new OperationCallbacks();
      this.specPath = element => isReferenceLikeElement(element) ? ['document', 'objects', 'Reference'] : ['document', 'objects', 'Callback'];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);

      // @ts-ignore
      this.element.filter(isReferenceElement$1).forEach(referenceElement => {
        referenceElement.setMetaProperty('referenced-element', 'callback');
      });
      return result;
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class SecurityVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new OperationSecurity();
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isObjectElement(item) ? ['document', 'objects', 'SecurityRequirement'] : ['value'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  }

  /**
   * @public
   */
  let ServersVisitor$1 = class ServersVisitor extends ServersVisitor$2 {
    constructor(options) {
      super(options);
      this.element = new OperationServers();
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let PathItemVisitor$1 = class PathItemVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new PathItem$1();
      this.specPath = always(['document', 'objects', 'PathItem']);
    }
    ObjectElement(objectElement) {
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);

      // decorate Operation elements with HTTP method
      this.element.filter(isOperationElement$1)
      // @ts-ignore
      .forEach((operationElement, httpMethodElementCI) => {
        const httpMethodElementCS = cloneDeep(httpMethodElementCI);
        httpMethodElementCS.content = serializer(httpMethodElementCS).toUpperCase();
        operationElement.setMetaProperty('http-method', httpMethodElementCS);
      });

      // mark this PathItemElement with reference metadata
      if (isStringElement(this.element.$ref)) {
        this.element.classes.push('reference-element');
      }
      return result;
    }
  };

  /**
   * @public
   */
  class $RefVisitor extends FallbackVisitor {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  }

  /**
   * @public
   */
  class ServersVisitor extends ServersVisitor$2 {
    constructor(options) {
      super(options);
      this.element = new PathItemServers();
    }
  }

  /**
   * @public
   */
  class ParametersVisitor extends ParametersVisitor$2 {
    constructor(options) {
      super(options);
      this.element = new PathItemParameters();
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  let SecuritySchemeVisitor$1 = class SecuritySchemeVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new SecurityScheme$1();
      this.specPath = always(['document', 'objects', 'SecurityScheme']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let OAuthFlowsVisitor$1 = class OAuthFlowsVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new OAuthFlows$1();
      this.specPath = always(['document', 'objects', 'OAuthFlows']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  let OAuthFlowVisitor$1 = class OAuthFlowVisitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new OAuthFlow$1();
      this.specPath = always(['document', 'objects', 'OAuthFlow']);
      this.canSupportSpecificationExtensions = true;
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  class ScopesVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new OAuthFlowScopes();
      this.specPath = always(['value']);
    }
  }

  /**
   * @public
   */
  /**
   * @public
   */
  class TagsVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Tags();
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const specPath = isTagLikeElement(item) ? ['document', 'objects', 'Tag'] : ['value'];
        const element = this.toRefractedElement(specPath, item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  }

  /**
   * Specification object allows us to have complete control over visitors
   * when traversing the ApiDOM.
   * Specification also allows us to create amended refractors from
   * existing ones by manipulating it.
   *
   * Note: Specification object allows to use absolute internal JSON pointers.
   */
  const {
    fixedFields: jsonSchemaFixedFields
  } = specification$6.visitors.document.objects.JSONSchema;

  /**
   * @public
   */
  const specification$5 = {
    visitors: {
      value: FallbackVisitor,
      document: {
        objects: {
          OpenApi: {
            $visitor: OpenApi3_0Visitor,
            fixedFields: {
              openapi: OpenapiVisitor,
              info: {
                $ref: '#/visitors/document/objects/Info'
              },
              servers: ServersVisitor$2,
              paths: {
                $ref: '#/visitors/document/objects/Paths'
              },
              components: {
                $ref: '#/visitors/document/objects/Components'
              },
              security: SecurityVisitor$1,
              tags: TagsVisitor,
              externalDocs: {
                $ref: '#/visitors/document/objects/ExternalDocumentation'
              }
            }
          },
          Info: {
            $visitor: InfoVisitor$1,
            fixedFields: {
              title: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              termsOfService: {
                $ref: '#/visitors/value'
              },
              contact: {
                $ref: '#/visitors/document/objects/Contact'
              },
              license: {
                $ref: '#/visitors/document/objects/License'
              },
              version: VersionVisitor
            }
          },
          Contact: {
            $visitor: ContactVisitor$1,
            fixedFields: {
              name: {
                $ref: '#/visitors/value'
              },
              url: {
                $ref: '#/visitors/value'
              },
              email: {
                $ref: '#/visitors/value'
              }
            }
          },
          License: {
            $visitor: LicenseVisitor$1,
            fixedFields: {
              name: {
                $ref: '#/visitors/value'
              },
              url: {
                $ref: '#/visitors/value'
              }
            }
          },
          Server: {
            $visitor: ServerVisitor$1,
            fixedFields: {
              url: UrlVisitor,
              description: {
                $ref: '#/visitors/value'
              },
              variables: VariablesVisitor
            }
          },
          ServerVariable: {
            $visitor: ServerVariableVisitor$1,
            fixedFields: {
              enum: {
                $ref: '#/visitors/value'
              },
              default: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              }
            }
          },
          Components: {
            $visitor: ComponentsVisitor$1,
            fixedFields: {
              schemas: SchemasVisitor$1,
              responses: ResponsesVisitor$2,
              parameters: ParametersVisitor$3,
              examples: ExamplesVisitor$1,
              requestBodies: RequestBodiesVisitor,
              headers: HeadersVisitor$2,
              securitySchemes: SecuritySchemesVisitor,
              links: LinksVisitor$1,
              callbacks: CallbacksVisitor$1
            }
          },
          Paths: {
            $visitor: PathsVisitor$1
          },
          PathItem: {
            $visitor: PathItemVisitor$1,
            fixedFields: {
              $ref: $RefVisitor,
              summary: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              get: {
                $ref: '#/visitors/document/objects/Operation'
              },
              put: {
                $ref: '#/visitors/document/objects/Operation'
              },
              post: {
                $ref: '#/visitors/document/objects/Operation'
              },
              delete: {
                $ref: '#/visitors/document/objects/Operation'
              },
              options: {
                $ref: '#/visitors/document/objects/Operation'
              },
              head: {
                $ref: '#/visitors/document/objects/Operation'
              },
              patch: {
                $ref: '#/visitors/document/objects/Operation'
              },
              trace: {
                $ref: '#/visitors/document/objects/Operation'
              },
              servers: ServersVisitor,
              parameters: ParametersVisitor
            }
          },
          Operation: {
            $visitor: OperationVisitor$1,
            fixedFields: {
              tags: TagsVisitor$1,
              summary: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              externalDocs: {
                $ref: '#/visitors/document/objects/ExternalDocumentation'
              },
              operationId: {
                $ref: '#/visitors/value'
              },
              parameters: ParametersVisitor$1,
              requestBody: RequestBodyVisitor$1,
              responses: {
                $ref: '#/visitors/document/objects/Responses'
              },
              callbacks: CallbacksVisitor,
              deprecated: {
                $ref: '#/visitors/value'
              },
              security: SecurityVisitor,
              servers: ServersVisitor$1
            }
          },
          ExternalDocumentation: {
            $visitor: ExternalDocumentationVisitor$1,
            fixedFields: {
              description: {
                $ref: '#/visitors/value'
              },
              url: {
                $ref: '#/visitors/value'
              }
            }
          },
          Parameter: {
            $visitor: ParameterVisitor$1,
            fixedFields: {
              name: {
                $ref: '#/visitors/value'
              },
              in: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              required: {
                $ref: '#/visitors/value'
              },
              deprecated: {
                $ref: '#/visitors/value'
              },
              allowEmptyValue: {
                $ref: '#/visitors/value'
              },
              style: {
                $ref: '#/visitors/value'
              },
              explode: {
                $ref: '#/visitors/value'
              },
              allowReserved: {
                $ref: '#/visitors/value'
              },
              schema: SchemaVisitor$3,
              example: {
                $ref: '#/visitors/value'
              },
              examples: ExamplesVisitor$2,
              content: ContentVisitor$2
            }
          },
          RequestBody: {
            $visitor: RequestBodyVisitor$2,
            fixedFields: {
              description: {
                $ref: '#/visitors/value'
              },
              content: ContentVisitor$1,
              required: {
                $ref: '#/visitors/value'
              }
            }
          },
          MediaType: {
            $visitor: MediaTypeVisitor$1,
            fixedFields: {
              schema: SchemaVisitor$4,
              example: {
                $ref: '#/visitors/value'
              },
              examples: ExamplesVisitor$4,
              encoding: EncodingVisitor$2
            }
          },
          Encoding: {
            $visitor: EncodingVisitor$1,
            fixedFields: {
              contentType: {
                $ref: '#/visitors/value'
              },
              headers: HeadersVisitor$1,
              style: {
                $ref: '#/visitors/value'
              },
              explode: {
                $ref: '#/visitors/value'
              },
              allowReserved: {
                $ref: '#/visitors/value'
              }
            }
          },
          Responses: {
            $visitor: ResponsesVisitor$1,
            fixedFields: {
              default: DefaultVisitor
            }
          },
          Response: {
            $visitor: ResponseVisitor$1,
            fixedFields: {
              description: {
                $ref: '#/visitors/value'
              },
              headers: HeadersVisitor,
              content: ContentVisitor,
              links: LinksVisitor
            }
          },
          Callback: {
            $visitor: CallbackVisitor$1
          },
          Example: {
            $visitor: ExampleVisitor$1,
            fixedFields: {
              summary: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              value: {
                $ref: '#/visitors/value'
              },
              externalValue: ExternalValueVisitor
            }
          },
          Link: {
            $visitor: LinkVisitor$1,
            fixedFields: {
              operationRef: OperationRefVisitor,
              operationId: OperationIdVisitor,
              parameters: ParametersVisitor$4,
              requestBody: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              server: {
                $ref: '#/visitors/document/objects/Server'
              }
            }
          },
          Header: {
            $visitor: HeaderVisitor$1,
            fixedFields: {
              description: {
                $ref: '#/visitors/value'
              },
              required: {
                $ref: '#/visitors/value'
              },
              deprecated: {
                $ref: '#/visitors/value'
              },
              allowEmptyValue: {
                $ref: '#/visitors/value'
              },
              style: {
                $ref: '#/visitors/value'
              },
              explode: {
                $ref: '#/visitors/value'
              },
              allowReserved: {
                $ref: '#/visitors/value'
              },
              schema: SchemaVisitor$2,
              example: {
                $ref: '#/visitors/value'
              },
              examples: ExamplesVisitor$3,
              content: ContentVisitor$3
            }
          },
          Tag: {
            $visitor: TagVisitor$1,
            fixedFields: {
              name: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              externalDocs: {
                $ref: '#/visitors/document/objects/ExternalDocumentation'
              }
            }
          },
          Reference: {
            $visitor: ReferenceVisitor$1,
            fixedFields: {
              $ref: $RefVisitor$1
            }
          },
          JSONSchema: {
            $ref: '#/visitors/document/objects/Schema'
          },
          JSONReference: {
            $ref: '#/visitors/document/objects/Reference'
          },
          Schema: {
            $visitor: SchemaVisitor$1,
            fixedFields: {
              // the following properties are taken directly from the JSON Schema definition and follow the same specifications
              title: jsonSchemaFixedFields.title,
              multipleOf: jsonSchemaFixedFields.multipleOf,
              maximum: jsonSchemaFixedFields.maximum,
              exclusiveMaximum: jsonSchemaFixedFields.exclusiveMaximum,
              minimum: jsonSchemaFixedFields.minimum,
              exclusiveMinimum: jsonSchemaFixedFields.exclusiveMinimum,
              maxLength: jsonSchemaFixedFields.maxLength,
              minLength: jsonSchemaFixedFields.minLength,
              pattern: jsonSchemaFixedFields.pattern,
              maxItems: jsonSchemaFixedFields.maxItems,
              minItems: jsonSchemaFixedFields.minItems,
              uniqueItems: jsonSchemaFixedFields.uniqueItems,
              maxProperties: jsonSchemaFixedFields.maxProperties,
              minProperties: jsonSchemaFixedFields.minProperties,
              required: jsonSchemaFixedFields.required,
              enum: jsonSchemaFixedFields.enum,
              // the following properties are taken from the JSON Schema definition but their definitions were adjusted to the OpenAPI Specification
              type: TypeVisitor,
              allOf: AllOfVisitor$2,
              anyOf: AnyOfVisitor$2,
              oneOf: OneOfVisitor$2,
              not: SchemaOrReferenceVisitor,
              items: ItemsVisitor$2,
              properties: PropertiesVisitor$2,
              additionalProperties: SchemaOrReferenceVisitor,
              description: jsonSchemaFixedFields.description,
              format: jsonSchemaFixedFields.format,
              default: jsonSchemaFixedFields.default,
              // OpenAPI vocabulary
              nullable: {
                $ref: '#/visitors/value'
              },
              discriminator: {
                $ref: '#/visitors/document/objects/Discriminator'
              },
              writeOnly: {
                $ref: '#/visitors/value'
              },
              xml: {
                $ref: '#/visitors/document/objects/XML'
              },
              externalDocs: {
                $ref: '#/visitors/document/objects/ExternalDocumentation'
              },
              example: {
                $ref: '#/visitors/value'
              },
              deprecated: {
                $ref: '#/visitors/value'
              }
            }
          },
          Discriminator: {
            $visitor: DiscriminatorVisitor$1,
            fixedFields: {
              propertyName: {
                $ref: '#/visitors/value'
              },
              mapping: MappingVisitor
            }
          },
          XML: {
            $visitor: XmlVisitor$1,
            fixedFields: {
              name: {
                $ref: '#/visitors/value'
              },
              namespace: {
                $ref: '#/visitors/value'
              },
              prefix: {
                $ref: '#/visitors/value'
              },
              attribute: {
                $ref: '#/visitors/value'
              },
              wrapped: {
                $ref: '#/visitors/value'
              }
            }
          },
          SecurityScheme: {
            $visitor: SecuritySchemeVisitor$1,
            fixedFields: {
              type: {
                $ref: '#/visitors/value'
              },
              description: {
                $ref: '#/visitors/value'
              },
              name: {
                $ref: '#/visitors/value'
              },
              in: {
                $ref: '#/visitors/value'
              },
              scheme: {
                $ref: '#/visitors/value'
              },
              bearerFormat: {
                $ref: '#/visitors/value'
              },
              flows: {
                $ref: '#/visitors/document/objects/OAuthFlows'
              },
              openIdConnectUrl: {
                $ref: '#/visitors/value'
              }
            }
          },
          OAuthFlows: {
            $visitor: OAuthFlowsVisitor$1,
            fixedFields: {
              implicit: {
                $ref: '#/visitors/document/objects/OAuthFlow'
              },
              password: {
                $ref: '#/visitors/document/objects/OAuthFlow'
              },
              clientCredentials: {
                $ref: '#/visitors/document/objects/OAuthFlow'
              },
              authorizationCode: {
                $ref: '#/visitors/document/objects/OAuthFlow'
              }
            }
          },
          OAuthFlow: {
            $visitor: OAuthFlowVisitor$1,
            fixedFields: {
              authorizationUrl: {
                $ref: '#/visitors/value'
              },
              tokenUrl: {
                $ref: '#/visitors/value'
              },
              refreshUrl: {
                $ref: '#/visitors/value'
              },
              scopes: ScopesVisitor
            }
          },
          SecurityRequirement: {
            $visitor: SecurityRequirementVisitor$1
          }
        },
        extension: {
          $visitor: SpecificationExtensionVisitor
        }
      }
    }
  };

  /**
   * @public
   */
  /**
   * @public
   */
  /**
   * @public
   */
  const createToolbox$5 = () => {
    const namespace = createNamespace(openApi3_0);
    const predicates = {
      ...openApi3_0Predicates,
      isElement,
      isStringElement,
      isArrayElement,
      isObjectElement,
      isMemberElement,
      includesClasses,
      hasElementSourceMap
    };
    return {
      predicates,
      namespace
    };
  };

  /**
   * @public
   */
  const refract$4 = (value, {
    specPath = ['visitors', 'document', 'objects', 'OpenApi', '$visitor'],
    plugins = []
  } = {}) => {
    const element = minimExports.refract(value);
    const resolvedSpec = dereference(specification$5);

    /**
     * This is where generic ApiDOM becomes semantic (namespace applied).
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const RootVisitorClass = path$1(specPath, resolvedSpec);
    const rootVisitor = new RootVisitorClass({
      specObj: resolvedSpec
    });
    visit$1(element, rootVisitor);

    /**
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(rootVisitor.element, plugins, {
      toolboxCreator: createToolbox$5,
      visitorOptions: {
        keyMap: keyMap$5,
        nodeTypeGetter: getNodeType$1
      }
    });
  };

  /**
   * @public
   */
  const createRefractor$4 = specPath => (value, options = {}) => refract$4(value, {
    specPath,
    ...options
  });

  Callback$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Callback', '$visitor']);
  Components$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Components', '$visitor']);
  Contact$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Contact', '$visitor']);
  Example$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Example', '$visitor']);
  Discriminator$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Discriminator', '$visitor']);
  Encoding$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Encoding', '$visitor']);
  ExternalDocumentation$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'ExternalDocumentation', '$visitor']);
  Header$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Header', '$visitor']);
  Info$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Info', '$visitor']);
  License$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'License', '$visitor']);
  Link$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Link', '$visitor']);
  MediaType$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'MediaType', '$visitor']);
  OAuthFlow$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'OAuthFlow', '$visitor']);
  OAuthFlows$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'OAuthFlows', '$visitor']);
  Openapi$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'OpenApi', 'fixedFields', 'openapi']);
  OpenApi3_0.refract = createRefractor$4(['visitors', 'document', 'objects', 'OpenApi', '$visitor']);
  Operation$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Operation', '$visitor']);
  Parameter$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Parameter', '$visitor']);
  PathItem$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'PathItem', '$visitor']);
  Paths$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Paths', '$visitor']);
  Reference$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Reference', '$visitor']);
  RequestBody$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'RequestBody', '$visitor']);
  Response$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Response', '$visitor']);
  Responses$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Responses', '$visitor']);
  Schema$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Schema', '$visitor']);
  SecurityRequirement$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'SecurityRequirement', '$visitor']);
  SecurityScheme$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'SecurityScheme', '$visitor']);
  Server$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Server', '$visitor']);
  ServerVariable$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'ServerVariable', '$visitor']);
  Tag$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'Tag', '$visitor']);
  Xml$1.refract = createRefractor$4(['visitors', 'document', 'objects', 'XML', '$visitor']);

  class Callback extends Callback$1 {
  }

  class Components extends Components$1 {
    get pathItems() {
      return this.get("pathItems");
    }
    set pathItems(pathItems) {
      this.set("pathItems", pathItems);
    }
  }

  class Contact extends Contact$1 {
  }

  class Discriminator extends Discriminator$1 {
  }

  class Encoding extends Encoding$1 {
  }

  class Example extends Example$1 {
  }

  class ExternalDocumentation extends ExternalDocumentation$1 {
  }

  class Header extends Header$1 {
    get schema() {
      return this.get("schema");
    }
    set schema(schema) {
      this.set("schema", schema);
    }
  }

  class Info extends Info$1 {
    get license() {
      return this.get("license");
    }
    set license(licenseElement) {
      this.set("license", licenseElement);
    }
    get summary() {
      return this.get("summary");
    }
    set summary(summary) {
      this.set("summary", summary);
    }
  }

  var __defProp$6 = Object.defineProperty;
  var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$3 = (obj, key, value) => __defNormalProp$6(obj, key + "" , value);
  const _JsonSchemaDialect = class _JsonSchemaDialect extends minimExports.StringElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "jsonSchemaDialect";
    }
  };
  __publicField$3(_JsonSchemaDialect, "default", new _JsonSchemaDialect("https://spec.openapis.org/oas/3.1/dialect/base"));
  let JsonSchemaDialect = _JsonSchemaDialect;

  class License extends License$1 {
    get identifier() {
      return this.get("identifier");
    }
    set identifier(name) {
      this.set("identifier", name);
    }
  }

  class Link extends Link$1 {
  }

  class MediaType extends MediaType$1 {
    get schema() {
      return this.get("schema");
    }
    set schema(schema) {
      this.set("schema", schema);
    }
  }

  class OAuthFlow extends OAuthFlow$1 {
  }

  class OAuthFlows extends OAuthFlows$1 {
  }

  class Openapi extends Openapi$1 {
  }

  class OpenApi3_1 extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "openApi3_1";
      this.classes.push("api");
    }
    get openapi() {
      return this.get("openapi");
    }
    set openapi(openapi) {
      this.set("openapi", openapi);
    }
    get info() {
      return this.get("info");
    }
    set info(info) {
      this.set("info", info);
    }
    get jsonSchemaDialect() {
      return this.get("jsonSchemaDialect");
    }
    set jsonSchemaDialect(jsonSchemaDialect) {
      this.set("jsonSchemaDialect", jsonSchemaDialect);
    }
    get servers() {
      return this.get("servers");
    }
    set servers(servers) {
      this.set("servers", servers);
    }
    get paths() {
      return this.get("paths");
    }
    set paths(paths) {
      this.set("paths", paths);
    }
    get components() {
      return this.get("components");
    }
    set components(components) {
      this.set("components", components);
    }
    get security() {
      return this.get("security");
    }
    set security(security) {
      this.set("security", security);
    }
    get tags() {
      return this.get("tags");
    }
    set tags(tags) {
      this.set("tags", tags);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
    get webhooks() {
      return this.get("webhooks");
    }
    set webhooks(webhooks) {
      this.set("webhooks", webhooks);
    }
  }

  class Operation extends Operation$1 {
    get requestBody() {
      return this.get("requestBody");
    }
    set requestBody(requestBody) {
      this.set("requestBody", requestBody);
    }
  }

  class Parameter extends Parameter$1 {
    get schema() {
      return this.get("schema");
    }
    set schema(schema) {
      this.set("schema", schema);
    }
  }

  class PathItem extends PathItem$1 {
    get GET() {
      return this.get("get");
    }
    set GET(operation) {
      this.set("GET", operation);
    }
    get PUT() {
      return this.get("put");
    }
    set PUT(operation) {
      this.set("PUT", operation);
    }
    get POST() {
      return this.get("post");
    }
    set POST(operation) {
      this.set("POST", operation);
    }
    get DELETE() {
      return this.get("delete");
    }
    set DELETE(operation) {
      this.set("DELETE", operation);
    }
    get OPTIONS() {
      return this.get("options");
    }
    set OPTIONS(operation) {
      this.set("OPTIONS", operation);
    }
    get HEAD() {
      return this.get("head");
    }
    set HEAD(operation) {
      this.set("HEAD", operation);
    }
    get PATCH() {
      return this.get("patch");
    }
    set PATCH(operation) {
      this.set("PATCH", operation);
    }
    get TRACE() {
      return this.get("trace");
    }
    set TRACE(operation) {
      this.set("TRACE", operation);
    }
  }

  class Paths extends Paths$1 {
  }

  class Reference extends Reference$1 {
  }
  Object.defineProperty(Reference.prototype, "description", {
    get() {
      return this.get("description");
    },
    set(description) {
      this.set("description", description);
    },
    enumerable: true
  });
  Object.defineProperty(Reference.prototype, "summary", {
    get() {
      return this.get("summary");
    },
    set(description) {
      this.set("summary", description);
    },
    enumerable: true
  });

  class RequestBody extends RequestBody$1 {
  }

  class Response extends Response$1 {
  }

  class Responses extends Responses$1 {
  }

  /* eslint-disable class-methods-use-this */

  /**
   * @public
   */
  let JSONSchema$3 = class JSONSchema extends JSONSchema$4 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'JSONSchemaDraft6';
    }

    /**
     * Core vocabulary
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-01
     */

    get idProp() {
      throw new UnsupportedOperationError('id keyword from Core vocabulary has been renamed to $id.');
    }
    set idProp(id) {
      throw new UnsupportedOperationError('id keyword from Core vocabulary has been renamed to $id.');
    }
    get $id() {
      return this.get('$id');
    }
    set $id($id) {
      this.set('$id', $id);
    }

    /**
     * Validation vocabulary
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-01
     */

    /**
     *  Validation keywords for numeric instances (number and integer)
     */

    get exclusiveMaximum() {
      return this.get('exclusiveMaximum');
    }
    set exclusiveMaximum(exclusiveMaximum) {
      this.set('exclusiveMaximum', exclusiveMaximum);
    }
    get exclusiveMinimum() {
      return this.get('exclusiveMinimum');
    }
    set exclusiveMinimum(exclusiveMinimum) {
      this.set('exclusiveMinimum', exclusiveMinimum);
    }

    /**
     * Validation keywords for arrays
     */

    get containsProp() {
      return this.get('contains');
    }
    set containsProp(contains) {
      this.set('contains', contains);
    }
    get items() {
      return this.get('items');
    }
    set items(items) {
      this.set('items', items);
    }

    /**
     * Validation keywords for objects
     */

    get propertyNames() {
      return this.get('propertyNames');
    }
    set propertyNames(propertyNames) {
      this.set('propertyNames', propertyNames);
    }

    /**
     *  Validation keywords for any instance type
     */

    get const() {
      return this.get('const');
    }
    set const(constValue) {
      this.set('const', constValue);
    }
    get not() {
      return this.get('not');
    }
    set not(not) {
      this.set('not', not);
    }

    /**
     * Metadata keywords
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-01#section-7
     */

    get examples() {
      return this.get('examples');
    }
    set examples(examples) {
      this.set('examples', examples);
    }
  };

  /* eslint-disable class-methods-use-this */

  /**
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-01#section-6
   * @public
   */

  let LinkDescription$3 = class LinkDescription extends LinkDescription$4 {
    get hrefSchema() {
      return this.get('hrefSchema');
    }
    set hrefSchema(hrefSchema) {
      this.set('hrefSchema', hrefSchema);
    }
    get targetSchema() {
      return this.get('targetSchema');
    }
    set targetSchema(targetSchema) {
      this.set('targetSchema', targetSchema);
    }
    get schema() {
      throw new UnsupportedOperationError('schema keyword from Hyper-Schema vocabulary has been renamed to submissionSchema.');
    }
    set schema(schema) {
      throw new UnsupportedOperationError('schema keyword from Hyper-Schema vocabulary has been renamed to submissionSchema.');
    }
    get submissionSchema() {
      return this.get('submissionSchema');
    }
    set submissionSchema(submissionSchema) {
      this.set('submissionSchema', submissionSchema);
    }
    get method() {
      throw new UnsupportedOperationError('method keyword from Hyper-Schema vocabulary has been removed.');
    }
    set method(method) {
      throw new UnsupportedOperationError('method keyword from Hyper-Schema vocabulary has been removed.');
    }
    get encType() {
      throw new UnsupportedOperationError('encType keyword from Hyper-Schema vocabulary has been renamed to submissionEncType.');
    }
    set encType(encType) {
      throw new UnsupportedOperationError('encType keyword from Hyper-Schema vocabulary has been renamed to submissionEncType.');
    }
    get submissionEncType() {
      return this.get('submissionEncType');
    }
    set submissionEncType(submissionEncType) {
      this.set('submissionEncType', submissionEncType);
    }
  };

  /**
   * @public
   */
  const jsonSchemaDraft6 = {
    namespace: options => {
      const {
        base
      } = options;
      base.register('jSONSchemaDraft6', JSONSchema$3);
      base.register('jSONReference', JSONReference);
      base.register('media', Media);
      base.register('linkDescription', LinkDescription$3);
      return base;
    }
  };

  /**
   * @public
   */
  const keyMap$4 = {
    JSONSchemaDraft6Element: ['content'],
    JSONReferenceElement: ['content'],
    MediaElement: ['content'],
    LinkDescriptionElement: ['content'],
    ...keyMapDefault$1
  };

  /**
   * @public
   */
  let JSONSchemaVisitor$4 = class JSONSchemaVisitor extends JSONSchemaVisitor$5 {
    constructor(options) {
      super(options);
      this.element = new JSONSchema$3();
    }

    // eslint-disable-next-line class-methods-use-this
    get defaultDialectIdentifier() {
      return 'http://json-schema.org/draft-06/schema#';
    }
    BooleanElement(booleanElement) {
      const result = this.enter(booleanElement);
      this.element.classes.push('boolean-json-schema');
      return result;
    }
    handleSchemaIdentifier(objectElement, identifierKeyword = '$id') {
      return super.handleSchemaIdentifier(objectElement, identifierKeyword);
    }
  };

  /**
   * @public
   */
  let ItemsVisitor$1 = class ItemsVisitor extends ItemsVisitor$3 {
    BooleanElement(booleanElement) {
      this.element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], booleanElement);
      return BREAK;
    }
  };

  /**
   * @public
   */
  class ExamplesVisitor extends FallbackVisitor$1 {
    ArrayElement(arrayElement) {
      const result = this.enter(arrayElement);
      this.element.classes.push('json-schema-examples');
      return result;
    }
  }

  /**
   * @public
   */
  let LinkDescriptionVisitor$4 = class LinkDescriptionVisitor extends LinkDescriptionVisitor$5 {
    constructor(options) {
      super(options);
      this.element = new LinkDescription$3();
    }
  };

  const specification$4 = pipe(
  // JSON Schema object modifications
  assocPath(['visitors', 'document', 'objects', 'JSONSchema', '$visitor'], JSONSchemaVisitor$4), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'id']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$id'], specification$6.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contains'], specification$6.visitors.JSONSchemaOrJSONReferenceVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'items'], ItemsVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'propertyNames'], specification$6.visitors.JSONSchemaOrJSONReferenceVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'const'], specification$6.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'examples'], ExamplesVisitor),
  // Link Description object modifications
  assocPath(['visitors', 'document', 'objects', 'LinkDescription', '$visitor'], LinkDescriptionVisitor$4), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'hrefSchema'], specification$6.visitors.JSONSchemaOrJSONReferenceVisitor), dissocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'schema']), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'submissionSchema'], specification$6.visitors.JSONSchemaOrJSONReferenceVisitor), dissocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'method']), dissocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'encType']), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'submissionEncType'], specification$6.visitors.value))(specification$6);

  /**
   * @public
   */
  const isJSONSchemaElement$3 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof JSONSchema$3 || hasBasicElementProps(element) && isElementType('JSONSchemaDraft6', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLinkDescriptionElement$3 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof LinkDescription$3 || hasBasicElementProps(element) && isElementType('linkDescription', element) && primitiveEq('object', element);
  });

  const jsonSchemaDraft6Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isJSONReferenceElement,
    isJSONSchemaElement: isJSONSchemaElement$3,
    isLinkDescriptionElement: isLinkDescriptionElement$3,
    isMediaElement
  }, Symbol.toStringTag, { value: 'Module' }));

  const createToolbox$4 = () => {
    const namespace = createNamespace(jsonSchemaDraft6);
    const predicates = {
      ...jsonSchemaDraft6Predicates,
      isStringElement
    };
    return {
      predicates,
      namespace
    };
  };

  /**
   * @public
   */
  const refract$3 = (value, {
    specPath = ['visitors', 'document', 'objects', 'JSONSchema', '$visitor'],
    plugins = [],
    specificationObj = specification$4
  } = {}) => {
    const element = minimExports.refract(value);
    const resolvedSpec = dereference(specificationObj);

    /**
     * This is where generic ApiDOM becomes semantic (namespace applied).
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const RootVisitorClass = path$1(specPath, resolvedSpec);
    const rootVisitor = new RootVisitorClass({
      specObj: resolvedSpec
    });
    visit$1(element, rootVisitor);

    /**
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(rootVisitor.element, plugins, {
      toolboxCreator: createToolbox$4,
      visitorOptions: {
        keyMap: keyMap$4,
        nodeTypeGetter: getNodeType$2
      }
    });
  };

  /**
   * @public
   */
  const createRefractor$3 = specPath => (value, options = {}) => refract$3(value, {
    specPath,
    ...options
  });

  JSONSchema$3.refract = createRefractor$3(['visitors', 'document', 'objects', 'JSONSchema', '$visitor']);
  LinkDescription$3.refract = createRefractor$3(['visitors', 'document', 'objects', 'LinkDescription', '$visitor']);

  /* eslint-disable class-methods-use-this */
  /**
   * @public
   */
  let JSONSchema$2 = class JSONSchema extends JSONSchema$3 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'JSONSchemaDraft7';
    }

    /**
     * Core vocabulary
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-01
     */

    get $comment() {
      return this.get('$comment');
    }
    set $comment($comment) {
      this.set('$comment', $comment);
    }

    /**
     * Validation vocabulary
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01
     */

    /**
     * Validation keywords for arrays
     */
    get items() {
      return this.get('items');
    }
    set items(items) {
      this.set('items', items);
    }

    /**
     * Keywords for Applying Subschemas Conditionally
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.6
     */

    get if() {
      return this.get('if');
    }
    set if(ifValue) {
      this.set('if', ifValue);
    }
    get then() {
      return this.get('then');
    }
    set then(then) {
      this.set('then', then);
    }
    get else() {
      return this.get('else');
    }
    set else(elseValue) {
      this.set('else', elseValue);
    }

    /**
     * Keywords for Applying Subschemas With Boolean Logic
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.7
     */

    get not() {
      return this.get('not');
    }
    set not(not) {
      this.set('not', not);
    }

    /**
     * String-Encoding Non-JSON Data
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-00#section-8
     */

    get contentEncoding() {
      return this.get('contentEncoding');
    }
    set contentEncoding(contentEncoding) {
      this.set('contentEncoding', contentEncoding);
    }
    get contentMediaType() {
      return this.get('contentMediaType');
    }
    set contentMediaType(contentMediaType) {
      this.set('contentMediaType', contentMediaType);
    }
    get media() {
      throw new UnsupportedOperationError('media keyword from Hyper-Schema vocabulary has been moved to validation vocabulary as "contentMediaType" / "contentEncoding"');
    }
    set media(media) {
      throw new UnsupportedOperationError('media keyword from Hyper-Schema vocabulary has been moved to validation vocabulary as "contentMediaType" / "contentEncoding"');
    }

    /**
     * Schema annotations
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-10
     */

    get writeOnly() {
      return this.get('writeOnly');
    }
    set writeOnly(writeOnly) {
      this.set('writeOnly', writeOnly);
    }
  };

  /* eslint-disable class-methods-use-this */

  /**
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-01#section-6
   * @public
   */

  let LinkDescription$2 = class LinkDescription extends LinkDescription$3 {
    /**
     * Link context.
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-01#section-6.1
     */

    get anchor() {
      return this.get('anchor');
    }
    set anchor(anchor) {
      this.set('anchor', anchor);
    }
    get anchorPointer() {
      return this.get('anchorPointer');
    }
    set anchorPointer(anchorPointer) {
      this.set('anchorPointer', anchorPointer);
    }

    /**
     * Adjusting URI Template Resolution.
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-01#section-6.4
     */

    get templatePointers() {
      return this.get('templatePointers');
    }
    set templatePointers(templatePointers) {
      this.set('templatePointers', templatePointers);
    }
    get templateRequired() {
      return this.get('templateRequired');
    }
    set templateRequired(templateRequired) {
      this.set('templateRequired', templateRequired);
    }

    /**
     * Link Target Attributes.
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-01#section-6.5
     */

    get targetSchema() {
      return this.get('targetSchema');
    }
    set targetSchema(targetSchema) {
      this.set('targetSchema', targetSchema);
    }
    get mediaType() {
      throw new UnsupportedOperationError('mediaType keyword from Hyper-Schema vocabulary has been renamed to targetMediaType.');
    }
    set mediaType(mediaType) {
      throw new UnsupportedOperationError('mediaType keyword from Hyper-Schema vocabulary has been renamed to targetMediaType.');
    }
    get targetMediaType() {
      return this.get('targetMediaType');
    }
    set targetMediaType(targetMediaType) {
      this.set('targetMediaType', targetMediaType);
    }
    get targetHints() {
      return this.get('targetHints');
    }
    set targetHints(targetHints) {
      this.set('targetHints', targetHints);
    }
    get description() {
      return this.get('description');
    }
    set description(description) {
      this.set('description', description);
    }
    get $comment() {
      return this.get('$comment');
    }
    set $comment($comment) {
      this.set('$comment', $comment);
    }

    /**
     *  Link Input.
     *
     *  URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-01#section-6.6
     */

    get hrefSchema() {
      return this.get('hrefSchema');
    }
    set hrefSchema(hrefSchema) {
      this.set('hrefSchema', hrefSchema);
    }
    get headerSchema() {
      return this.get('headerSchema');
    }
    set headerSchema(headerSchema) {
      this.set('headerSchema', headerSchema);
    }

    /**
     *  Submitting Data for Processing.
     *
     *  URI: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-01#section-6.6.4
     */

    get submissionSchema() {
      return this.get('submissionSchema');
    }
    set submissionSchema(submissionSchema) {
      this.set('submissionSchema', submissionSchema);
    }
    get submissionEncType() {
      throw new UnsupportedOperationError('submissionEncType keyword from Hyper-Schema vocabulary has been renamed to submissionMediaType.');
    }
    set submissionEncType(submissionEncType) {
      throw new UnsupportedOperationError('submissionEncType keyword from Hyper-Schema vocabulary has been renamed to submissionMediaType.');
    }
    get submissionMediaType() {
      return this.get('submissionMediaType');
    }
    set submissionMediaType(submissionMediaType) {
      this.set('submissionMediaType', submissionMediaType);
    }
  };

  /**
   * @public
   */
  const jsonSchemaDraft7 = {
    namespace: options => {
      const {
        base
      } = options;
      base.register('jSONSchemaDraft7', JSONSchema$2);
      base.register('jSONReference', JSONReference);
      base.register('linkDescription', LinkDescription$2);
      return base;
    }
  };

  /**
   * @public
   */
  const keyMap$3 = {
    JSONSchemaDraft7Element: ['content'],
    JSONReferenceElement: ['content'],
    LinkDescriptionElement: ['content'],
    ...keyMapDefault$1
  };

  /**
   * @public
   */
  let JSONSchemaVisitor$3 = class JSONSchemaVisitor extends JSONSchemaVisitor$4 {
    constructor(options) {
      super(options);
      this.element = new JSONSchema$2();
    }

    // eslint-disable-next-line class-methods-use-this
    get defaultDialectIdentifier() {
      return 'http://json-schema.org/draft-07/schema#';
    }
  };

  /**
   * @public
   */
  let LinkDescriptionVisitor$3 = class LinkDescriptionVisitor extends LinkDescriptionVisitor$4 {
    constructor(options) {
      super(options);
      this.element = new LinkDescription$2();
    }
  };

  const specification$3 = pipe(
  // JSON Schema object modifications
  assocPath(['visitors', 'document', 'objects', 'JSONSchema', '$visitor'], JSONSchemaVisitor$3), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$comment'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'if'], specification$4.visitors.JSONSchemaOrJSONReferenceVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'then'], specification$4.visitors.JSONSchemaOrJSONReferenceVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'else'], specification$4.visitors.JSONSchemaOrJSONReferenceVisitor), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'media']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contentEncoding'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contentMediaType'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'writeOnly'], specification$4.visitors.value),
  // Link Description object modifications
  assocPath(['visitors', 'document', 'objects', 'LinkDescription', '$visitor'], LinkDescriptionVisitor$3), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'anchor'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'anchorPointer'], specification$4.visitors.value), dissocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'mediaType']), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'targetMediaType'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'targetHints'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'description'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', '$comment'], specification$4.visitors.value), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'headerSchema'], specification$4.visitors.JSONSchemaOrJSONReferenceVisitor), dissocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'submissionEncType']), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'submissionMediaType'], specification$4.visitors.value))(specification$4);

  /**
   * @public
   */
  const isJSONSchemaElement$2 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof JSONSchema$2 || hasBasicElementProps(element) && isElementType('JSONSchemaDraft7', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLinkDescriptionElement$2 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof LinkDescription$2 || hasBasicElementProps(element) && isElementType('linkDescription', element) && primitiveEq('object', element);
  });

  const jsonSchemaDraft7Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isJSONReferenceElement,
    isJSONSchemaElement: isJSONSchemaElement$2,
    isLinkDescriptionElement: isLinkDescriptionElement$2
  }, Symbol.toStringTag, { value: 'Module' }));

  const createToolbox$3 = () => {
    const namespace = createNamespace(jsonSchemaDraft7);
    const predicates = {
      ...jsonSchemaDraft7Predicates,
      isStringElement
    };
    return {
      predicates,
      namespace
    };
  };

  /**
   * @public
   */
  const refract$2 = (value, {
    specPath = ['visitors', 'document', 'objects', 'JSONSchema', '$visitor'],
    plugins = [],
    specificationObj = specification$3
  } = {}) => {
    const element = minimExports.refract(value);
    const resolvedSpec = dereference(specificationObj);

    /**
     * This is where generic ApiDOM becomes semantic (namespace applied).
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const RootVisitorClass = path$1(specPath, resolvedSpec);
    const rootVisitor = new RootVisitorClass({
      specObj: resolvedSpec
    });
    visit$1(element, rootVisitor);

    /**
     * Run plugins only when necessary.
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(rootVisitor.element, plugins, {
      toolboxCreator: createToolbox$3,
      visitorOptions: {
        keyMap: keyMap$3,
        nodeTypeGetter: getNodeType$2
      }
    });
  };

  /**
   * @public
   */
  const createRefractor$2 = specPath => (value, options = {}) => refract$2(value, {
    specPath,
    ...options
  });

  JSONSchema$2.refract = createRefractor$2(['visitors', 'document', 'objects', 'JSONSchema', '$visitor']);
  LinkDescription$2.refract = createRefractor$2(['visitors', 'document', 'objects', 'LinkDescription', '$visitor']);

  /* eslint-disable class-methods-use-this */

  /**
   * @public
   */
  let JSONSchema$1 = class JSONSchema extends JSONSchema$2 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'JSONSchema201909';
    }

    /**
     * Core vocabulary
     *
     * URI: https://json-schema.org/draft/2019-09/vocab/core
     */

    get $vocabulary() {
      return this.get('$vocabulary');
    }
    set $vocabulary($vocabulary) {
      this.set('$vocabulary', $vocabulary);
    }
    get $anchor() {
      return this.get('$anchor');
    }
    set $anchor($anchor) {
      this.set('$anchor', $anchor);
    }
    get $recursiveAnchor() {
      return this.get('$recursiveAnchor');
    }
    set $recursiveAnchor($recursiveAnchor) {
      this.set('$recursiveAnchor', $recursiveAnchor);
    }
    get $recursiveRef() {
      return this.get('$recursiveRef');
    }
    set $recursiveRef($recursiveRef) {
      this.set('$recursiveRef', $recursiveRef);
    }
    get $ref() {
      return this.get('$ref');
    }
    set $ref($ref) {
      this.set('$ref', $ref);
    }
    get $defs() {
      return this.get('$defs');
    }
    set $defs($defs) {
      this.set('$defs', $defs);
    }
    get definitions() {
      throw new UnsupportedOperationError('definitions keyword from Validation vocabulary has been renamed to $defs.');
    }
    set definitions(definitions) {
      throw new UnsupportedOperationError('definitions keyword from Validation vocabulary has been renamed to $defs.');
    }

    /**
     * Applicator vocabulary
     *
     * URI: https://json-schema.org/draft/2019-09/vocab/applicator
     */

    get not() {
      return this.get('not');
    }
    set not(not) {
      this.set('not', not);
    }
    get if() {
      return this.get('if');
    }
    set if(ifSchema) {
      this.set('if', ifSchema);
    }
    get then() {
      return this.get('then');
    }
    set then(thenSchema) {
      this.set('then', thenSchema);
    }
    get else() {
      return this.get('else');
    }
    set else(elseSchema) {
      this.set('else', elseSchema);
    }
    get dependentSchemas() {
      return this.get('dependentSchemas');
    }
    set dependentSchemas(dependentSchemas) {
      this.set('dependentSchemas', dependentSchemas);
    }
    get dependencies() {
      throw new UnsupportedOperationError('dependencies keyword from Validation vocabulary has been renamed to dependentSchemas.');
    }
    set dependencies(dependencies) {
      throw new UnsupportedOperationError('dependencies keyword from Validation vocabulary has been renamed to dependentSchemas.');
    }
    get items() {
      return this.get('items');
    }
    set items(items) {
      this.set('items', items);
    }
    get containsProp() {
      return this.get('contains');
    }
    set containsProp(containsProp) {
      this.set('contains', containsProp);
    }
    get additionalProperties() {
      return this.get('additionalProperties');
    }
    set additionalProperties(additionalProperties) {
      this.set('additionalProperties', additionalProperties);
    }
    get additionalItems() {
      return this.get('additionalItems');
    }
    set additionalItems(additionalItems) {
      this.set('additionalItems', additionalItems);
    }
    get propertyNames() {
      return this.get('propertyNames');
    }
    set propertyNames(propertyNames) {
      this.set('propertyNames', propertyNames);
    }
    get unevaluatedItems() {
      return this.get('unevaluatedItems');
    }
    set unevaluatedItems(unevaluatedItems) {
      this.set('unevaluatedItems', unevaluatedItems);
    }
    get unevaluatedProperties() {
      return this.get('unevaluatedProperties');
    }
    set unevaluatedProperties(unevaluatedProperties) {
      this.set('unevaluatedProperties', unevaluatedProperties);
    }

    /**
     * Validation vocabulary
     *
     * URI: https://json-schema.org/draft/2019-09/json-schema-validation#rfc.section.6
     */

    /**
     * Validation Keywords for Arrays
     *
     * URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-validation-02#rfc.section.6.4
     */

    get maxContains() {
      return this.get('maxContains');
    }
    set maxContains(maxContains) {
      this.set('maxContains', maxContains);
    }
    get minContains() {
      return this.get('minContains');
    }
    set minContains(minContains) {
      this.set('minContains', minContains);
    }

    /**
     * Validation Keywords for Objects
     *
     * URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-validation-02#rfc.section.6.5
     */

    get dependentRequired() {
      return this.get('dependentRequired');
    }
    set dependentRequired(dependentRequired) {
      this.set('dependentRequired', dependentRequired);
    }

    /**
     * Vocabulary for Basic Meta-Data Annotations
     *
     * URI: https://json-schema.org/draft/2019-09/vocab/meta-data
     */

    get deprecated() {
      return this.get('deprecated');
    }
    set deprecated(deprecated) {
      this.set('deprecated', deprecated);
    }

    /**
     * Vocabulary for the Contents of String-Encoded Data
     *
     * URI: https://json-schema.org/draft/2019-09/vocab/content
     */

    get contentSchema() {
      return this.get('contentSchema');
    }
    set contentSchema(contentSchema) {
      this.set('contentSchema', contentSchema);
    }
  };

  /* eslint-disable class-methods-use-this */

  /**
   * URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-hyperschema-02#rfc.section.6
   * @public
   */

  let LinkDescription$1 = class LinkDescription extends LinkDescription$2 {
    /**
     *  Link Target Attributes.
     *
     *  URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-hyperschema-02#rfc.section.6.5
     */
    get targetSchema() {
      return this.get('targetSchema');
    }
    set targetSchema(targetSchema) {
      this.set('targetSchema', targetSchema);
    }

    /**
     *  Link Input.
     *
     *  URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-hyperschema-02#input
     */
    get hrefSchema() {
      return this.get('hrefSchema');
    }
    set hrefSchema(hrefSchema) {
      this.set('hrefSchema', hrefSchema);
    }
    get headerSchema() {
      return this.get('headerSchema');
    }
    set headerSchema(headerSchema) {
      this.set('headerSchema', headerSchema);
    }
    get submissionSchema() {
      return this.get('submissionSchema');
    }
    set submissionSchema(submissionSchema) {
      this.set('submissionSchema', submissionSchema);
    }
  };

  /**
   * @public
   */
  const jsonSchema201909 = {
    namespace: options => {
      const {
        base
      } = options;
      base.register('jSONSchema201909', JSONSchema$1);
      base.register('linkDescription', LinkDescription$1);
      return base;
    }
  };

  /**
   * @public
   */
  const keyMap$2 = {
    JSONSchema201909Element: ['content'],
    LinkDescriptionElement: ['content'],
    ...keyMapDefault$1
  };

  /**
   * @public
   */
  let JSONSchemaVisitor$2 = class JSONSchemaVisitor extends JSONSchemaVisitor$3 {
    constructor(options) {
      super(options);
      this.element = new JSONSchema$1();
    }

    // eslint-disable-next-line class-methods-use-this
    get defaultDialectIdentifier() {
      return 'https://json-schema.org/draft/2019-09/schema';
    }
    ObjectElement(objectElement) {
      this.handleDialectIdentifier(objectElement);
      this.handleSchemaIdentifier(objectElement);

      // for further processing consider this Schema Element as parent for all embedded Schema Elements
      this.parent = this.element;
      const result = FixedFieldsVisitor$1.prototype.ObjectElement.call(this, objectElement);

      // mark this SchemaElement with reference metadata
      if (isStringElement(this.element.$ref)) {
        this.element.classes.push('reference-element');
        this.element.setMetaProperty('referenced-element', 'schema');
      }
      return result;
    }
  };

  /**
   * @public
   */
  class $vocabularyVisitor extends FallbackVisitor$1 {
    ObjectElement(objectElement) {
      const result = super.enter(objectElement);
      this.element.classes.push('json-schema-$vocabulary');
      return result;
    }
  }

  /**
   * @public
   */
  class $refVisitor extends FallbackVisitor$1 {
    StringElement(stringElement) {
      const result = super.enter(stringElement);
      this.element.classes.push('reference-value');
      return result;
    }
  }

  /**
   * @public
   */

  /**
   * @public
   */
  let $defsVisitor$1 = class $defsVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-$defs');
      this.specPath = always(['document', 'objects', 'JSONSchema']);
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let AllOfVisitor$1 = class AllOfVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-allOf');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let AnyOfVisitor$1 = class AnyOfVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-anyOf');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let OneOfVisitor$1 = class OneOfVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-oneOf');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let DependentSchemasVisitor$1 = class DependentSchemasVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-dependentSchemas');
      this.specPath = always(['document', 'objects', 'JSONSchema']);
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  class ItemsVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    ObjectElement(objectElement) {
      this.element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], objectElement);
      return BREAK;
    }
    ArrayElement(arrayElement) {
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-items');
      arrayElement.forEach(item => {
        const element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
    BooleanElement(booleanElement) {
      this.element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], booleanElement);
      return BREAK;
    }
  }

  /**
   * @public
   */

  /**
   * @public
   */
  let PropertiesVisitor$1 = class PropertiesVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-properties');
      this.specPath = always(['document', 'objects', 'JSONSchema']);
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let PatternPropertiesVisitor$1 = class PatternPropertiesVisitor extends Mixin(MapVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ObjectElement();
      this.element.classes.push('json-schema-patternProperties');
      this.specPath = always(['document', 'objects', 'JSONSchema']);
    }
  };

  /**
   * @public
   */
  class DependentRequiredVisitor extends FallbackVisitor$1 {
    ObjectElement(objectElement) {
      const result = super.enter(objectElement);
      this.element.classes.push('json-schema-dependentRequired');
      return result;
    }
  }

  /**
   * @public
   */
  let LinkDescriptionVisitor$2 = class LinkDescriptionVisitor extends LinkDescriptionVisitor$3 {
    constructor(options) {
      super(options);
      this.element = new LinkDescription$1();
    }
  };

  const specification$2 = pipe(
  // JSON Schema object modifications
  assocPath(['visitors', 'document', 'objects', 'JSONSchema', '$visitor'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$vocabulary'], $vocabularyVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$anchor'], specification$3.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$recursiveAnchor'], specification$3.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$recursiveRef'], specification$3.visitors.value), dissocPath(['visitors', 'document', 'objects', 'JSONReference', '$visitor']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$ref'], $refVisitor), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'definitions']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$defs'], $defsVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'allOf'], AllOfVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'anyOf'], AnyOfVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'oneOf'], OneOfVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'not'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'if'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'then'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'else'], JSONSchemaVisitor$2), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'dependencies']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'dependentSchemas'], DependentSchemasVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'items'], ItemsVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contains'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'properties'], PropertiesVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'patternProperties'], PatternPropertiesVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'additionalProperties'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'additionalItems'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'propertyNames'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'unevaluatedItems'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'unevaluatedProperties'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'maxContains'], specification$3.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'minContains'], specification$3.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'dependentRequired'], DependentRequiredVisitor), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'deprecated'], specification$3.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contentSchema'], JSONSchemaVisitor$2),
  // Link Description object modifications
  assocPath(['visitors', 'document', 'objects', 'LinkDescription', '$visitor'], LinkDescriptionVisitor$2), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'targetSchema'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'hrefSchema'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'headerSchema'], JSONSchemaVisitor$2), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'submissionSchema'], JSONSchemaVisitor$2))(specification$3);

  /**
   * @public
   */
  const isJSONSchemaElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof JSONSchema$1 || hasBasicElementProps(element) && isElementType('JSONSchema201909', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLinkDescriptionElement$1 = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof LinkDescription$1 || hasBasicElementProps(element) && isElementType('linkDescription', element) && primitiveEq('object', element);
  });

  const jsonSchema201909Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isJSONSchemaElement: isJSONSchemaElement$1,
    isLinkDescriptionElement: isLinkDescriptionElement$1
  }, Symbol.toStringTag, { value: 'Module' }));

  const createToolbox$2 = () => {
    const namespace = createNamespace(jsonSchema201909);
    const predicates = {
      ...jsonSchema201909Predicates,
      isStringElement
    };
    return {
      predicates,
      namespace
    };
  };

  /**
   * @public
   */
  const refract$1 = (value, {
    specPath = ['visitors', 'document', 'objects', 'JSONSchema', '$visitor'],
    plugins = [],
    specificationObj = specification$2
  } = {}) => {
    const element = minimExports.refract(value);
    const resolvedSpec = dereference(specificationObj);

    /**
     * This is where generic ApiDOM becomes semantic (namespace applied).
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const RootVisitorClass = path$1(specPath, resolvedSpec);
    const rootVisitor = new RootVisitorClass({
      specObj: resolvedSpec
    });
    visit$1(element, rootVisitor);

    /**
     * Run plugins only when necessary.
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(rootVisitor.element, plugins, {
      toolboxCreator: createToolbox$2,
      visitorOptions: {
        keyMap: keyMap$2,
        nodeTypeGetter: getNodeType$2
      }
    });
  };

  /**
   * @public
   */
  const createRefractor$1 = specPath => (value, options = {}) => refract$1(value, {
    specPath,
    ...options
  });

  JSONSchema$1.refract = createRefractor$1(['visitors', 'document', 'objects', 'JSONSchema', '$visitor']);
  LinkDescription$1.refract = createRefractor$1(['visitors', 'document', 'objects', 'LinkDescription', '$visitor']);

  /* eslint-disable class-methods-use-this */

  /**
   * @public
   */
  class JSONSchema extends JSONSchema$1 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = 'JSONSchema202012';
    }

    /**
     * Core vocabulary
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/core
     */

    get $dynamicAnchor() {
      return this.get('$dynamicAnchor');
    }
    set $dynamicAnchor($dynamicAnchor) {
      this.set('$dynamicAnchor', $dynamicAnchor);
    }
    get $recursiveAnchor() {
      throw new UnsupportedOperationError('$recursiveAnchor keyword from Core vocabulary has been renamed to $dynamicAnchor.');
    }
    set $recursiveAnchor($recursiveAnchor) {
      throw new UnsupportedOperationError('$recursiveAnchor keyword from Core vocabulary has been renamed to $dynamicAnchor.');
    }
    get $dynamicRef() {
      return this.get('$dynamicRef');
    }
    set $dynamicRef($dynamicRef) {
      this.set('$dynamicRef', $dynamicRef);
    }
    get $recursiveRef() {
      throw new UnsupportedOperationError('$recursiveRef keyword from Core vocabulary has been renamed to $dynamicRef.');
    }
    set $recursiveRef($recursiveRef) {
      throw new UnsupportedOperationError('$recursiveRef keyword from Core vocabulary has been renamed to $dynamicRef.');
    }

    /**
     * Applicator vocabulary
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/applicator
     */

    get prefixItems() {
      return this.get('prefixItems');
    }
    set prefixItems(prefixItems) {
      this.set('prefixItems', prefixItems);
    }
  }

  /* eslint-disable class-methods-use-this */

  /**
   * URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-hyperschema-02#rfc.section.6
   * @public
   */

  class LinkDescription extends LinkDescription$1 {
    /**
     *  Link Target Attributes.
     *
     *  URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-hyperschema-02#rfc.section.6.5
     */
    get targetSchema() {
      return this.get('targetSchema');
    }
    set targetSchema(targetSchema) {
      this.set('targetSchema', targetSchema);
    }

    /**
     *  Link Input.
     *
     *  URI: https://json-schema.org/draft/2019-09/draft-handrews-json-schema-hyperschema-02#input
     */
    get hrefSchema() {
      return this.get('hrefSchema');
    }
    set hrefSchema(hrefSchema) {
      this.set('hrefSchema', hrefSchema);
    }
    get headerSchema() {
      return this.get('headerSchema');
    }
    set headerSchema(headerSchema) {
      this.set('headerSchema', headerSchema);
    }
    get submissionSchema() {
      return this.get('submissionSchema');
    }
    set submissionSchema(submissionSchema) {
      this.set('submissionSchema', submissionSchema);
    }
  }

  /**
   * @public
   */
  const jsonSchema202012 = {
    namespace: options => {
      const {
        base
      } = options;
      base.register('jSONSchema202012', JSONSchema);
      base.register('linkDescription', LinkDescription);
      return base;
    }
  };

  /**
   * @public
   */
  const keyMap$1 = {
    JSONSchema202012Element: ['content'],
    LinkDescriptionElement: ['content'],
    ...keyMapDefault$1
  };

  /**
   * @public
   */
  let JSONSchemaVisitor$1 = class JSONSchemaVisitor extends JSONSchemaVisitor$2 {
    constructor(options) {
      super(options);
      this.element = new JSONSchema();
    }

    // eslint-disable-next-line class-methods-use-this
    get defaultDialectIdentifier() {
      return 'https://json-schema.org/draft/2020-12/schema';
    }
  };

  /**
   * @public
   */

  /**
   * @public
   */
  let PrefixItemsVisitor$1 = class PrefixItemsVisitor extends Mixin(SpecificationVisitor$1, ParentSchemaAwareVisitor, FallbackVisitor$1) {
    constructor(options) {
      super(options);
      this.element = new minimExports.ArrayElement();
      this.element.classes.push('json-schema-prefixItems');
    }
    ArrayElement(arrayElement) {
      arrayElement.forEach(item => {
        const element = this.toRefractedElement(['document', 'objects', 'JSONSchema'], item);
        this.element.push(element);
      });
      this.copyMetaAndAttributes(arrayElement, this.element);
      return BREAK;
    }
  };

  /**
   * @public
   */
  let LinkDescriptionVisitor$1 = class LinkDescriptionVisitor extends LinkDescriptionVisitor$2 {
    constructor(options) {
      super(options);
      this.element = new LinkDescription();
    }
  };

  const specification$1 = pipe(
  // JSON Schema object modifications
  assocPath(['visitors', 'document', 'objects', 'JSONSchema', '$visitor'], JSONSchemaVisitor$1), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$recursiveAnchor']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$dynamicAnchor'], specification$2.visitors.value), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$recursiveRef']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', '$dynamicRef'], specification$2.visitors.value), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'not'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'if'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'then'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'else'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'prefixItems'], PrefixItemsVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'items'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contains'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'additionalProperties'], JSONSchemaVisitor$1), dissocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'additionalItems']), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'propertyNames'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'unevaluatedItems'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'unevaluatedProperties'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'JSONSchema', 'fixedFields', 'contentSchema'], JSONSchemaVisitor$1),
  // Link Description object modifications
  assocPath(['visitors', 'document', 'objects', 'LinkDescription', '$visitor'], LinkDescriptionVisitor$1), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'targetSchema'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'hrefSchema'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'headerSchema'], JSONSchemaVisitor$1), assocPath(['visitors', 'document', 'objects', 'LinkDescription', 'fixedFields', 'submissionSchema'], JSONSchemaVisitor$1))(specification$2);

  /**
   * @public
   */
  const isJSONSchemaElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof JSONSchema || hasBasicElementProps(element) && isElementType('JSONSchema202012', element) && primitiveEq('object', element);
  });

  /**
   * @public
   */
  const isLinkDescriptionElement = createPredicate(({
    hasBasicElementProps,
    isElementType,
    primitiveEq
  }) => {
    return element => element instanceof LinkDescription || hasBasicElementProps(element) && isElementType('linkDescription', element) && primitiveEq('object', element);
  });

  const jsonSchema202012Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isJSONSchemaElement,
    isLinkDescriptionElement
  }, Symbol.toStringTag, { value: 'Module' }));

  const createToolbox$1 = () => {
    const namespace = createNamespace(jsonSchema202012);
    const predicates = {
      ...jsonSchema202012Predicates,
      isStringElement
    };
    return {
      predicates,
      namespace
    };
  };

  /**
   * @public
   */
  const refract = (value, {
    specPath = ['visitors', 'document', 'objects', 'JSONSchema', '$visitor'],
    plugins = [],
    specificationObj = specification$1
  } = {}) => {
    const element = minimExports.refract(value);
    const resolvedSpec = dereference(specificationObj);

    /**
     * This is where generic ApiDOM becomes semantic (namespace applied).
     * We don't allow consumers to hook into this translation.
     * Though we allow consumers to define their onw plugins on already transformed ApiDOM.
     */
    const RootVisitorClass = path$1(specPath, resolvedSpec);
    const rootVisitor = new RootVisitorClass({
      specObj: resolvedSpec
    });
    visit$1(element, rootVisitor);

    /**
     * Run plugins only when necessary.
     * Running plugins visitors means extra single traversal === performance hit.
     */
    return dispatchPluginsSync(rootVisitor.element, plugins, {
      toolboxCreator: createToolbox$1,
      visitorOptions: {
        keyMap: keyMap$1,
        nodeTypeGetter: getNodeType$2
      }
    });
  };

  /**
   * @public
   */
  const createRefractor = specPath => (value, options = {}) => refract(value, {
    specPath,
    ...options
  });

  JSONSchema.refract = createRefractor(['visitors', 'document', 'objects', 'JSONSchema', '$visitor']);
  LinkDescription.refract = createRefractor(['visitors', 'document', 'objects', 'LinkDescription', '$visitor']);

  class Schema extends JSONSchema {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "schema";
    }
    /**
     * OAS base vocabulary
     *
     * URI: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#baseVocabulary
     */
    get discriminator() {
      return this.get("discriminator");
    }
    set discriminator(discriminator) {
      this.set("discriminator", discriminator);
    }
    get xml() {
      return this.get("xml");
    }
    set xml(xml) {
      this.set("xml", xml);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
    /**
     * @deprecated The example property has been deprecated in favor of the JSON Schema examples keyword. Use of example is discouraged, and later versions of this specification may remove it.
     */
    get example() {
      return this.get("example");
    }
    set example(example) {
      this.set("example", example);
    }
  }

  class SecurityRequirement extends SecurityRequirement$1 {
  }

  class SecurityScheme extends SecurityScheme$1 {
  }

  class Server extends Server$1 {
  }

  class ServerVariable extends ServerVariable$1 {
  }

  class Tag extends Tag$1 {
  }

  class Xml extends Xml$1 {
  }

  const openApi3_1 = {
    namespace: (options) => {
      const { base } = options;
      base.register("callback", Callback);
      base.register("components", Components);
      base.register("contact", Contact);
      base.register("discriminator", Discriminator);
      base.register("encoding", Encoding);
      base.register("example", Example);
      base.register("externalDocumentation", ExternalDocumentation);
      base.register("header", Header);
      base.register("info", Info);
      base.register("jsonSchemaDialect", JsonSchemaDialect);
      base.register("license", License);
      base.register("link", Link);
      base.register("mediaType", MediaType);
      base.register("oAuthFlow", OAuthFlow);
      base.register("oAuthFlows", OAuthFlows);
      base.register("openapi", Openapi);
      base.register("openApi3_1", OpenApi3_1);
      base.register("operation", Operation);
      base.register("parameter", Parameter);
      base.register("pathItem", PathItem);
      base.register("paths", Paths);
      base.register("reference", Reference);
      base.register("requestBody", RequestBody);
      base.register("response", Response);
      base.register("responses", Responses);
      base.register("schema", Schema);
      base.register("securityRequirement", SecurityRequirement);
      base.register("securityScheme", SecurityScheme);
      base.register("server", Server);
      base.register("serverVariable", ServerVariable);
      base.register("tag", Tag);
      base.register("xml", Xml);
      return base;
    }
  };

  var __defProp$5 = Object.defineProperty;
  var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$2 = (obj, key, value) => __defNormalProp$5(obj, key + "" , value);
  const _ComponentsPathItems = class _ComponentsPathItems extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsPathItems.primaryClass);
    }
  };
  __publicField$2(_ComponentsPathItems, "primaryClass", "components-path-items");
  let ComponentsPathItems = _ComponentsPathItems;

  var __defProp$4 = Object.defineProperty;
  var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$1 = (obj, key, value) => __defNormalProp$4(obj, key + "" , value);
  const _Webhooks = class _Webhooks extends minimExports.ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_Webhooks.primaryClass);
    }
  };
  __publicField$1(_Webhooks, "primaryClass", "webhooks");
  let Webhooks = _Webhooks;

  var __defProp$3 = Object.defineProperty;
  var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
  var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
  var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$2 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$2.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    if (__getOwnPropSymbols$2)
      for (var prop of __getOwnPropSymbols$2(b)) {
        if (__propIsEnum$2.call(b, prop))
          __defNormalProp$3(a, prop, b[prop]);
      }
    return a;
  };
  const getNodeType = (element) => {
    if (!isElement(element)) {
      return void 0;
    }
    return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
  };
  const keyMap = __spreadValues$2({
    CallbackElement: ["content"],
    ComponentsElement: ["content"],
    ContactElement: ["content"],
    DiscriminatorElement: ["content"],
    Encoding: ["content"],
    Example: ["content"],
    ExternalDocumentationElement: ["content"],
    HeaderElement: ["content"],
    InfoElement: ["content"],
    LicenseElement: ["content"],
    MediaTypeElement: ["content"],
    OAuthFlowElement: ["content"],
    OAuthFlowsElement: ["content"],
    OpenApi3_1Element: ["content"],
    OperationElement: ["content"],
    ParameterElement: ["content"],
    PathItemElement: ["content"],
    PathsElement: ["content"],
    ReferenceElement: ["content"],
    RequestBodyElement: ["content"],
    ResponseElement: ["content"],
    ResponsesElement: ["content"],
    SchemaElement: ["content"],
    SecurityRequirementElement: ["content"],
    SecuritySchemeElement: ["content"],
    ServerElement: ["content"],
    ServerVariableElement: ["content"],
    TagElement: ["content"]
  }, keyMapDefault$1);

  const schema = {
    // concrete types handling (CTs)
    OpenApi3_1Element: {
      info(...args) {
        return new Info(...args);
      },
      servers(...args) {
        return new Servers(...args);
      },
      paths(...args) {
        return new Paths(...args);
      },
      webhooks(...args) {
        return new Webhooks(...args);
      },
      components(...args) {
        return new Components(...args);
      },
      security(...args) {
        return new Security(...args);
      },
      tags(...args) {
        return new Tags(...args);
      },
      externalDocs(...args) {
        return new ExternalDocumentation(...args);
      }
    },
    InfoElement: {
      contact(...args) {
        return new Contact(...args);
      },
      license(...args) {
        return new License(...args);
      }
    },
    ServerElement: {
      variables(...args) {
        return new ServerVariables(...args);
      }
    },
    ServerVariableElement: {
      enum(...args) {
        return new minimExports.ArrayElement(...args);
      }
    },
    PathsElement: {
      "[key: *]": function key(...args) {
        return new PathItem(...args);
      }
    },
    PathItemElement: {
      get(...args) {
        return new Operation(...args);
      },
      put(...args) {
        return new Operation(...args);
      },
      post(...args) {
        return new Operation(...args);
      },
      delete(...args) {
        return new Operation(...args);
      },
      options(...args) {
        return new Operation(...args);
      },
      head(...args) {
        return new Operation(...args);
      },
      patch(...args) {
        return new Operation(...args);
      },
      trace(...args) {
        return new Operation(...args);
      },
      servers(...args) {
        return new PathItemServers(...args);
      },
      parameters(...args) {
        return new PathItemParameters(...args);
      }
    },
    OperationElement: {
      tags(...args) {
        return new OperationTags(...args);
      },
      externalDocs(...args) {
        return new ExternalDocumentation(...args);
      },
      parameters(...args) {
        return new OperationParameters(...args);
      },
      requestBody(...args) {
        return new RequestBody(...args);
      },
      responses(...args) {
        return new Responses(...args);
      },
      callbacks(...args) {
        return new OperationCallbacks(...args);
      },
      security(...args) {
        return new OperationSecurity(...args);
      },
      servers(...args) {
        return new OperationServers(...args);
      }
    },
    ParameterElement: {
      schema(...args) {
        return new Schema(...args);
      },
      examples(...args) {
        return new ParameterExamples(...args);
      },
      content(...args) {
        return new ParameterContent(...args);
      }
    },
    RequestBodyElement: {
      content(...args) {
        return new RequestBodyContent(...args);
      }
    },
    MediaTypeElement: {
      schema(...args) {
        return new Schema(...args);
      },
      examples(...args) {
        return new MediaTypeExamples(...args);
      },
      encoding(...args) {
        return new MediaTypeEncoding(...args);
      }
    },
    EncodingElement: {
      headers(...args) {
        return new EncodingHeaders(...args);
      }
    },
    ResponsesElement: {
      "[key: *]": function key2(...args) {
        return new Response(...args);
      }
    },
    ResponseElement: {
      headers(...args) {
        return new ResponseHeaders(...args);
      },
      content(...args) {
        return new ResponseContent(...args);
      },
      links(...args) {
        return new ResponseLinks(...args);
      }
    },
    CallbackElement: {
      "[key: *]": function key3(...args) {
        return new PathItem(...args);
      }
    },
    LinkElement: {
      server(...args) {
        return new Server(...args);
      }
    },
    HeaderElement: {
      schema(...args) {
        return new Schema(...args);
      },
      examples(...args) {
        return new HeaderExamples(...args);
      },
      content(...args) {
        return new HeaderContent(...args);
      }
    },
    ComponentsElement: {
      schemas(...args) {
        return new ComponentsSchemas(...args);
      },
      responses(...args) {
        return new ComponentsResponses(...args);
      },
      parameters(...args) {
        return new ComponentsParameters(...args);
      },
      examples(...args) {
        return new ComponentsExamples(...args);
      },
      requestBodies(...args) {
        return new ComponentsRequestBodies(...args);
      },
      headers(...args) {
        return new ComponentsHeaders(...args);
      },
      securitySchemes(...args) {
        return new ComponentsSecuritySchemes(...args);
      },
      links(...args) {
        return new ComponentsLinks(...args);
      },
      callbacks(...args) {
        return new ComponentsCallbacks(...args);
      },
      pathItems(...args) {
        return new ComponentsPathItems(...args);
      }
    },
    SecurityRequirementElement: {
      "[key: *]": function key4(...args) {
        return new minimExports.ArrayElement(...args);
      }
    },
    TagElement: {
      externalDocs(...args) {
        return new ExternalDocumentation(...args);
      }
    },
    SchemaElement: {
      $vocabulary(...args) {
        const element = new minimExports.ObjectElement(...args);
        element.classes.push("json-schema-$vocabulary");
        return element;
      },
      $defs(...args) {
        const element = new minimExports.ObjectElement(...args);
        element.classes.push("json-schema-$defs");
        return element;
      },
      allOf(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-allOf");
        return element;
      },
      anyOf(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-anyOf");
        return element;
      },
      oneOf(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-oneOf");
        return element;
      },
      not(...args) {
        return new Schema(...args);
      },
      if(...args) {
        return new Schema(...args);
      },
      then(...args) {
        return new Schema(...args);
      },
      else(...args) {
        return new Schema(...args);
      },
      dependentSchemas(...args) {
        const element = new minimExports.ObjectElement(...args);
        element.classes.push("json-schema-dependentSchemas");
        return element;
      },
      prefixItems(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-prefixItems");
        return element;
      },
      items(...args) {
        return new Schema(...args);
      },
      contains(...args) {
        return new Schema(...args);
      },
      properties(...args) {
        const element = new minimExports.ObjectElement(...args);
        element.classes.push("json-schema-properties");
        return element;
      },
      patternProperties(...args) {
        const element = new minimExports.ObjectElement(...args);
        element.classes.push("json-schema-patternProperties");
        return element;
      },
      additionalProperties(...args) {
        return new Schema(...args);
      },
      propertyNames(...args) {
        return new Schema(...args);
      },
      unevaluatedItems(...args) {
        return new Schema(...args);
      },
      unevaluatedProperties(...args) {
        return new Schema(...args);
      },
      type(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-type");
        return element;
      },
      enum(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-enum");
        return element;
      },
      required(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-required");
        return element;
      },
      dependentRequired(...args) {
        const element = new minimExports.ObjectElement(...args);
        element.classes.push("json-schema-dependentRequired");
        return element;
      },
      examples(...args) {
        const element = new minimExports.ArrayElement(...args);
        element.classes.push("json-schema-examples");
        return element;
      },
      contentSchema(...args) {
        return new Schema(...args);
      },
      discriminator(...args) {
        return new Discriminator(...args);
      },
      xml(...args) {
        return new Xml(...args);
      },
      externalDocs(...args) {
        return new ExternalDocumentation(...args);
      }
    },
    DiscriminatorElement: {
      mapping(...args) {
        return new DiscriminatorMapping(...args);
      }
    },
    SecuritySchemeElement: {
      flows(...args) {
        return new OAuthFlows(...args);
      }
    },
    OAuthFlowsElement: {
      implicit(...args) {
        return new OAuthFlow(...args);
      },
      password(...args) {
        return new OAuthFlow(...args);
      },
      clientCredentials(...args) {
        return new OAuthFlow(...args);
      },
      authorizationCode(...args) {
        return new OAuthFlow(...args);
      }
    },
    OAuthFlowElement: {
      scopes(...args) {
        return new OAuthFlowScopes(...args);
      }
    },
    // non-concrete types handling (NCEs)
    [Webhooks.primaryClass]: {
      "[key: *]": function key5(...args) {
        return new PathItem(...args);
      }
    },
    [ServerVariables.primaryClass]: {
      "[key: *]": function key6(...args) {
        return new ServerVariable(...args);
      }
    },
    [ComponentsSchemas.primaryClass]: {
      "[key: *]": function key7(...args) {
        return new Schema(...args);
      }
    },
    [ComponentsResponses.primaryClass]: {
      "[key: *]": function key8(...args) {
        return new Response(...args);
      }
    },
    [ComponentsParameters.primaryClass]: {
      "[key: *]": function key9(...args) {
        return new Parameter(...args);
      }
    },
    [ComponentsExamples.primaryClass]: {
      "[key: *]": function key10(...args) {
        return new Example(...args);
      }
    },
    [ComponentsRequestBodies.primaryClass]: {
      "[key: *]": function key11(...args) {
        return new RequestBody(...args);
      }
    },
    [ComponentsHeaders.primaryClass]: {
      "[key: *]": function key12(...args) {
        return new Header(...args);
      }
    },
    [ComponentsSecuritySchemes.primaryClass]: {
      "[key: *]": function key13(...args) {
        return new SecurityScheme(...args);
      }
    },
    [ComponentsLinks.primaryClass]: {
      "[key: *]": function key14(...args) {
        return new Link(...args);
      }
    },
    [ComponentsCallbacks.primaryClass]: {
      "[key: *]": function key15(...args) {
        return new Callback(...args);
      }
    },
    [ComponentsPathItems.primaryClass]: {
      "[key: *]": function key16(...args) {
        return new PathItem(...args);
      }
    },
    [OperationCallbacks.primaryClass]: {
      "[key: *]": function key17(...args) {
        return new Callback(...args);
      }
    },
    [ParameterExamples.primaryClass]: {
      "[key: *]": function key18(...args) {
        return new Example(...args);
      }
    },
    [ParameterContent.primaryClass]: {
      "[key: *]": function key19(...args) {
        return new MediaType(...args);
      }
    },
    [RequestBodyContent.primaryClass]: {
      "[key: *]": function key20(...args) {
        return new MediaType(...args);
      }
    },
    [MediaTypeExamples.primaryClass]: {
      "[key: *]": function key21(...args) {
        return new Example(...args);
      }
    },
    [MediaTypeEncoding.primaryClass]: {
      "[key: *]": function key22(...args) {
        return new Encoding(...args);
      }
    },
    [EncodingHeaders.primaryClass]: {
      "[key: *]": function key23(...args) {
        return new Header(...args);
      }
    },
    [ResponseHeaders.primaryClass]: {
      "[key: *]": function key24(...args) {
        return new Header(...args);
      }
    },
    [ResponseContent.primaryClass]: {
      "[key: *]": function key25(...args) {
        return new MediaType(...args);
      }
    },
    [ResponseLinks.primaryClass]: {
      "[key: *]": function key26(...args) {
        return new Link(...args);
      }
    },
    "json-schema-$defs": {
      "[key: *]": function key27(...args) {
        return new Schema(...args);
      }
    },
    "json-schema-dependentSchemas": {
      "[key: *]": function key28(...args) {
        return new Schema(...args);
      }
    },
    "json-schema-properties": {
      "[key: *]": function key29(...args) {
        return new Schema(...args);
      }
    },
    [Servers.primaryClass]: {
      "<*>": (...args) => new Server(...args)
    },
    [Security.primaryClass]: {
      "<*>": function asterisk(...args) {
        return new SecurityRequirement(...args);
      }
    },
    [Tags.primaryClass]: {
      "<*>": function asterisk2(...args) {
        return new Tag(...args);
      }
    },
    [PathItemServers.primaryClass]: {
      "<*>": function asterisk3(...args) {
        return new Server(...args);
      }
    },
    [PathItemParameters.primaryClass]: {
      "<*>": function asterisk4(...args) {
        return new Parameter(...args);
      }
    },
    [OperationParameters.primaryClass]: {
      "<*>": function asterisk5(...args) {
        return new Parameter(...args);
      }
    },
    [OperationSecurity.primaryClass]: {
      "<*>": function asterisk6(...args) {
        return new SecurityRequirement(...args);
      }
    },
    [OperationServers.primaryClass]: {
      "<*>": function asterisk7(...args) {
        return new Server(...args);
      }
    },
    "json-schema-allOf": {
      "<*>": function asterisk8(...args) {
        return new Schema(...args);
      }
    },
    "json-schema-anyOf": {
      "<*>": function asterisk9(...args) {
        return new Schema(...args);
      }
    },
    "json-schema-oneOf": {
      "<*>": function asterisk10(...args) {
        return new Schema(...args);
      }
    },
    "json-schema-prefixItems": {
      "<*>": function asterisk11(...args) {
        return new Schema(...args);
      }
    }
  };
  const findElementFactory = (ancestor, keyName) => {
    const elementType = getNodeType(ancestor);
    const keyMapping = schema[elementType] || schema[serializer(ancestor.classes.first)];
    return typeof keyMapping === "undefined" ? void 0 : Object.prototype.hasOwnProperty.call(keyMapping, "[key: *]") ? keyMapping["[key: *]"] : keyMapping[keyName];
  };
  const plugin$7 = () => ({ predicates }) => {
    const isEmptyElement = (element) => predicates.isStringElement(element) && predicates.includesClasses(["yaml-e-node", "yaml-e-scalar"], element);
    return {
      visitor: {
        StringElement(element, key30, parent, path, ancestors) {
          if (!isEmptyElement(element)) return void 0;
          const lineage = [...ancestors, parent].filter(predicates.isElement);
          const parentElement = lineage[lineage.length - 1];
          let elementFactory;
          let context;
          if (predicates.isArrayElement(parentElement)) {
            context = element;
            elementFactory = findElementFactory(parentElement, "<*>");
          } else if (predicates.isMemberElement(parentElement)) {
            context = lineage[lineage.length - 2];
            elementFactory = findElementFactory(context, serializer(parentElement.key));
          }
          if (typeof elementFactory !== "function") return void 0;
          const result = elementFactory.call(
            { context },
            void 0,
            cloneDeep(element.meta),
            cloneDeep(element.attributes)
          );
          return assignSourceMap(result, element);
        }
      }
    };
  };

  var __defProp$2 = Object.defineProperty;
  var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp$2(obj, key + "" , value);
  class NormalizeStorage {
    constructor(storageElement, storageField, storageSubField) {
      this.storageElement = storageElement;
      this.storageField = storageField;
      this.storageSubField = storageSubField;
      __publicField(this, "internalStore");
    }
    get store() {
      if (!this.internalStore) {
        let rootStore = this.storageElement.get(this.storageField);
        if (!isObjectElement(rootStore)) {
          rootStore = new minimExports.ObjectElement();
          this.storageElement.set(this.storageField, rootStore);
        }
        let store = rootStore.get(this.storageSubField);
        if (!isArrayElement(store)) {
          store = new minimExports.ArrayElement();
          rootStore.set(this.storageSubField, store);
        }
        this.internalStore = store;
      }
      return this.internalStore;
    }
    append(pointer) {
      if (!this.includes(pointer)) {
        this.store.push(pointer);
      }
    }
    includes(pointer) {
      return this.store.includes(pointer);
    }
  }

  const plugin$6 = ({ storageField = "x-normalized" } = {}) => (toolbox) => {
    const { predicates, ancestorLineageToJSONPointer } = toolbox;
    const parameterEquals = (parameter1, parameter2) => {
      if (!predicates.isParameterElement(parameter1)) return false;
      if (!predicates.isParameterElement(parameter2)) return false;
      if (!predicates.isStringElement(parameter1.name)) return false;
      if (!predicates.isStringElement(parameter1.in)) return false;
      if (!predicates.isStringElement(parameter2.name)) return false;
      if (!predicates.isStringElement(parameter2.in)) return false;
      return serializer(parameter1.name) === serializer(parameter2.name) && serializer(parameter1.in) === serializer(parameter2.in);
    };
    const pathItemParameters = [];
    let storage;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(element) {
            storage = new NormalizeStorage(element, storageField, "parameters");
          },
          leave() {
            storage = void 0;
          }
        },
        PathItemElement: {
          enter(pathItemElement, key, parent, path, ancestors) {
            if (ancestors.some(predicates.isComponentsElement)) {
              return;
            }
            const { parameters } = pathItemElement;
            if (predicates.isArrayElement(parameters)) {
              pathItemParameters.push([...parameters.content]);
            } else {
              pathItemParameters.push([]);
            }
          },
          leave() {
            pathItemParameters.pop();
          }
        },
        OperationElement: {
          leave(operationElement, key, parent, path, ancestors) {
            const parentPathItemParameters = last(pathItemParameters);
            if (!Array.isArray(parentPathItemParameters) || parentPathItemParameters.length === 0) {
              return;
            }
            const operationJSONPointer = ancestorLineageToJSONPointer([
              ...ancestors,
              parent,
              operationElement
            ]);
            if (storage.includes(operationJSONPointer)) {
              return;
            }
            const operationParameters = pathOr(
              [],
              ["parameters", "content"],
              operationElement
            );
            const mergedParameters = uniqWith(parameterEquals, [
              ...operationParameters,
              ...parentPathItemParameters
            ]);
            operationElement.parameters = new OperationParameters(mergedParameters);
            storage.append(operationJSONPointer);
          }
        }
      }
    };
  };

  const plugin$5 = ({ storageField = "x-normalized" } = {}) => (toolbox) => {
    const { predicates, ancestorLineageToJSONPointer } = toolbox;
    let topLevelSecurity;
    let storage;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(openapiElement) {
            storage = new NormalizeStorage(openapiElement, storageField, "security-requirements");
            if (predicates.isArrayElement(openapiElement.security)) {
              topLevelSecurity = openapiElement.security;
            }
          },
          leave() {
            storage = void 0;
            topLevelSecurity = void 0;
          }
        },
        OperationElement: {
          leave(operationElement, key, parent, path, ancestors) {
            if (ancestors.some(predicates.isComponentsElement)) {
              return;
            }
            const operationJSONPointer = ancestorLineageToJSONPointer([
              ...ancestors,
              parent,
              operationElement
            ]);
            if (storage.includes(operationJSONPointer)) {
              return;
            }
            const missingOperationLevelSecurity = typeof operationElement.security === "undefined";
            const hasTopLevelSecurity = typeof topLevelSecurity !== "undefined";
            if (missingOperationLevelSecurity && hasTopLevelSecurity) {
              operationElement.security = new OperationSecurity(topLevelSecurity == null ? void 0 : topLevelSecurity.content);
              storage.append(operationJSONPointer);
            }
          }
        }
      }
    };
  };

  const plugin$4 = ({ storageField = "x-normalized" } = {}) => (toolbox) => {
    const { namespace, ancestorLineageToJSONPointer, predicates } = toolbox;
    let storage;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(openapiElement) {
            const isServersUndefined = typeof openapiElement.servers === "undefined";
            const isServersArrayElement = predicates.isArrayElement(openapiElement.servers);
            const isServersEmpty = isServersArrayElement && openapiElement.servers.length === 0;
            const defaultServer = namespace.elements.Server.refract({ url: "/" });
            if (isServersUndefined || !isServersArrayElement) {
              openapiElement.servers = new Servers([defaultServer]);
            } else if (isServersArrayElement && isServersEmpty) {
              openapiElement.servers.push(defaultServer);
            }
            storage = new NormalizeStorage(openapiElement, storageField, "servers");
          },
          leave() {
            storage = void 0;
          }
        },
        PathItemElement(pathItemElement, key, parent, path, ancestors) {
          var _a;
          if (ancestors.some(predicates.isComponentsElement)) return;
          if (!ancestors.some(predicates.isOpenApi3_1Element)) return;
          const pathItemJSONPointer = ancestorLineageToJSONPointer([
            ...ancestors,
            parent,
            pathItemElement
          ]);
          if (storage.includes(pathItemJSONPointer)) {
            return;
          }
          const parentOpenapiElement = ancestors.find(predicates.isOpenApi3_1Element);
          const isServersUndefined = typeof pathItemElement.servers === "undefined";
          const isServersArrayElement = predicates.isArrayElement(pathItemElement.servers);
          const isServersEmpty = isServersArrayElement && pathItemElement.servers.length === 0;
          if (predicates.isOpenApi3_1Element(parentOpenapiElement)) {
            const openapiServersContent = (_a = parentOpenapiElement.servers) == null ? void 0 : _a.content;
            const openapiServers = openapiServersContent != null ? openapiServersContent : [];
            if (isServersUndefined || !isServersArrayElement) {
              pathItemElement.servers = new PathItemServers(openapiServers);
            } else if (isServersArrayElement && isServersEmpty) {
              openapiServers.forEach((server) => {
                pathItemElement.servers.push(server);
              });
            }
            storage.append(pathItemJSONPointer);
          }
        },
        OperationElement(operationElement, key, parent, path, ancestors) {
          var _a;
          if (ancestors.some(predicates.isComponentsElement)) return;
          if (!ancestors.some(predicates.isOpenApi3_1Element)) return;
          const operationJSONPointer = ancestorLineageToJSONPointer([
            ...ancestors,
            parent,
            operationElement
          ]);
          if (storage.includes(operationJSONPointer)) {
            return;
          }
          const parentPathItemElement = [...ancestors].reverse().find(predicates.isPathItemElement);
          const isServersUndefined = typeof operationElement.servers === "undefined";
          const isServersArrayElement = predicates.isArrayElement(operationElement.servers);
          const isServersEmpty = isServersArrayElement && operationElement.servers.length === 0;
          if (predicates.isPathItemElement(parentPathItemElement)) {
            const pathItemServersContent = (_a = parentPathItemElement.servers) == null ? void 0 : _a.content;
            const pathItemServers = pathItemServersContent != null ? pathItemServersContent : [];
            if (isServersUndefined || !isServersArrayElement) {
              operationElement.servers = new OperationServers(pathItemServers);
            } else if (isServersArrayElement && isServersEmpty) {
              pathItemServers.forEach((server) => {
                operationElement.servers.push(server);
              });
            }
            storage.append(operationJSONPointer);
          }
        }
      }
    };
  };

  const removeSpaces = (operationId) => {
    return operationId.replace(/\s/g, "");
  };
  const replaceSpecialCharsWithUnderscore = (operationId) => {
    return operationId.replace(/\W/gi, "_");
  };
  const createNormalizedOperationId = (path, method) => {
    const normalizedMethod = replaceSpecialCharsWithUnderscore(removeSpaces(method.toLowerCase()));
    const normalizedPath = replaceSpecialCharsWithUnderscore(removeSpaces(path));
    return `${normalizedMethod}${normalizedPath}`;
  };
  const normalizeOperationId = (operationId, path, method) => {
    const withoutSpaces = removeSpaces(operationId);
    if (withoutSpaces.length > 0) {
      return replaceSpecialCharsWithUnderscore(withoutSpaces);
    }
    return createNormalizedOperationId(path, method);
  };
  const plugin$3 = ({
    storageField = "x-normalized",
    operationIdNormalizer = normalizeOperationId
  } = {}) => (toolbox) => {
    const { predicates, ancestorLineageToJSONPointer, namespace } = toolbox;
    const pathTemplates = [];
    const normalizedOperations = [];
    const links = [];
    let storage;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(element) {
            storage = new NormalizeStorage(element, storageField, "operation-ids");
          },
          leave() {
            const normalizedOperationGroups = groupBy((operationElement) => {
              return serializer(operationElement.operationId);
            }, normalizedOperations);
            Object.entries(normalizedOperationGroups).forEach(
              ([normalizedOperationId, operationElements]) => {
                if (!Array.isArray(operationElements)) return;
                if (operationElements.length <= 1) return;
                operationElements.forEach((operationElement, index) => {
                  const indexedNormalizedOperationId = `${normalizedOperationId}${index + 1}`;
                  operationElement.operationId = new namespace.elements.String(
                    indexedNormalizedOperationId
                  );
                });
              }
            );
            links.forEach((linkElement) => {
              if (typeof linkElement.operationId === "undefined") return;
              const linkOperationId = String(serializer(linkElement.operationId));
              const operationElement = normalizedOperations.find((normalizedOperationElement) => {
                const originalOperationId = serializer(
                  normalizedOperationElement.meta.get("originalOperationId")
                );
                return originalOperationId === linkOperationId;
              });
              if (typeof operationElement === "undefined") return;
              linkElement.operationId = cloneDeep.safe(operationElement.operationId);
              linkElement.meta.set("originalOperationId", linkOperationId);
              linkElement.set("__originalOperationId", linkOperationId);
            });
            normalizedOperations.length = 0;
            links.length = 0;
            storage = void 0;
          }
        },
        PathItemElement: {
          enter(pathItemElement) {
            const pathTemplate = defaultTo("path", serializer(pathItemElement.meta.get("path")));
            pathTemplates.push(pathTemplate);
          },
          leave() {
            pathTemplates.pop();
          }
        },
        OperationElement: {
          enter(operationElement, key, parent, path, ancestors) {
            if (typeof operationElement.operationId === "undefined") return;
            const operationJSONPointer = ancestorLineageToJSONPointer([
              ...ancestors,
              parent,
              operationElement
            ]);
            if (storage.includes(operationJSONPointer)) {
              return;
            }
            const originalOperationId = String(serializer(operationElement.operationId));
            const pathTemplate = last(pathTemplates);
            const method = defaultTo(
              "method",
              serializer(operationElement.meta.get("http-method"))
            );
            const normalizedOperationId = operationIdNormalizer(
              originalOperationId,
              pathTemplate,
              method
            );
            if (originalOperationId === normalizedOperationId) return;
            operationElement.operationId = new namespace.elements.String(normalizedOperationId);
            operationElement.set("__originalOperationId", originalOperationId);
            operationElement.meta.set("originalOperationId", originalOperationId);
            normalizedOperations.push(operationElement);
            storage.append(operationJSONPointer);
          }
        },
        LinkElement: {
          leave(linkElement) {
            if (!predicates.isLinkElement(linkElement)) return;
            if (typeof linkElement.operationId === "undefined") return;
            links.push(linkElement);
          }
        }
      }
    };
  };

  const plugin$2 = ({ storageField = "x-normalized" } = {}) => (toolbox) => {
    const { predicates, ancestorLineageToJSONPointer } = toolbox;
    let storage;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(element) {
            storage = new NormalizeStorage(element, storageField, "parameter-examples");
          },
          leave() {
            storage = void 0;
          }
        },
        ParameterElement: {
          leave(parameterElement, key, parent, path, ancestors) {
            var _a, _b;
            if (ancestors.some(predicates.isComponentsElement)) {
              return;
            }
            if (typeof parameterElement.schema === "undefined" || !predicates.isSchemaElement(parameterElement.schema)) {
              return;
            }
            if (typeof ((_a = parameterElement.schema) == null ? void 0 : _a.example) === "undefined" && typeof ((_b = parameterElement.schema) == null ? void 0 : _b.examples) === "undefined") {
              return;
            }
            const parameterJSONPointer = ancestorLineageToJSONPointer([
              ...ancestors,
              parent,
              parameterElement
            ]);
            if (storage.includes(parameterJSONPointer)) {
              return;
            }
            if (typeof parameterElement.examples !== "undefined" && predicates.isObjectElement(parameterElement.examples)) {
              const examples = parameterElement.examples.map((example) => {
                return cloneDeep.safe(example.value);
              });
              if (typeof parameterElement.schema.examples !== "undefined") {
                parameterElement.schema.set("examples", examples);
                storage.append(parameterJSONPointer);
              }
              if (typeof parameterElement.schema.example !== "undefined") {
                parameterElement.schema.set("example", examples[0]);
                storage.append(parameterJSONPointer);
              }
              return;
            }
            if (typeof parameterElement.example !== "undefined") {
              if (typeof parameterElement.schema.examples !== "undefined") {
                parameterElement.schema.set("examples", [cloneDeep(parameterElement.example)]);
                storage.append(parameterJSONPointer);
              }
              if (typeof parameterElement.schema.example !== "undefined") {
                parameterElement.schema.set("example", cloneDeep(parameterElement.example));
                storage.append(parameterJSONPointer);
              }
            }
          }
        }
      }
    };
  };

  const plugin$1 = ({ storageField = "x-normalized" } = {}) => (toolbox) => {
    const { predicates, ancestorLineageToJSONPointer } = toolbox;
    let storage;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(element) {
            storage = new NormalizeStorage(element, storageField, "header-examples");
          },
          leave() {
            storage = void 0;
          }
        },
        HeaderElement: {
          leave(headerElement, key, parent, path, ancestors) {
            var _a, _b;
            if (ancestors.some(predicates.isComponentsElement)) {
              return;
            }
            if (typeof headerElement.schema === "undefined" || !predicates.isSchemaElement(headerElement.schema)) {
              return;
            }
            if (typeof ((_a = headerElement.schema) == null ? void 0 : _a.example) === "undefined" && typeof ((_b = headerElement.schema) == null ? void 0 : _b.examples) === "undefined") {
              return;
            }
            const headerJSONPointer = ancestorLineageToJSONPointer([
              ...ancestors,
              parent,
              headerElement
            ]);
            if (storage.includes(headerJSONPointer)) {
              return;
            }
            if (typeof headerElement.examples !== "undefined" && predicates.isObjectElement(headerElement.examples)) {
              const examples = headerElement.examples.map((example) => {
                return cloneDeep.safe(example.value);
              });
              if (typeof headerElement.schema.examples !== "undefined") {
                headerElement.schema.set("examples", examples);
                storage.append(headerJSONPointer);
              }
              if (typeof headerElement.schema.example !== "undefined") {
                headerElement.schema.set("example", examples[0]);
                storage.append(headerJSONPointer);
              }
              return;
            }
            if (typeof headerElement.example !== "undefined") {
              if (typeof headerElement.schema.examples !== "undefined") {
                headerElement.schema.set("examples", [cloneDeep(headerElement.example)]);
                storage.append(headerJSONPointer);
              }
              if (typeof headerElement.schema.example !== "undefined") {
                headerElement.schema.set("example", cloneDeep(headerElement.example));
                storage.append(headerJSONPointer);
              }
            }
          }
        }
      }
    };
  };

  const isCallbackElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Callback || hasBasicElementProps(element) && isElementType("callback", element) && primitiveEq("object", element);
    }
  );
  const isComponentsElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Components || hasBasicElementProps(element) && isElementType("components", element) && primitiveEq("object", element);
    }
  );
  const isContactElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Contact || hasBasicElementProps(element) && isElementType("contact", element) && primitiveEq("object", element);
    }
  );
  const isExampleElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Example || hasBasicElementProps(element) && isElementType("example", element) && primitiveEq("object", element);
    }
  );
  const isExternalDocumentationElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof ExternalDocumentation || hasBasicElementProps(element) && isElementType("externalDocumentation", element) && primitiveEq("object", element);
    }
  );
  const isHeaderElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Header || hasBasicElementProps(element) && isElementType("header", element) && primitiveEq("object", element);
    }
  );
  const isInfoElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Info || hasBasicElementProps(element) && isElementType("info", element) && primitiveEq("object", element);
    }
  );
  const isJsonSchemaDialectElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof JsonSchemaDialect || hasBasicElementProps(element) && isElementType("jsonSchemaDialect", element) && primitiveEq("string", element);
    }
  );
  const isLicenseElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof License || hasBasicElementProps(element) && isElementType("license", element) && primitiveEq("object", element);
    }
  );
  const isLinkElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Link || hasBasicElementProps(element) && isElementType("link", element) && primitiveEq("object", element);
    }
  );
  const isOpenapiElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Openapi || hasBasicElementProps(element) && isElementType("openapi", element) && primitiveEq("string", element);
    }
  );
  const isOpenApi3_1Element = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq, hasClass }) => {
      return (element) => element instanceof OpenApi3_1 || hasBasicElementProps(element) && isElementType("openApi3_1", element) && primitiveEq("object", element) && hasClass("api", element);
    }
  );
  const isOperationElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Operation || hasBasicElementProps(element) && isElementType("operation", element) && primitiveEq("object", element);
    }
  );
  const isParameterElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Parameter || hasBasicElementProps(element) && isElementType("parameter", element) && primitiveEq("object", element);
    }
  );
  const isPathItemElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof PathItem || hasBasicElementProps(element) && isElementType("pathItem", element) && primitiveEq("object", element);
    }
  );
  const isPathItemElementExternal = (element) => {
    if (!isPathItemElement(element)) {
      return false;
    }
    if (!isStringElement(element.$ref)) {
      return false;
    }
    const value = serializer(element.$ref);
    return typeof value === "string" && value.length > 0 && !value.startsWith("#");
  };
  const isPathsElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Paths || hasBasicElementProps(element) && isElementType("paths", element) && primitiveEq("object", element);
    }
  );
  const isReferenceElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Reference || hasBasicElementProps(element) && isElementType("reference", element) && primitiveEq("object", element);
    }
  );
  const isReferenceElementExternal = (element) => {
    if (!isReferenceElement(element)) {
      return false;
    }
    if (!isStringElement(element.$ref)) {
      return false;
    }
    const value = serializer(element.$ref);
    return typeof value === "string" && value.length > 0 && !value.startsWith("#");
  };
  const isRequestBodyElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof RequestBody || hasBasicElementProps(element) && isElementType("requestBody", element) && primitiveEq("object", element);
    }
  );
  const isResponseElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Response || hasBasicElementProps(element) && isElementType("response", element) && primitiveEq("object", element);
    }
  );
  const isResponsesElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Responses || hasBasicElementProps(element) && isElementType("responses", element) && primitiveEq("object", element);
    }
  );
  const isSchemaElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Schema || hasBasicElementProps(element) && isElementType("schema", element) && primitiveEq("object", element);
    }
  );
  const isBooleanJsonSchemaElement = (element) => {
    return isBooleanElement(element) && element.classes.includes("boolean-json-schema");
  };
  const isSecurityRequirementElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof SecurityRequirement || hasBasicElementProps(element) && isElementType("securityRequirement", element) && primitiveEq("object", element);
    }
  );
  const isSecuritySchemeElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof SecurityScheme || hasBasicElementProps(element) && isElementType("securityScheme", element) && primitiveEq("object", element);
    }
  );
  const isServerElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof Server || hasBasicElementProps(element) && isElementType("server", element) && primitiveEq("object", element);
    }
  );
  const isServerVariableElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof ServerVariable || hasBasicElementProps(element) && isElementType("serverVariable", element) && primitiveEq("object", element);
    }
  );
  const isMediaTypeElement = createPredicate(
    ({ hasBasicElementProps, isElementType, primitiveEq }) => {
      return (element) => element instanceof MediaType || hasBasicElementProps(element) && isElementType("mediaType", element) && primitiveEq("object", element);
    }
  );

  const openApi3_1Predicates = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    isBooleanJsonSchemaElement,
    isCallbackElement,
    isComponentsElement,
    isContactElement,
    isExampleElement,
    isExternalDocumentationElement,
    isHeaderElement,
    isInfoElement,
    isJsonSchemaDialectElement,
    isLicenseElement,
    isLinkElement,
    isMediaTypeElement,
    isOpenApi3_1Element,
    isOpenapiElement,
    isOperationElement,
    isParameterElement,
    isPathItemElement,
    isPathItemElementExternal,
    isPathsElement,
    isReferenceElement,
    isReferenceElementExternal,
    isRequestBodyElement,
    isResponseElement,
    isResponsesElement,
    isSchemaElement,
    isSecurityRequirementElement,
    isSecuritySchemeElement,
    isServerElement,
    isServerVariableElement
  }, Symbol.toStringTag, { value: 'Module' }));

  const plugin = ({ storageField = "x-normalized", baseURI = "" } = {}) => (toolbox) => {
    const { ancestorLineageToJSONPointer } = toolbox;
    let storage;
    let allOfDiscriminatorMapping;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(element) {
            var _a;
            storage = new NormalizeStorage(element, storageField, "discriminator-mapping");
            allOfDiscriminatorMapping = (_a = element.getMetaProperty("allOfDiscriminatorMapping")) != null ? _a : new minimExports.ObjectElement();
          },
          leave() {
            storage = void 0;
          }
        },
        SchemaElement: {
          leave(schemaElement, key, parent, path, ancestors) {
            var _a, _b;
            if (!isDiscriminatorElement(schemaElement.discriminator)) {
              return;
            }
            const schemaJSONPointer = ancestorLineageToJSONPointer([
              ...ancestors,
              parent,
              schemaElement
            ]);
            if (storage.includes(schemaJSONPointer)) {
              return;
            }
            if (isArrayElement(schemaElement.oneOf) && isArrayElement(schemaElement.anyOf)) {
              return;
            }
            const parentElement = ancestors[ancestors.length - 1];
            const schemaName = schemaElement.getMetaProperty("schemaName");
            const allOfMapping = allOfDiscriminatorMapping.getMember(serializer(schemaName));
            const hasAllOfMapping = (
              // @ts-ignore
              allOfMapping && !((_a = parentElement == null ? void 0 : parentElement.classes) == null ? void 0 : _a.contains("json-schema-allOf"))
            );
            if (!isArrayElement(schemaElement.oneOf) && !isArrayElement(schemaElement.anyOf) && !hasAllOfMapping) {
              return;
            }
            const mapping = (_b = schemaElement.discriminator.get("mapping")) != null ? _b : new minimExports.ObjectElement();
            const normalizedMapping = new minimExports.ObjectElement();
            let isNormalized = true;
            const items = isArrayElement(schemaElement.oneOf) ? schemaElement.oneOf : isArrayElement(schemaElement.anyOf) ? schemaElement.anyOf : allOfMapping.value;
            items.forEach((item) => {
              if (!isSchemaElement(item)) {
                return;
              }
              if (isReferenceLikeElement(item)) {
                isNormalized = false;
                return;
              }
              const metaRefFields = serializer(item.getMetaProperty("ref-fields"));
              const metaRefOrigin = serializer(item.getMetaProperty("ref-origin"));
              const metaSchemaName = serializer(item.getMetaProperty("schemaName"));
              if (!hasAllOfMapping && (metaRefOrigin !== baseURI || !metaSchemaName && metaRefFields)) {
                let hasMatchingMapping = false;
                mapping.forEach((mappingValue, mappingKey) => {
                  var _a2;
                  const mappingValueSchema = mappingValue.getMetaProperty("ref-schema");
                  const mappingValueSchemaRefBaseURI = (_a2 = mappingValueSchema == null ? void 0 : mappingValueSchema.getMetaProperty("ref-fields")) == null ? void 0 : _a2.get("$refBaseURI");
                  if (mappingValueSchemaRefBaseURI == null ? void 0 : mappingValueSchemaRefBaseURI.equals(metaRefFields == null ? void 0 : metaRefFields.$refBaseURI)) {
                    normalizedMapping.set(serializer(mappingKey), cloneShallow(item));
                    hasMatchingMapping = true;
                  }
                });
                if (!hasMatchingMapping) {
                  isNormalized = false;
                }
                return;
              }
              if (metaSchemaName) {
                let hasMatchingMapping = false;
                mapping.forEach((mappingValue, mappingKey) => {
                  var _a2;
                  const mappingValueSchema = mappingValue.getMetaProperty("ref-schema");
                  const mappingValueSchemaName = mappingValueSchema == null ? void 0 : mappingValueSchema.getMetaProperty("schemaName");
                  const mappingValueSchemaRefBaseURI = (_a2 = mappingValueSchema == null ? void 0 : mappingValueSchema.getMetaProperty("ref-fields")) == null ? void 0 : _a2.get("$refBaseURI");
                  if ((mappingValueSchemaName == null ? void 0 : mappingValueSchemaName.equals(metaSchemaName)) && (!hasAllOfMapping || (mappingValueSchemaRefBaseURI == null ? void 0 : mappingValueSchemaRefBaseURI.equals(metaRefFields == null ? void 0 : metaRefFields.$refBaseURI)))) {
                    normalizedMapping.set(serializer(mappingKey), cloneShallow(item));
                    hasMatchingMapping = true;
                  }
                });
                if (!hasMatchingMapping) {
                  normalizedMapping.set(metaSchemaName, cloneShallow(item));
                }
              }
            });
            const mappingKeys = mapping.keys();
            const normalizedMappingKeys = normalizedMapping.keys();
            isNormalized = isNormalized && normalizedMapping.filter((mappingValue) => !isSchemaElement(mappingValue)).length === 0 && mappingKeys.every((mappingKey) => normalizedMappingKeys.includes(mappingKey));
            if (isNormalized) {
              schemaElement.discriminator.set("x-normalized-mapping", normalizedMapping);
              visit$1(
                schemaElement,
                {},
                {
                  // @ts-ignore
                  detectCyclesCallback: (node, nodeKey, nodeParent) => {
                    if (!nodeParent || !isMemberElement(node) || !isStringElement(node.key) || !node.key.equals("discriminator") || !isDiscriminatorElement(node.value)) {
                      return;
                    }
                    const discriminator = cloneShallow(node.value);
                    const discriminatorCopy = new Discriminator();
                    if (discriminator.get("mapping")) {
                      discriminatorCopy.mapping = discriminator.get("mapping");
                    }
                    if (discriminator.get("propertyName")) {
                      discriminatorCopy.propertyName = discriminator.get("propertyName");
                    }
                    nodeParent[nodeKey] = new minimExports.MemberElement(
                      new minimExports.StringElement("discriminator"),
                      discriminatorCopy
                    );
                  }
                }
              );
              storage.append(schemaJSONPointer);
            }
          }
        }
      }
    };
  };

  // copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>
  //   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>
  //
  // Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)
  function grammar() {
    // ```
    // SUMMARY
    //      rules = 8
    //       udts = 0
    //    opcodes = 28
    //        ---   ABNF original opcodes
    //        ALT = 5
    //        CAT = 3
    //        REP = 3
    //        RNM = 6
    //        TLS = 5
    //        TBS = 1
    //        TRG = 5
    //        ---   SABNF superset opcodes
    //        UDT = 0
    //        AND = 0
    //        NOT = 0
    // characters = [0 - 1114111]
    // ```
    /* OBJECT IDENTIFIER (for internal parser use) */
    this.grammarObject = 'grammarObject';

    /* RULES */
    this.rules = [];
    this.rules[0] = {
      name: 'json-pointer',
      lower: 'json-pointer',
      index: 0,
      isBkr: false
    };
    this.rules[1] = {
      name: 'reference-token',
      lower: 'reference-token',
      index: 1,
      isBkr: false
    };
    this.rules[2] = {
      name: 'unescaped',
      lower: 'unescaped',
      index: 2,
      isBkr: false
    };
    this.rules[3] = {
      name: 'escaped',
      lower: 'escaped',
      index: 3,
      isBkr: false
    };
    this.rules[4] = {
      name: 'array-location',
      lower: 'array-location',
      index: 4,
      isBkr: false
    };
    this.rules[5] = {
      name: 'array-index',
      lower: 'array-index',
      index: 5,
      isBkr: false
    };
    this.rules[6] = {
      name: 'array-dash',
      lower: 'array-dash',
      index: 6,
      isBkr: false
    };
    this.rules[7] = {
      name: 'slash',
      lower: 'slash',
      index: 7,
      isBkr: false
    };

    /* UDTS */
    this.udts = [];

    /* OPCODES */
    /* json-pointer */
    this.rules[0].opcodes = [];
    this.rules[0].opcodes[0] = {
      type: 3,
      min: 0,
      max: Infinity
    }; // REP
    this.rules[0].opcodes[1] = {
      type: 2,
      children: [2, 3]
    }; // CAT
    this.rules[0].opcodes[2] = {
      type: 4,
      index: 7
    }; // RNM(slash)
    this.rules[0].opcodes[3] = {
      type: 4,
      index: 1
    }; // RNM(reference-token)

    /* reference-token */
    this.rules[1].opcodes = [];
    this.rules[1].opcodes[0] = {
      type: 3,
      min: 0,
      max: Infinity
    }; // REP
    this.rules[1].opcodes[1] = {
      type: 1,
      children: [2, 3]
    }; // ALT
    this.rules[1].opcodes[2] = {
      type: 4,
      index: 2
    }; // RNM(unescaped)
    this.rules[1].opcodes[3] = {
      type: 4,
      index: 3
    }; // RNM(escaped)

    /* unescaped */
    this.rules[2].opcodes = [];
    this.rules[2].opcodes[0] = {
      type: 1,
      children: [1, 2, 3]
    }; // ALT
    this.rules[2].opcodes[1] = {
      type: 5,
      min: 0,
      max: 46
    }; // TRG
    this.rules[2].opcodes[2] = {
      type: 5,
      min: 48,
      max: 125
    }; // TRG
    this.rules[2].opcodes[3] = {
      type: 5,
      min: 127,
      max: 1114111
    }; // TRG

    /* escaped */
    this.rules[3].opcodes = [];
    this.rules[3].opcodes[0] = {
      type: 2,
      children: [1, 2]
    }; // CAT
    this.rules[3].opcodes[1] = {
      type: 7,
      string: [126]
    }; // TLS
    this.rules[3].opcodes[2] = {
      type: 1,
      children: [3, 4]
    }; // ALT
    this.rules[3].opcodes[3] = {
      type: 7,
      string: [48]
    }; // TLS
    this.rules[3].opcodes[4] = {
      type: 7,
      string: [49]
    }; // TLS

    /* array-location */
    this.rules[4].opcodes = [];
    this.rules[4].opcodes[0] = {
      type: 1,
      children: [1, 2]
    }; // ALT
    this.rules[4].opcodes[1] = {
      type: 4,
      index: 5
    }; // RNM(array-index)
    this.rules[4].opcodes[2] = {
      type: 4,
      index: 6
    }; // RNM(array-dash)

    /* array-index */
    this.rules[5].opcodes = [];
    this.rules[5].opcodes[0] = {
      type: 1,
      children: [1, 2]
    }; // ALT
    this.rules[5].opcodes[1] = {
      type: 6,
      string: [48]
    }; // TBS
    this.rules[5].opcodes[2] = {
      type: 2,
      children: [3, 4]
    }; // CAT
    this.rules[5].opcodes[3] = {
      type: 5,
      min: 49,
      max: 57
    }; // TRG
    this.rules[5].opcodes[4] = {
      type: 3,
      min: 0,
      max: Infinity
    }; // REP
    this.rules[5].opcodes[5] = {
      type: 5,
      min: 48,
      max: 57
    }; // TRG

    /* array-dash */
    this.rules[6].opcodes = [];
    this.rules[6].opcodes[0] = {
      type: 7,
      string: [45]
    }; // TLS

    /* slash */
    this.rules[7].opcodes = [];
    this.rules[7].opcodes[0] = {
      type: 7,
      string: [47]
    }; // TLS

    // The `toString()` function will display the original grammar file(s) that produced these opcodes.
    this.toString = function toString() {
      let str = "";
      str += "; JavaScript Object Notation (JSON) Pointer ABNF syntax\n";
      str += "; https://datatracker.ietf.org/doc/html/rfc6901\n";
      str += "json-pointer    = *( slash reference-token ) ; MODIFICATION: surrogate text rule used\n";
      str += "reference-token = *( unescaped / escaped )\n";
      str += "unescaped       = %x00-2E / %x30-7D / %x7F-10FFFF\n";
      str += "                ; %x2F ('/') and %x7E ('~') are excluded from 'unescaped'\n";
      str += "escaped         = \"~\" ( \"0\" / \"1\" )\n";
      str += "                ; representing '~' and '/', respectively\n";
      str += "\n";
      str += "; https://datatracker.ietf.org/doc/html/rfc6901#section-4\n";
      str += "array-location  = array-index / array-dash\n";
      str += "array-index     = %x30 / ( %x31-39 *(%x30-39) )\n";
      str += "                ; \"0\", or digits without a leading \"0\"\n";
      str += "array-dash      = \"-\"\n";
      str += "\n";
      str += "; Surrogate named rules\n";
      str += "slash           = \"/\"\n";
      return str;
    };
  }

  class JSONPointerError extends Error {
    constructor(message, options = undefined) {
      super(message, options);
      this.name = this.constructor.name;
      if (typeof message === 'string') {
        this.message = message;
      }
      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }

      /**
       * This needs to stay here until our minimum supported version of Node.js is >= 16.9.0.
       * Node.js is >= 16.9.0 supports error causes natively.
       */
      if (options != null && typeof options === 'object' && Object.prototype.hasOwnProperty.call(options, 'cause') && !('cause' in this)) {
        const {
          cause
        } = options;
        this.cause = cause;
        if (cause instanceof Error && 'stack' in cause) {
          this.stack = `${this.stack}\nCAUSE: ${cause.stack}`;
        }
      }

      /**
       * Allows to assign arbitrary properties to the error object.
       */
      if (options != null && typeof options === 'object') {
        const {
          cause,
          ...causelessOptions
        } = options;
        Object.assign(this, causelessOptions);
      }
    }
  }

  new grammar();

  new grammar();

  new grammar();

  new grammar();

  new grammar();

  const escape = referenceToken => {
    if (typeof referenceToken !== 'string' && typeof referenceToken !== 'number') {
      throw new TypeError('Reference token must be a string or number');
    }
    return String(referenceToken).replace(/~/g, '~0').replace(/\//g, '~1');
  };

  class JSONPointerCompileError extends JSONPointerError {}

  const compile = referenceTokens => {
    if (!Array.isArray(referenceTokens)) {
      throw new TypeError('Reference tokens must be a list of strings or numbers');
    }
    try {
      if (referenceTokens.length === 0) {
        return '';
      }
      return `/${referenceTokens.map(referenceToken => {
      if (typeof referenceToken !== 'string' && typeof referenceToken !== 'number') {
        throw new TypeError('Reference token must be a string or number');
      }
      return escape(String(referenceToken));
    }).join('/')}`;
    } catch (error) {
      throw new JSONPointerCompileError('Unexpected error during JSON Pointer compilation', {
        cause: error,
        referenceTokens
      });
    }
  };

  var __defProp$1 = Object.defineProperty;
  var __defProps$1 = Object.defineProperties;
  var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
  var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
  var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$1 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1)
      for (var prop of __getOwnPropSymbols$1(b)) {
        if (__propIsEnum$1.call(b, prop))
          __defNormalProp$1(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
  const ancestorLineageToJSONPointer = (elementPath) => {
    const jsonPointerTokens = elementPath.reduce((path, element, index) => {
      if (isMemberElement(element)) {
        const token = String(serializer(element.key));
        path.push(token);
      } else if (isArrayElement(elementPath[index - 2])) {
        const token = String(elementPath[index - 2].content.indexOf(element));
        path.push(token);
      }
      return path;
    }, []);
    return compile(jsonPointerTokens);
  };
  const createToolbox = () => {
    const namespace = createNamespace(openApi3_1);
    const predicates = __spreadProps$1(__spreadValues$1({}, openApi3_1Predicates), {
      isElement,
      isStringElement,
      isArrayElement,
      isObjectElement,
      isMemberElement,
      isServersElement,
      includesClasses,
      hasElementSourceMap
    });
    return { predicates, ancestorLineageToJSONPointer, namespace };
  };

  class OpenApi3_1Visitor extends Mixin(FixedFieldsVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new OpenApi3_1();
      this.specPath = always(["document", "objects", "OpenApi"]);
      this.canSupportSpecificationExtensions = true;
      this.openApiSemanticElement = this.element;
    }
    ObjectElement(objectElement) {
      this.openApiGenericElement = objectElement;
      return FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);
    }
  }

  const BaseInfoVisitor = specification$5.visitors.document.objects.Info.$visitor;
  class InfoVisitor extends BaseInfoVisitor {
    constructor(options) {
      super(options);
      this.element = new Info();
    }
  }

  const BaseContactVisitor = specification$5.visitors.document.objects.Contact.$visitor;
  class ContactVisitor extends BaseContactVisitor {
    constructor(options) {
      super(options);
      this.element = new Contact();
    }
  }

  const BaseLicenseVisitor = specification$5.visitors.document.objects.License.$visitor;
  class LicenseVisitor extends BaseLicenseVisitor {
    constructor(options) {
      super(options);
      this.element = new License();
    }
  }

  const BaseLinkVisitor = specification$5.visitors.document.objects.Link.$visitor;
  class LinkVisitor extends BaseLinkVisitor {
    constructor(options) {
      super(options);
      this.element = new Link();
    }
  }

  class JsonSchemaDialectVisitor extends Mixin(SpecificationVisitor, FallbackVisitor) {
    StringElement(stringElement) {
      const jsonSchemaDialectElement = new JsonSchemaDialect(serializer(stringElement));
      this.copyMetaAndAttributes(stringElement, jsonSchemaDialectElement);
      this.element = jsonSchemaDialectElement;
      return BREAK;
    }
  }

  const BaseServerVisitor = specification$5.visitors.document.objects.Server.$visitor;
  class ServerVisitor extends BaseServerVisitor {
    constructor(options) {
      super(options);
      this.element = new Server();
    }
  }

  const BaseServerVariableVisitor = specification$5.visitors.document.objects.ServerVariable.$visitor;
  class ServerVariableVisitor extends BaseServerVariableVisitor {
    constructor(options) {
      super(options);
      this.element = new ServerVariable();
    }
  }

  const BaseMediaTypeVisitor = specification$5.visitors.document.objects.MediaType.$visitor;
  class MediaTypeVisitor extends BaseMediaTypeVisitor {
    constructor(options) {
      super(options);
      this.element = new MediaType();
    }
  }

  const BaseSecurityRequirementVisitor = specification$5.visitors.document.objects.SecurityRequirement.$visitor;
  class SecurityRequirementVisitor extends BaseSecurityRequirementVisitor {
    constructor(options) {
      super(options);
      this.element = new SecurityRequirement();
    }
  }

  const BaseComponentsVisitor = specification$5.visitors.document.objects.Components.$visitor;
  class ComponentsVisitor extends BaseComponentsVisitor {
    constructor(options) {
      super(options);
      this.element = new Components();
    }
  }

  const BaseTagVisitor = specification$5.visitors.document.objects.Tag.$visitor;
  class TagVisitor extends BaseTagVisitor {
    constructor(options) {
      super(options);
      this.element = new Tag();
    }
  }

  const BaseReferenceVisitor = specification$5.visitors.document.objects.Reference.$visitor;
  class ReferenceVisitor extends BaseReferenceVisitor {
    constructor(options) {
      super(options);
      this.element = new Reference();
    }
  }

  const BaseParameterVisitor = specification$5.visitors.document.objects.Parameter.$visitor;
  class ParameterVisitor extends BaseParameterVisitor {
    constructor(options) {
      super(options);
      this.element = new Parameter();
    }
  }

  const BaseHeaderVisitor = specification$5.visitors.document.objects.Header.$visitor;
  class HeaderVisitor extends BaseHeaderVisitor {
    constructor(options) {
      super(options);
      this.element = new Header();
    }
  }

  class SchemaVisitor extends Mixin(FixedFieldsVisitor, ParentSchemaAwareVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Schema();
      this.specPath = always(["document", "objects", "Schema"]);
      this.canSupportSpecificationExtensions = true;
      this.jsonSchemaDefaultDialect = JsonSchemaDialect.default;
      this.passingOptionsNames.push("parent");
    }
    ObjectElement(objectElement) {
      this.handleDialectIdentifier(objectElement);
      this.handleSchemaIdentifier(objectElement);
      this.parent = this.element;
      const result = FixedFieldsVisitor.prototype.ObjectElement.call(this, objectElement);
      if (isStringElement(this.element.$ref)) {
        this.element.classes.push("reference-element");
        this.element.setMetaProperty("referenced-element", "schema");
      }
      return result;
    }
    BooleanElement(booleanElement) {
      return JSONSchemaVisitor$1.prototype.BooleanElement.call(this, booleanElement);
    }
    /**
     * This function depends on some external context, so we need to make sure this function
     * works even when no context is provided like when directly refracting generic Object Element
     * into Schema Element: `SchemaElement.refract(new ObjectElement({ type: 'object' });`
     */
    get defaultDialectIdentifier() {
      let jsonSchemaDialect;
      if (this.openApiSemanticElement !== void 0 && // @ts-ignore
      isJsonSchemaDialectElement(this.openApiSemanticElement.jsonSchemaDialect)) {
        jsonSchemaDialect = serializer(this.openApiSemanticElement.jsonSchemaDialect);
      } else if (this.openApiGenericElement !== void 0 && isStringElement(this.openApiGenericElement.get("jsonSchemaDialect"))) {
        jsonSchemaDialect = serializer(this.openApiGenericElement.get("jsonSchemaDialect"));
      } else {
        jsonSchemaDialect = serializer(this.jsonSchemaDefaultDialect);
      }
      return jsonSchemaDialect;
    }
    handleDialectIdentifier(objectElement) {
      return JSONSchemaVisitor$1.prototype.handleDialectIdentifier.call(this, objectElement);
    }
    handleSchemaIdentifier(objectElement) {
      return JSONSchemaVisitor$1.prototype.handleSchemaIdentifier.call(this, objectElement);
    }
  }

  class $defsVisitor extends $defsVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class AllOfVisitor extends AllOfVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class AnyOfVisitor extends AnyOfVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class OneOfVisitor extends OneOfVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class DependentSchemasVisitor extends DependentSchemasVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class PrefixItemsVisitor extends PrefixItemsVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class PropertiesVisitor extends PropertiesVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  class PatternPropertiesVisitor extends PatternPropertiesVisitor$1 {
    constructor(options) {
      super(options);
      this.passingOptionsNames.push("parent");
    }
  }

  const BaseDiscriminatorVisitor = specification$5.visitors.document.objects.Discriminator.$visitor;
  class DiscriminatorVisitor extends BaseDiscriminatorVisitor {
    constructor(options) {
      super(options);
      this.element = new Discriminator();
      this.canSupportSpecificationExtensions = true;
    }
  }

  const BaseXMLVisitor = specification$5.visitors.document.objects.XML.$visitor;
  class XmlVisitor extends BaseXMLVisitor {
    constructor(options) {
      super(options);
      this.element = new Xml();
    }
  }

  class SchemasVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsSchemas();
      this.specPath = always(["document", "objects", "Schema"]);
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);
      this.element.filter(isSchemaElement).forEach((schemaElement, schemaName) => {
        schemaElement.setMetaProperty("schemaName", serializer(schemaName));
      });
      return result;
    }
  }

  class PathItemsVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new ComponentsPathItems();
      this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);
      this.element.filter(isReferenceElement).forEach((referenceElement) => {
        referenceElement.setMetaProperty("referenced-element", "pathItem");
      });
      return result;
    }
  }

  const BaseExampleVisitor = specification$5.visitors.document.objects.Example.$visitor;
  class ExampleVisitor extends BaseExampleVisitor {
    constructor(options) {
      super(options);
      this.element = new Example();
    }
  }

  const BaseExternalDocumentationVisitor = specification$5.visitors.document.objects.ExternalDocumentation.$visitor;
  class ExternalDocumentationVisitor extends BaseExternalDocumentationVisitor {
    constructor(options) {
      super(options);
      this.element = new ExternalDocumentation();
    }
  }

  const BaseEncodingVisitor = specification$5.visitors.document.objects.Encoding.$visitor;
  class EncodingVisitor extends BaseEncodingVisitor {
    constructor(options) {
      super(options);
      this.element = new Encoding();
    }
  }

  const BasePathsVisitor = specification$5.visitors.document.objects.Paths.$visitor;
  class PathsVisitor extends BasePathsVisitor {
    constructor(options) {
      super(options);
      this.element = new Paths();
    }
  }

  const BaseRequestBodyVisitor = specification$5.visitors.document.objects.RequestBody.$visitor;
  class RequestBodyVisitor extends BaseRequestBodyVisitor {
    constructor(options) {
      super(options);
      this.element = new RequestBody();
    }
  }

  const BaseCallbackVisitor = specification$5.visitors.document.objects.Callback.$visitor;
  class CallbackVisitor extends BaseCallbackVisitor {
    constructor(options) {
      super(options);
      this.element = new Callback();
      this.specPath = (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
      };
    }
    ObjectElement(objectElement) {
      const result = BaseCallbackVisitor.prototype.ObjectElement.call(this, objectElement);
      this.element.filter(isReferenceElement).forEach((referenceElement) => {
        referenceElement.setMetaProperty("referenced-element", "pathItem");
      });
      return result;
    }
  }

  const BaseResponseVisitor = specification$5.visitors.document.objects.Response.$visitor;
  class ResponseVisitor extends BaseResponseVisitor {
    constructor(options) {
      super(options);
      this.element = new Response();
    }
  }

  const BaseResponsesVisitor = specification$5.visitors.document.objects.Responses.$visitor;
  class ResponsesVisitor extends BaseResponsesVisitor {
    constructor(options) {
      super(options);
      this.element = new Responses();
    }
  }

  const BaseOperationVisitor = specification$5.visitors.document.objects.Operation.$visitor;
  class OperationVisitor extends BaseOperationVisitor {
    constructor(options) {
      super(options);
      this.element = new Operation();
    }
  }

  const BasePathItemVisitor = specification$5.visitors.document.objects.PathItem.$visitor;
  class PathItemVisitor extends BasePathItemVisitor {
    constructor(options) {
      super(options);
      this.element = new PathItem();
    }
  }

  const BaseSecuritySchemeVisitor = specification$5.visitors.document.objects.SecurityScheme.$visitor;
  class SecuritySchemeVisitor extends BaseSecuritySchemeVisitor {
    constructor(options) {
      super(options);
      this.element = new SecurityScheme();
    }
  }

  const BaseOAuthFlowsVisitor = specification$5.visitors.document.objects.OAuthFlows.$visitor;
  class OAuthFlowsVisitor extends BaseOAuthFlowsVisitor {
    constructor(options) {
      super(options);
      this.element = new OAuthFlows();
    }
  }

  const BaseOAuthFlowVisitor = specification$5.visitors.document.objects.OAuthFlow.$visitor;
  class OAuthFlowVisitor extends BaseOAuthFlowVisitor {
    constructor(options) {
      super(options);
      this.element = new OAuthFlow();
    }
  }

  class WebhooksVisitor extends Mixin(MapVisitor, FallbackVisitor) {
    constructor(options) {
      super(options);
      this.element = new Webhooks();
      this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
    }
    ObjectElement(objectElement) {
      const result = MapVisitor.prototype.ObjectElement.call(this, objectElement);
      this.element.filter(isReferenceElement).forEach((referenceElement) => {
        referenceElement.setMetaProperty("referenced-element", "pathItem");
      });
      this.element.filter(isPathItemElement).forEach((pathItemElement, key) => {
        pathItemElement.setMetaProperty("webhook-name", serializer(key));
      });
      return result;
    }
  }

  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  const { JSONSchema: JSONSchemaVisitor, LinkDescription: LinkDescriptionVisitor } = specification$1.visitors.document.objects;
  const specification = {
    visitors: {
      value: specification$5.visitors.value,
      document: {
        objects: {
          OpenApi: {
            $visitor: OpenApi3_1Visitor,
            fixedFields: {
              openapi: specification$5.visitors.document.objects.OpenApi.fixedFields.openapi,
              info: {
                $ref: "#/visitors/document/objects/Info"
              },
              jsonSchemaDialect: JsonSchemaDialectVisitor,
              servers: specification$5.visitors.document.objects.OpenApi.fixedFields.servers,
              paths: {
                $ref: "#/visitors/document/objects/Paths"
              },
              webhooks: WebhooksVisitor,
              components: {
                $ref: "#/visitors/document/objects/Components"
              },
              security: specification$5.visitors.document.objects.OpenApi.fixedFields.security,
              tags: specification$5.visitors.document.objects.OpenApi.fixedFields.tags,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              }
            }
          },
          Info: {
            $visitor: InfoVisitor,
            fixedFields: {
              title: specification$5.visitors.document.objects.Info.fixedFields.title,
              description: specification$5.visitors.document.objects.Info.fixedFields.description,
              summary: { $ref: "#/visitors/value" },
              termsOfService: specification$5.visitors.document.objects.Info.fixedFields.termsOfService,
              contact: {
                $ref: "#/visitors/document/objects/Contact"
              },
              license: {
                $ref: "#/visitors/document/objects/License"
              },
              version: specification$5.visitors.document.objects.Info.fixedFields.version
            }
          },
          Contact: {
            $visitor: ContactVisitor,
            fixedFields: {
              name: specification$5.visitors.document.objects.Contact.fixedFields.name,
              url: specification$5.visitors.document.objects.Contact.fixedFields.url,
              email: specification$5.visitors.document.objects.Contact.fixedFields.email
            }
          },
          License: {
            $visitor: LicenseVisitor,
            fixedFields: {
              name: specification$5.visitors.document.objects.License.fixedFields.name,
              identifier: { $ref: "#/visitors/value" },
              url: specification$5.visitors.document.objects.License.fixedFields.url
            }
          },
          Server: {
            $visitor: ServerVisitor,
            fixedFields: {
              url: specification$5.visitors.document.objects.Server.fixedFields.url,
              description: specification$5.visitors.document.objects.Server.fixedFields.description,
              variables: specification$5.visitors.document.objects.Server.fixedFields.variables
            }
          },
          ServerVariable: {
            $visitor: ServerVariableVisitor,
            fixedFields: {
              enum: specification$5.visitors.document.objects.ServerVariable.fixedFields.enum,
              default: specification$5.visitors.document.objects.ServerVariable.fixedFields.default,
              description: specification$5.visitors.document.objects.ServerVariable.fixedFields.description
            }
          },
          Components: {
            $visitor: ComponentsVisitor,
            fixedFields: {
              schemas: SchemasVisitor,
              responses: specification$5.visitors.document.objects.Components.fixedFields.responses,
              parameters: specification$5.visitors.document.objects.Components.fixedFields.parameters,
              examples: specification$5.visitors.document.objects.Components.fixedFields.examples,
              requestBodies: specification$5.visitors.document.objects.Components.fixedFields.requestBodies,
              headers: specification$5.visitors.document.objects.Components.fixedFields.headers,
              securitySchemes: specification$5.visitors.document.objects.Components.fixedFields.securitySchemes,
              links: specification$5.visitors.document.objects.Components.fixedFields.links,
              callbacks: specification$5.visitors.document.objects.Components.fixedFields.callbacks,
              pathItems: PathItemsVisitor
            }
          },
          Paths: {
            $visitor: PathsVisitor
          },
          PathItem: {
            $visitor: PathItemVisitor,
            fixedFields: {
              $ref: specification$5.visitors.document.objects.PathItem.fixedFields.$ref,
              summary: specification$5.visitors.document.objects.PathItem.fixedFields.summary,
              description: specification$5.visitors.document.objects.PathItem.fixedFields.description,
              get: {
                $ref: "#/visitors/document/objects/Operation"
              },
              put: {
                $ref: "#/visitors/document/objects/Operation"
              },
              post: {
                $ref: "#/visitors/document/objects/Operation"
              },
              delete: {
                $ref: "#/visitors/document/objects/Operation"
              },
              options: {
                $ref: "#/visitors/document/objects/Operation"
              },
              head: {
                $ref: "#/visitors/document/objects/Operation"
              },
              patch: {
                $ref: "#/visitors/document/objects/Operation"
              },
              trace: {
                $ref: "#/visitors/document/objects/Operation"
              },
              servers: specification$5.visitors.document.objects.PathItem.fixedFields.servers,
              parameters: specification$5.visitors.document.objects.PathItem.fixedFields.parameters
            }
          },
          Operation: {
            $visitor: OperationVisitor,
            fixedFields: {
              tags: specification$5.visitors.document.objects.Operation.fixedFields.tags,
              summary: specification$5.visitors.document.objects.Operation.fixedFields.summary,
              description: specification$5.visitors.document.objects.Operation.fixedFields.description,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              },
              operationId: specification$5.visitors.document.objects.Operation.fixedFields.operationId,
              parameters: specification$5.visitors.document.objects.Operation.fixedFields.parameters,
              requestBody: specification$5.visitors.document.objects.Operation.fixedFields.requestBody,
              responses: {
                $ref: "#/visitors/document/objects/Responses"
              },
              callbacks: specification$5.visitors.document.objects.Operation.fixedFields.callbacks,
              deprecated: specification$5.visitors.document.objects.Operation.fixedFields.deprecated,
              security: specification$5.visitors.document.objects.Operation.fixedFields.security,
              servers: specification$5.visitors.document.objects.Operation.fixedFields.servers
            }
          },
          ExternalDocumentation: {
            $visitor: ExternalDocumentationVisitor,
            fixedFields: {
              description: specification$5.visitors.document.objects.ExternalDocumentation.fixedFields.description,
              url: specification$5.visitors.document.objects.ExternalDocumentation.fixedFields.url
            }
          },
          Parameter: {
            $visitor: ParameterVisitor,
            fixedFields: {
              name: specification$5.visitors.document.objects.Parameter.fixedFields.name,
              in: specification$5.visitors.document.objects.Parameter.fixedFields.in,
              description: specification$5.visitors.document.objects.Parameter.fixedFields.description,
              required: specification$5.visitors.document.objects.Parameter.fixedFields.required,
              deprecated: specification$5.visitors.document.objects.Parameter.fixedFields.deprecated,
              allowEmptyValue: specification$5.visitors.document.objects.Parameter.fixedFields.allowEmptyValue,
              style: specification$5.visitors.document.objects.Parameter.fixedFields.style,
              explode: specification$5.visitors.document.objects.Parameter.fixedFields.explode,
              allowReserved: specification$5.visitors.document.objects.Parameter.fixedFields.allowReserved,
              schema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              example: specification$5.visitors.document.objects.Parameter.fixedFields.example,
              examples: specification$5.visitors.document.objects.Parameter.fixedFields.examples,
              content: specification$5.visitors.document.objects.Parameter.fixedFields.content
            }
          },
          RequestBody: {
            $visitor: RequestBodyVisitor,
            fixedFields: {
              description: specification$5.visitors.document.objects.RequestBody.fixedFields.description,
              content: specification$5.visitors.document.objects.RequestBody.fixedFields.content,
              required: specification$5.visitors.document.objects.RequestBody.fixedFields.required
            }
          },
          MediaType: {
            $visitor: MediaTypeVisitor,
            fixedFields: {
              schema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              example: specification$5.visitors.document.objects.MediaType.fixedFields.example,
              examples: specification$5.visitors.document.objects.MediaType.fixedFields.examples,
              encoding: specification$5.visitors.document.objects.MediaType.fixedFields.encoding
            }
          },
          Encoding: {
            $visitor: EncodingVisitor,
            fixedFields: {
              contentType: specification$5.visitors.document.objects.Encoding.fixedFields.contentType,
              headers: specification$5.visitors.document.objects.Encoding.fixedFields.headers,
              style: specification$5.visitors.document.objects.Encoding.fixedFields.style,
              explode: specification$5.visitors.document.objects.Encoding.fixedFields.explode,
              allowReserved: specification$5.visitors.document.objects.Encoding.fixedFields.allowReserved
            }
          },
          Responses: {
            $visitor: ResponsesVisitor,
            fixedFields: {
              default: specification$5.visitors.document.objects.Responses.fixedFields.default
            }
          },
          Response: {
            $visitor: ResponseVisitor,
            fixedFields: {
              description: specification$5.visitors.document.objects.Response.fixedFields.description,
              headers: specification$5.visitors.document.objects.Response.fixedFields.headers,
              content: specification$5.visitors.document.objects.Response.fixedFields.content,
              links: specification$5.visitors.document.objects.Response.fixedFields.links
            }
          },
          Callback: {
            $visitor: CallbackVisitor
          },
          Example: {
            $visitor: ExampleVisitor,
            fixedFields: {
              summary: specification$5.visitors.document.objects.Example.fixedFields.summary,
              description: specification$5.visitors.document.objects.Example.fixedFields.description,
              value: specification$5.visitors.document.objects.Example.fixedFields.value,
              externalValue: specification$5.visitors.document.objects.Example.fixedFields.externalValue
            }
          },
          Link: {
            $visitor: LinkVisitor,
            fixedFields: {
              operationRef: specification$5.visitors.document.objects.Link.fixedFields.operationRef,
              operationId: specification$5.visitors.document.objects.Link.fixedFields.operationId,
              parameters: specification$5.visitors.document.objects.Link.fixedFields.parameters,
              requestBody: specification$5.visitors.document.objects.Link.fixedFields.requestBody,
              description: specification$5.visitors.document.objects.Link.fixedFields.description,
              server: {
                $ref: "#/visitors/document/objects/Server"
              }
            }
          },
          Header: {
            $visitor: HeaderVisitor,
            fixedFields: {
              description: specification$5.visitors.document.objects.Header.fixedFields.description,
              required: specification$5.visitors.document.objects.Header.fixedFields.required,
              deprecated: specification$5.visitors.document.objects.Header.fixedFields.deprecated,
              allowEmptyValue: specification$5.visitors.document.objects.Header.fixedFields.allowEmptyValue,
              style: specification$5.visitors.document.objects.Header.fixedFields.style,
              explode: specification$5.visitors.document.objects.Header.fixedFields.explode,
              allowReserved: specification$5.visitors.document.objects.Header.fixedFields.allowReserved,
              schema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              example: specification$5.visitors.document.objects.Header.fixedFields.example,
              examples: specification$5.visitors.document.objects.Header.fixedFields.examples,
              content: specification$5.visitors.document.objects.Header.fixedFields.content
            }
          },
          Tag: {
            $visitor: TagVisitor,
            fixedFields: {
              name: specification$5.visitors.document.objects.Tag.fixedFields.name,
              description: specification$5.visitors.document.objects.Tag.fixedFields.description,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              }
            }
          },
          Reference: {
            $visitor: ReferenceVisitor,
            fixedFields: {
              $ref: specification$5.visitors.document.objects.Reference.fixedFields.$ref,
              summary: { $ref: "#/visitors/value" },
              description: { $ref: "#/visitors/value" }
            }
          },
          JSONSchema: {
            $ref: "#/visitors/document/objects/Schema"
          },
          LinkDescription: __spreadValues({}, LinkDescriptionVisitor),
          Schema: {
            $visitor: SchemaVisitor,
            fixedFields: __spreadProps(__spreadValues({}, JSONSchemaVisitor.fixedFields), {
              // core vocabulary
              $defs: $defsVisitor,
              // applicator vocabulary
              allOf: AllOfVisitor,
              anyOf: AnyOfVisitor,
              oneOf: OneOfVisitor,
              not: {
                $ref: "#/visitors/document/objects/Schema"
              },
              if: {
                $ref: "#/visitors/document/objects/Schema"
              },
              then: {
                $ref: "#/visitors/document/objects/Schema"
              },
              else: {
                $ref: "#/visitors/document/objects/Schema"
              },
              dependentSchemas: DependentSchemasVisitor,
              prefixItems: PrefixItemsVisitor,
              items: {
                $ref: "#/visitors/document/objects/Schema"
              },
              contains: {
                $ref: "#/visitors/document/objects/Schema"
              },
              properties: PropertiesVisitor,
              patternProperties: PatternPropertiesVisitor,
              additionalProperties: {
                $ref: "#/visitors/document/objects/Schema"
              },
              propertyNames: {
                $ref: "#/visitors/document/objects/Schema"
              },
              // unevaluated Locations vocabulary
              unevaluatedItems: {
                $ref: "#/visitors/document/objects/Schema"
              },
              unevaluatedProperties: {
                $ref: "#/visitors/document/objects/Schema"
              },
              // validation vocabulary
              // contents of String-Encoded Data vocabulary
              contentSchema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              // OAS base vocabulary
              discriminator: {
                $ref: "#/visitors/document/objects/Discriminator"
              },
              xml: {
                $ref: "#/visitors/document/objects/XML"
              },
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              },
              example: { $ref: "#/visitors/value" }
            })
          },
          Discriminator: {
            $visitor: DiscriminatorVisitor,
            fixedFields: {
              propertyName: specification$5.visitors.document.objects.Discriminator.fixedFields.propertyName,
              mapping: specification$5.visitors.document.objects.Discriminator.fixedFields.mapping
            }
          },
          XML: {
            $visitor: XmlVisitor,
            fixedFields: {
              name: specification$5.visitors.document.objects.XML.fixedFields.name,
              namespace: specification$5.visitors.document.objects.XML.fixedFields.namespace,
              prefix: specification$5.visitors.document.objects.XML.fixedFields.prefix,
              attribute: specification$5.visitors.document.objects.XML.fixedFields.attribute,
              wrapped: specification$5.visitors.document.objects.XML.fixedFields.wrapped
            }
          },
          SecurityScheme: {
            $visitor: SecuritySchemeVisitor,
            fixedFields: {
              type: specification$5.visitors.document.objects.SecurityScheme.fixedFields.type,
              description: specification$5.visitors.document.objects.SecurityScheme.fixedFields.description,
              name: specification$5.visitors.document.objects.SecurityScheme.fixedFields.name,
              in: specification$5.visitors.document.objects.SecurityScheme.fixedFields.in,
              scheme: specification$5.visitors.document.objects.SecurityScheme.fixedFields.scheme,
              bearerFormat: specification$5.visitors.document.objects.SecurityScheme.fixedFields.bearerFormat,
              flows: {
                $ref: "#/visitors/document/objects/OAuthFlows"
              },
              openIdConnectUrl: specification$5.visitors.document.objects.SecurityScheme.fixedFields.openIdConnectUrl
            }
          },
          OAuthFlows: {
            $visitor: OAuthFlowsVisitor,
            fixedFields: {
              implicit: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              password: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              clientCredentials: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              authorizationCode: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              }
            }
          },
          OAuthFlow: {
            $visitor: OAuthFlowVisitor,
            fixedFields: {
              authorizationUrl: specification$5.visitors.document.objects.OAuthFlow.fixedFields.authorizationUrl,
              tokenUrl: specification$5.visitors.document.objects.OAuthFlow.fixedFields.tokenUrl,
              refreshUrl: specification$5.visitors.document.objects.OAuthFlow.fixedFields.refreshUrl,
              scopes: specification$5.visitors.document.objects.OAuthFlow.fixedFields.scopes
            }
          },
          SecurityRequirement: {
            $visitor: SecurityRequirementVisitor
          }
        },
        extension: {
          $visitor: specification$5.visitors.document.extension.$visitor
        }
      }
    }
  };

  exports.AlternatingVisitor = AlternatingVisitor;
  exports.CallbackElement = Callback;
  exports.ComponentsCallbacksElement = ComponentsCallbacks;
  exports.ComponentsElement = Components;
  exports.ComponentsExamplesElement = ComponentsExamples;
  exports.ComponentsHeadersElement = ComponentsHeaders;
  exports.ComponentsLinksElement = ComponentsLinks;
  exports.ComponentsParametersElement = ComponentsParameters;
  exports.ComponentsPathItemsElement = ComponentsPathItems;
  exports.ComponentsRequestBodiesElement = ComponentsRequestBodies;
  exports.ComponentsResponsesElement = ComponentsResponses;
  exports.ComponentsSchemasElement = ComponentsSchemas;
  exports.ComponentsSecuritySchemesElement = ComponentsSecuritySchemes;
  exports.ContactElement = Contact;
  exports.DiscriminatorElement = Discriminator;
  exports.DiscriminatorMappingElement = DiscriminatorMapping;
  exports.EncodingElement = Encoding;
  exports.EncodingHeadersElement = EncodingHeaders;
  exports.ExampleElement = Example;
  exports.ExternalDocumentationElement = ExternalDocumentation;
  exports.FallbackVisitor = FallbackVisitor;
  exports.FixedFieldsVisitor = FixedFieldsVisitor;
  exports.HeaderContentElement = HeaderContent;
  exports.HeaderElement = Header;
  exports.HeaderExamplesElement = HeaderExamples;
  exports.InfoElement = Info;
  exports.JsonSchemaDialectElement = JsonSchemaDialect;
  exports.LicenseElement = License;
  exports.LinkElement = Link;
  exports.LinkParametersElement = LinkParameters;
  exports.MapVisitor = MapVisitor;
  exports.MediaTypeElement = MediaType;
  exports.MediaTypeEncodingElement = MediaTypeEncoding;
  exports.MediaTypeExamplesElement = MediaTypeExamples;
  exports.MixedFieldsVisitor = MixedFieldsVisitor;
  exports.OAuthFlowElement = OAuthFlow;
  exports.OAuthFlowScopesElement = OAuthFlowScopes;
  exports.OAuthFlowsElement = OAuthFlows;
  exports.OpenAPIMediaTypes = OpenAPIMediaTypes;
  exports.OpenApi3_1Element = OpenApi3_1;
  exports.OpenapiElement = Openapi;
  exports.OperationCallbacksElement = OperationCallbacks;
  exports.OperationElement = Operation;
  exports.OperationParametersElement = OperationParameters;
  exports.OperationSecurityElement = OperationSecurity;
  exports.OperationServersElement = OperationServers;
  exports.OperationTagsElement = OperationTags;
  exports.ParameterContentElement = ParameterContent;
  exports.ParameterElement = Parameter;
  exports.ParameterExamplesElement = ParameterExamples;
  exports.PathItemElement = PathItem;
  exports.PathItemParametersElement = PathItemParameters;
  exports.PathItemServersElement = PathItemServers;
  exports.PathsElement = Paths;
  exports.PatternedFieldsVisitor = PatternedFieldsVisitor;
  exports.ReferenceElement = Reference;
  exports.RequestBodyContentElement = RequestBodyContent;
  exports.RequestBodyElement = RequestBody;
  exports.ResponseContentElement = ResponseContent;
  exports.ResponseElement = Response;
  exports.ResponseHeadersElement = ResponseHeaders;
  exports.ResponseLinksElement = ResponseLinks;
  exports.ResponsesElement = Responses;
  exports.SchemaElement = Schema;
  exports.SecurityElement = Security;
  exports.SecurityRequirementElement = SecurityRequirement;
  exports.SecuritySchemeElement = SecurityScheme;
  exports.ServerElement = Server;
  exports.ServerVariableElement = ServerVariable;
  exports.ServerVariablesElement = ServerVariables;
  exports.ServersElement = Servers;
  exports.SpecificationExtensionVisitor = SpecificationExtensionVisitor;
  exports.SpecificationVisitor = SpecificationVisitor;
  exports.TagElement = Tag;
  exports.TagsElement = Tags;
  exports.Visitor = Visitor;
  exports.WebhooksElement = Webhooks;
  exports.XmlElement = Xml;
  exports.createToolbox = createToolbox;
  exports.default = openApi3_1;
  exports.getNodeType = getNodeType;
  exports.isArrayElement = isArrayElement;
  exports.isBooleanElement = isBooleanElement;
  exports.isBooleanJsonSchemaElement = isBooleanJsonSchemaElement;
  exports.isCallbackElement = isCallbackElement;
  exports.isComponentsElement = isComponentsElement;
  exports.isContactElement = isContactElement;
  exports.isElement = isElement;
  exports.isExampleElement = isExampleElement;
  exports.isExternalDocumentationElement = isExternalDocumentationElement;
  exports.isInfoElement = isInfoElement;
  exports.isJsonSchemaDialectElement = isJsonSchemaDialectElement;
  exports.isLicenseElement = isLicenseElement;
  exports.isLinkElement = isLinkElement;
  exports.isLinkPrimitiveElement = isLinkElement$2;
  exports.isMediaTypeElement = isMediaTypeElement;
  exports.isMemberElement = isMemberElement;
  exports.isNullElement = isNullElement;
  exports.isNumberElement = isNumberElement;
  exports.isObjectElement = isObjectElement;
  exports.isOpenApi3_1Element = isOpenApi3_1Element;
  exports.isOpenApiExtension = isOpenApiExtension;
  exports.isOpenapiElement = isOpenapiElement;
  exports.isOperationElement = isOperationElement;
  exports.isParameterElement = isParameterElement;
  exports.isPathItemElement = isPathItemElement;
  exports.isPathItemElementExternal = isPathItemElementExternal;
  exports.isPathsElement = isPathsElement;
  exports.isRefElement = isRefElement;
  exports.isReferenceElement = isReferenceElement;
  exports.isReferenceElementExternal = isReferenceElementExternal;
  exports.isReferenceLikeElement = isReferenceLikeElement;
  exports.isRequestBodyElement = isRequestBodyElement;
  exports.isResponseElement = isResponseElement;
  exports.isResponsesElement = isResponsesElement;
  exports.isSchemaElement = isSchemaElement;
  exports.isSecurityRequirementElement = isSecurityRequirementElement;
  exports.isSecuritySchemeElement = isSecuritySchemeElement;
  exports.isServerElement = isServerElement;
  exports.isServerLikeElement = isServerLikeElement;
  exports.isServerVariableElement = isServerVariableElement;
  exports.isServersElement = isServersElement;
  exports.isStringElement = isStringElement;
  exports.keyMap = keyMap;
  exports.mediaTypes = mediaTypes;
  exports.refractorPluginNormalizeDiscriminatorMapping = plugin;
  exports.refractorPluginNormalizeHeaderExamples = plugin$1;
  exports.refractorPluginNormalizeOperationIds = plugin$3;
  exports.refractorPluginNormalizeParameterExamples = plugin$2;
  exports.refractorPluginNormalizeParameters = plugin$6;
  exports.refractorPluginNormalizeSecurityRequirements = plugin$5;
  exports.refractorPluginNormalizeServers = plugin$4;
  exports.refractorPluginReplaceEmptyElement = plugin$7;
  exports.specificationObj = specification;

  Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: 'Module' } });

}));
